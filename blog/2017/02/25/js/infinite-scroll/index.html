<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>设计高性能无限滚动加载，了解高效页面秘密 | exp team</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="UX Planet论坛上有过这么一篇热门文章: Infinite Scrolling Best Practices，它从UX角度分析了无限滚动加载的设计实践。
无限滚动加载在互联网上到处都有应用：豆瓣首页是一个，Facebook的Timeline是一个，Tweeter的话题列表也是一个。当你向下滚动，新的内容就神奇的“无中生有”了。这是一个得到广泛赞扬的用户体验。
无限滚动加载背后的技术挑战其实比">
<meta property="og:type" content="article">
<meta property="og:title" content="设计高性能无限滚动加载，了解高效页面秘密">
<meta property="og:url" content="https://exp-team.github.io/blog/2017/02/25/js/infinite-scroll/index.html">
<meta property="og:site_name" content="exp team">
<meta property="og:description" content="UX Planet论坛上有过这么一篇热门文章: Infinite Scrolling Best Practices，它从UX角度分析了无限滚动加载的设计实践。
无限滚动加载在互联网上到处都有应用：豆瓣首页是一个，Facebook的Timeline是一个，Tweeter的话题列表也是一个。当你向下滚动，新的内容就神奇的“无中生有”了。这是一个得到广泛赞扬的用户体验。
无限滚动加载背后的技术挑战其实比">
<meta property="og:image" content="https://exp-team.github.io/bimg/s1.png">
<meta property="og:image" content="https://exp-team.github.io/bimg/s2.jpg">
<meta property="og:image" content="https://exp-team.github.io/bimg/s3.gif">
<meta property="og:image" content="https://exp-team.github.io/bimg/s4.png">
<meta property="og:image" content="https://exp-team.github.io/bimg/s5.png">
<meta property="og:image" content="https://exp-team.github.io/bimg/s6.jpg">
<meta property="og:updated_time" content="2017-03-06T10:31:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计高性能无限滚动加载，了解高效页面秘密">
<meta name="twitter:description" content="UX Planet论坛上有过这么一篇热门文章: Infinite Scrolling Best Practices，它从UX角度分析了无限滚动加载的设计实践。
无限滚动加载在互联网上到处都有应用：豆瓣首页是一个，Facebook的Timeline是一个，Tweeter的话题列表也是一个。当你向下滚动，新的内容就神奇的“无中生有”了。这是一个得到广泛赞扬的用户体验。
无限滚动加载背后的技术挑战其实比">
<meta name="twitter:image" content="https://exp-team.github.io/bimg/s1.png">
  
    <link rel="alternate" href="/atom.xml" title="exp team" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b549e90ef81d82146548abb71d982d0e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">exp team</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">together, stronger</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://exp-team.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-js/infinite-scroll" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/02/25/js/infinite-scroll/" class="article-date">
  <time datetime="2017-02-24T16:00:00.000Z" itemprop="datePublished">2017-02-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      设计高性能无限滚动加载，了解高效页面秘密
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>UX Planet论坛上有过这么一篇<a href="https://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11" target="_blank" rel="external">热门文章: Infinite Scrolling Best Practices</a>，它从UX角度分析了无限滚动加载的设计实践。</p>
<p>无限滚动加载在互联网上到处都有应用：<br>豆瓣首页是一个，Facebook的Timeline是一个，Tweeter的话题列表也是一个。当你向下滚动，新的内容就神奇的“无中生有”了。这是一个得到广泛赞扬的用户体验。</p>
<p>无限滚动加载背后的技术挑战其实比想象中要多不少。尤其是要考虑页面性能，需要做到极致。<br>本文通过代码实例，来实现一个无限滚动加载效果。更重要的是，在实现过程中，对于页面性能的分析和处理力图做到最大化，希望对读者有所启发，同时也欢迎与我讨论。</p>
<h2 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h2><p>在开启我们的代码之前，有必要先了解一下常用的性能测量手段：</p>
<p>1）使用window.performance </p>
<p>HTML5带来的performance API功能强大。我们可以使用其performance.now()精确计算程序执行时间。performance.now()与Date.now()不同的是，返回了以微秒（百万分之一秒）为单位的时间，更加精准。并且与 Date.now() 会受系统程序执行阻塞的影响不同，performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。<br>同时，也可以使用performance.mark()标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。</p>
<p>2）使用console.time方法与console.timeEnd方法</p>
<p>其中console.time方法用于标记开始时间，console.timeEnd方法用于标记结束时间，并且将结束时间与开始时间之间经过的毫秒数在控制台中输出。</p>
<p>3）使用专业的测量工具／平台：jsPerf</p>
<p>这次实现中，我们使用第二种方法，因为它已经完全可以满足我们的需求，且兼容性更加全面。</p>
<h2 id="整体思路和方案设计"><a href="#整体思路和方案设计" class="headerlink" title="整体思路和方案设计"></a>整体思路和方案设计</h2><p>我们要实现的页面样例如图，</p>
<p><img src="/bimg/s1.png" alt=""></p>
<p>它能够做到无限下拉加载内容。我把红线标出的部分叫做一个block-item，后续也都用这种命名。</p>
<p>1）关于设计方案，肯定第一个最基本、最朴素的思想是下拉到底部之后发送ajax异步请求，成功之后的回调里进行页面拼接。</p>
<p>2）但是观察页面布局，很明显图片较多，每一个block-item区块都有一张配图。当加载后的内容插入到页面中时，浏览器就开始获取图片。这意味着所有的图像同时下载，浏览器中的下载通道将被占满。同时，由于内容优先于用户浏览而加载，所以可能被迫下载底部那些永远也不会被用户浏览到的图像。<br>所以，我们需要设计一个懒加载效果，使得页面速度更快，并且节省用户的流量费用和延长电池寿命。</p>
<p>3）上一条提到的懒加载实现上，为了避免到真正的页面底部时才进行加载和渲染，而造成用户较长时间等待。我们可以设置一个合理阈值，在用户滚动到页面底部之前，先进行提前加载。</p>
<p>4）另外，页面滚动的事件肯定是需要监听的。同时，页面滚动问题也比较棘手，后面将专为滚动进行分析。</p>
<p>5）DOM操作我们知道是及其缓慢而低效的，有兴趣的同学可以研究一下jsPerf上一些经典的benchmark，比如<a href="http://jsperf.com/jquery-cache-vs-dom-querying" target="_blank" rel="external">这篇</a>。关于造成这种缓慢的原因，社区上同样有很多文章有过分析，这里就不再深入。但我想总结并补充的是：DOM操作，光是为了找一个节点，就从本质上比简单的检索内存中的值要慢。一些DOM操作还需要重新计算样式来读取或检索一个值。更突出的问题在于：DOM操作是阻塞的，所以当有一个DOM操作在进行时，其他的什么都不能做，包括用户与页面的交互（除了滚动）。这是一个极度伤害用户体验的事实。</p>
<p>所以，在下面的效果实现中，我采用了大量“不可思议”的DOM缓存，甚至极端的缓存everything。当然，这样做的收益也在最后部分有所展现。</p>
<h3 id="滚动问题"><a href="#滚动问题" class="headerlink" title="滚动问题"></a>滚动问题</h3><p>滚动问题不难想象在于高频率的触发滚动事件处理上。具我亲测，在极端case下，滚动及其卡顿。即使滚动不卡顿，你可以打开Chrome控制台发现，帧速率也非常慢。关于帧速率的问题，我们有著名的16.7毫秒理论。关于这个时间分析，社区上也有不少文章阐述，这里不再展开。</p>
<p>针对于此，有很多读者会立刻想到“截流和防抖动函数”（Throttle和Debounce）。<br>简单总结一下：</p>
<p>1）Throttle允许我们限制激活响应的数量。我们可以限制每秒回调的数量。反过来，也就是说在激活下一个回调之前要等待多少时间;</p>
<p>2）Debounce意味着当事件发生时，我们不会立即激活回调。相反，我们等待一定的时间并检查相同的事件是否再次触发。如果是，我们重置定时器，并再次等待。如果在等待期间没有发生相同的事件，我们就立即激活回调。</p>
<p>具体这里就不代码实现了。原理明白之后，应该不难写出。</p>
<p>但是我这里想从移动端主要浏览器处理滚动的方式入手，来思考这个问题：</p>
<p>1）在Android机器上，用户滚动屏幕时，滚动事件高频率发生——在Galaxy－SIII手机上，大约频率是一秒一百次。这意味着，滚动处理函数也被调用了数百次，而这些又都是成本较大的函数。</p>
<p>2）在Safari浏览器上，我们遇到的问题恰恰是相反的：用户每次滚动屏幕时，滚动事件只在滚动动画停止时才触发。当用户在iPhone上滚动屏幕时，不会运行更新界面的代码（滚动停止时才会运行一次）。</p>
<p>另外，我想也许会有读者想到rAf（requestAnimationFrame），但是据我观察，很多前端其实并不明白requestAnimationFrame技术的原理和解决的问题。只是机械地把动画性能、掉帧问题甩到这么一个名词上。在真实项目中，也没有亲自实现过，更不要说考虑requestAnimationFrame的兼容性情况了。这里场景我并不会使用rAf，因为。setTimeout的定时器值推荐最小使用16.7ms（原因请去社区上找答案，不再细讲），我们这里并不会超过这个限制，并且考虑兼容性。关于这项技术的使用，如果有问题，欢迎留言讨论。</p>
<p>基于以上，我的解决方案是既不同于Throttle，也不同于Debounce，但是和这两个思想，尤其是Throttle又比较类似：把滚动事件替换为一个带有计时器的滚动处理程序，每100毫秒进行简单检查，看这段时间内用户是否滚动过。如果没有，则什么都不做；如果有，就进行处理。</p>
<h3 id="用户体验优化小窍门"><a href="#用户体验优化小窍门" class="headerlink" title="用户体验优化小窍门"></a>用户体验优化小窍门</h3><p>在图像加载完成时，使用淡入（fade in）效果出现。这在实际情况上会稍微慢一下，应该慢一个过渡执行时间。但用户体验上感觉会更快。这是已经被证实且普遍应用的小“trick”。但是据我感觉，它确实有效。我们的代码实现也采用了这个小窍门。不过类似这种“社会心理学”范畴的东西，显然不是本文研究的重点。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>代码上将会采用：超前阈值的懒加载＋DOM Cache和图片Cache＋滚动throttle模拟＋CSS fadeIn动画。<br>具体功能封装上和一些实现层面的东西，请您继续阅读。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h3><p>整体结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"exp-list-box"</span> <span class="attr">id</span>=<span class="string">"expListBox"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"exp-list"</span> <span class="attr">id</span>=<span class="string">"expList"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui-refresh-down"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>主体内容放在id为“expListBox”的container里面，id为“expList”的ul是页面加载内容的容器。<br>因为每次加载并append进入HTML的内容相对较多。我使用了模版来取代传统的字符串拼接。前端模版这次选用了我的同事<a href="https://github.com/yanhaijing/template.js" target="_blank" rel="external">颜海镜大神的开源作品</a>，模版结构为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">#dataList.forEach(function</span> (<span class="attr">v</span>) &#123;#&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="attr">class</span>=<span class="string">"slide"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;#=v.href#&gt;"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"img"</span> <span class="attr">src</span>=<span class="string">"data:image/gif;base64,R0lGODdhAQABAPAAAP%2F%2F%2FwAAACwAAAAAAQABAEACAkQBADs%3D"</span> </span></div><div class="line">                <span class="attr">data-src</span>=<span class="string">"&lt;#=v.src#&gt;"</span>&gt;</div><div class="line">                <span class="tag">&lt;/<span class="name">img</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.title#</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"writer"</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.writer#</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"good-num"</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.succNum#</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">#&#125;)#</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上模版内容由每次ajax请求到的数据填充，并添加进入页面，构成每个block-item。<br>这里需要注意观察，有助于对后面逻辑的理解。页面中一个block-item下div属性存有该block-item的eid值，对应class叫做”slide”，子孙节点包含有一个image标签，src初始赋值为1px的空白图进行占位。真实图片资源位置存储在”data-src”中。<br>另外，请求返回的数据dataList可以理解为由9个对象构成的数组，也就是说，每次请求加载9个block-item。</p>
<h3 id="样式亮点"><a href="#样式亮点" class="headerlink" title="样式亮点"></a>样式亮点</h3><p>样式方面不是这篇文章的重点，挑选最核心的一行来说明一下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.slide</span> <span class="selector-class">.img</span>&#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">90px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">-webkit-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">-moz-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">-o-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唯一需要注意的是image的opacity设置为0，图片将会在成功请求并渲染后调整为1，辅助transition属性实现一个fade in效果。<br>对应我们上面所提到的那个“trick”</p>
<h3 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h3><p>我是完全按照业务需求来设计，并没有做抽象。其实这样的一个下拉加载功能完全可以抽象出来。有兴趣的读者可以下去自己进行封装和抽象。<br>我们先把精力集中在逻辑处理上。<br>下面进入我们最核心的逻辑部分，为了防止全局污染，我把它放入了一个立即执行函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fetching = <span class="literal">false</span>; </div><div class="line">    <span class="keyword">var</span> page = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> slideCache = [];</div><div class="line">    <span class="keyword">var</span> itemMap = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> lastScrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line">    <span class="keyword">var</span> scrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line">    <span class="keyword">var</span> innerHeight;</div><div class="line">    <span class="keyword">var</span> topViewPort;</div><div class="line">    <span class="keyword">var</span> bottomViewPort;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isVisible</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...判断元素是否在可见区域</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateItemCache</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="comment">// ....更新DOM缓存</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fetchContent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...ajax请求数据</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleDefer</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...懒加载实现</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleScroll</span> (<span class="params">e, force</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...滚动处理程序</span></div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">    fetchContent();</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>我认为好的编程习惯是在程序开头部分便声明所有的变量，防止“变量提升”带来的潜在困扰，并且也有利于程序的整体把控。<br>我们来看一下变量设置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加载中状态锁</span></div><div class="line"><span class="number">1</span>）<span class="keyword">var</span> fetching = <span class="literal">false</span>;</div><div class="line"><span class="comment">// 用于加载时发送请求参数，表示第几屏内容，初始为1，以后每请求一次，递增1</span></div><div class="line"><span class="number">2</span>）<span class="keyword">var</span> page = <span class="number">1</span>; </div><div class="line"><span class="comment">// 只缓存最新一次下拉数据生成的DOM节点，即需要插入的dom缓存数组</span></div><div class="line"><span class="number">3</span>）<span class="keyword">var</span> slideCache = []; </div><div class="line"><span class="comment">// 用于已经生成的DOM节点储存，存有item的offsetTop，offsetHeight</span></div><div class="line"><span class="number">4</span>) <span class="keyword">var</span> slideMap = &#123;&#125;; </div><div class="line"><span class="comment">// pageYOffset设置或返回当前页面相对于窗口显示区左上角的Y位置。</span></div><div class="line"><span class="number">5</span>）<span class="keyword">var</span> lastScrollY = <span class="built_in">window</span>.pageYOffset; <span class="keyword">var</span> scrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line"><span class="comment">// 浏览器窗口的视口（viewport）高度</span></div><div class="line"><span class="number">6</span>）<span class="keyword">var</span> innerHeight;</div><div class="line"><span class="comment">// isVisible的上下阈值边界</span></div><div class="line"><span class="number">7</span>) <span class="keyword">var</span> topViewPort; </div><div class="line"><span class="number">8</span>) <span class="keyword">var</span> bottomViewPort;</div></pre></td></tr></table></figure>
<p>关于DOM cache的变量详细说明，在后文有提供。</p>
<p>同样，我们有5个函数。在上面的代码中，注释已经写明白了每个方法的具体作用。接下来，我们逐个分析。</p>
<h4 id="滚动处理程序handleScroll"><a href="#滚动处理程序handleScroll" class="headerlink" title="滚动处理程序handleScroll"></a>滚动处理程序handleScroll</h4><p>它接受两个变量，第二个是一个布尔值force，表示是否强制触发滚动程序执行。</p>
<p>核心思路是：如果时间间隔100毫秒内，没有发生滚动，且并未强制触发，则do nothing，间隔100毫秒之后再次查询，然后直接return。<br>其中，是否发生滚动由lastScrollY === window.scrollY来判断。<br>在100毫秒之内发生滚动或者强制触发时，需要判断是否滚动已接近页面底部。如果是，则拉取数据，调用fetchContent方法，并调用懒加载方法handleDefer。<br>并且在这个处理程序中，我们计算出来了isVisible区域的上下阈值。我们使用600作为浮动区间，这么做的目的是在一定范围内提前加载图片，节省用户等待时间。当然，如果我们进行抽象时，可以把这个值进行参数化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleScroll</span> (<span class="params">e, force</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果时间间隔内，没有发生滚动，且并未强制触发加载，则do nothing，再次间隔100毫秒之后查询</span></div><div class="line">    <span class="keyword">if</span> (!force &amp;&amp; lastScrollY === <span class="built_in">window</span>.scrollY) &#123;</div><div class="line">        <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 更新文档滚动位置</span></div><div class="line">        lastScrollY = <span class="built_in">window</span>.scrollY;</div><div class="line">    &#125;</div><div class="line">    scrollY = <span class="built_in">window</span>.scrollY;</div><div class="line">    <span class="comment">// 浏览器窗口的视口（viewport）高度赋值</span></div><div class="line">    innerHeight = <span class="built_in">window</span>.innerHeight;</div><div class="line">    <span class="comment">// 计算isVisible上下阈值</span></div><div class="line">    topViewPort = scrollY - <span class="number">1000</span>;</div><div class="line">    bottomViewPort = scrollY + innerHeight + <span class="number">600</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否需要加载</span></div><div class="line">    <span class="comment">// document.body.offsetHeight;返回当前网页高度 </span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY + innerHeight + <span class="number">200</span> &gt; <span class="built_in">document</span>.body.offsetHeight) &#123;</div><div class="line">        fetchContent();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 实现懒加载</span></div><div class="line">    handleDefer();</div><div class="line">    <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="拉取数据"><a href="#拉取数据" class="headerlink" title="拉取数据"></a>拉取数据</h4><p>这里我用到了自己封装的ajax接口方法，它基于zepto的ajax方法，只不过又手动采用了promise包装一层。实现比较简单，当然有兴趣可以找我要一下代码，这里不再详细说了。<br>我们使用前端模版进行HTML渲染，同时调用updateItemCache，将此次数据拉取生成的DOM节点缓存。之后手动触发handleScroll，更新文档滚动位置和懒加载处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchContent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 设置加载状态锁</span></div><div class="line">    <span class="keyword">if</span> (fetching) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        fetching = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    ajax(&#123;</div><div class="line">        <span class="attr">url</span>: (!location.pathname.indexOf(<span class="string">'/m/'</span>) ? <span class="string">'/m'</span> : <span class="string">''</span>)</div><div class="line">            + <span class="string">'/list/asyn?page='</span> + page + (+<span class="keyword">new</span> <span class="built_in">Date</span>),</div><div class="line">        <span class="attr">timeout</span>: <span class="number">300000</span>,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'json'</span></div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (data.errno) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'render'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> dataList = data.data.list;</div><div class="line">        <span class="keyword">var</span> len = dataList.length;</div><div class="line">        <span class="keyword">var</span> ulContainer = <span class="built_in">document</span>.getElementById(<span class="string">'expList'</span>);</div><div class="line">        <span class="keyword">var</span> str = <span class="string">''</span>;</div><div class="line">        <span class="keyword">var</span> frag = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> tpl = __inline(<span class="string">'content.tmpl'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            str = tpl(&#123;<span class="attr">dataList</span>: dataList&#125;);</div><div class="line">        &#125;</div><div class="line">        frag.innerHTML = str;</div><div class="line">        ulContainer.appendChild(frag);</div><div class="line">        <span class="comment">// 更新缓存</span></div><div class="line">        updateItemCache(frag);</div><div class="line">        <span class="comment">// 已经拉去完毕，设置标识为true</span></div><div class="line">        fetching = <span class="literal">false</span>;</div><div class="line">        <span class="comment">// 强制触发</span></div><div class="line">        handleScroll(<span class="literal">null</span>, <span class="literal">true</span>);</div><div class="line">        page++;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'render'</span>);</div><div class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">xhr, type</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Refresh:Ajax Error!'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h4><p>之前参数里提到过，一共有两个用于缓存的对象／数组：</p>
<p>1）slideCache：缓存最近一次加载过的数据生成的DOM内容，缓存方式为数组储存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">slideCache = [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">id</span>: <span class="string">"s-97r45"</span>,</div><div class="line">        <span class="attr">img</span>: img DOM节点,</div><div class="line">        <span class="attr">node</span>: 父容器DOM node,类似&lt;div id=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"slide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</div><div class="line">        <span class="attr">src</span>: 图片资源地址</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">]</div></pre></td></tr></table></figure>
<p>slideCache由updateItemCache函数更新，主要用于懒加载时的赋值src。这样我们做到“只写入DOM”原则，不需要再从DOM读取。</p>
<p>2）slideMap：缓存DOM节点的高度和offsetTop，以DOM节点的id为索引。存储方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">slideMap = &#123;</div><div class="line">    s<span class="number">-97</span>r45: &#123;</div><div class="line">        <span class="attr">node</span>: DOM node,类似&lt;div id=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"slide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</div><div class="line">        <span class="attr">offTop</span>: <span class="number">300</span>,</div><div class="line">        <span class="attr">offsetHeight</span>: <span class="number">90</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>slideMap根据isVisible方法的参数进行更新和读取。使得我们在判断是否isVisible时，大量减少读取DOM的操作。   </p>
<h4 id="懒加载程序"><a href="#懒加载程序" class="headerlink" title="懒加载程序"></a>懒加载程序</h4><p>在上面的滚动处理程序中，我们调用了handleDefer函数。我们看一下这个函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDefer</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 时间记录</span></div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'defer'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 获取dom缓存</span></div><div class="line">    <span class="keyword">var</span> list = slideCache;</div><div class="line">    <span class="comment">// 对于遍历list里的每一项，都使用一个变量，而不是在循环内部声明。节省内存，把性能高效，做到极致。</span></div><div class="line">    <span class="keyword">var</span> thisImg;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</div><div class="line">        thisImg = list[i].img; <span class="comment">// 这里我们都是从内存中读取，而不用读取DOM节点</span></div><div class="line">        <span class="keyword">var</span> deferSrc = list[i].src; <span class="comment">// 这里我们都是从内存中读取，而不用读取DOM节点</span></div><div class="line">        <span class="comment">// 判断元素是否可见</span></div><div class="line">        <span class="keyword">if</span> (isVisible(list[i].id)) &#123;</div><div class="line">            <span class="comment">// 这个函数是图片onload逻辑</span></div><div class="line">            <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> node = thisImg;</div><div class="line">                <span class="keyword">var</span> src = deferSrc;</div><div class="line">                <span class="comment">// 创建一个闭包</span></div><div class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    node.src = src;</div><div class="line">                    node.style.opacity = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">            img.onload = handler();</div><div class="line">            img.src = list[i].src;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'defer'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要思路就是对DOM缓存中的每一项进行循环遍历。在循环中，判断每一项是否已经进入isVisible区域。如果进入isVisible区域，则对当前项进行真实src赋值，并设置opacity为1。</p>
<h4 id="更新拉取数据生成的DOM缓存"><a href="#更新拉取数据生成的DOM缓存" class="headerlink" title="更新拉取数据生成的DOM缓存"></a>更新拉取数据生成的DOM缓存</h4><p>针对每一个slide类，我们缓存对应DOM节、id、子元素img DOM节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateItemCache</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> list = node.querySelectorAll(<span class="string">'.slide'</span>);</div><div class="line">    <span class="keyword">var</span> len = list.length;</div><div class="line">    slideCache = [];</div><div class="line">    <span class="keyword">var</span> obj;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        obj = &#123;</div><div class="line">            <span class="attr">node</span>: list[i],</div><div class="line">            <span class="attr">id</span>: list[i].getAttribute(<span class="string">'id'</span>),</div><div class="line">            <span class="attr">img</span>: list[i].querySelector(<span class="string">'.img'</span>)</div><div class="line">        &#125;</div><div class="line">        obj.src = obj.img.getAttribute(<span class="string">'data-src'</span>);</div><div class="line">        slideCache.push(obj);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="是否在isVisible区域判断"><a href="#是否在isVisible区域判断" class="headerlink" title="是否在isVisible区域判断"></a>是否在isVisible区域判断</h4><p>该函数接受相应DOM id，并进行判断。<br>如果判断条件晦涩难懂的话，你一定要手动画画图理解一下。如果你就是懒得画图，那么也没关系，我帮你画好了，只是丑一些。。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVisible</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> offTop;</div><div class="line">    <span class="keyword">var</span> offsetHeight;</div><div class="line">    <span class="keyword">var</span> data;</div><div class="line">    <span class="keyword">var</span> node;</div><div class="line"></div><div class="line">    <span class="comment">// 判断此元素是否已经懒加载正确渲染，分为在屏幕之上（已经懒加载完毕）和屏幕外，已经添加到dom中，但是还未请求图片（懒加载之前）</span></div><div class="line">    <span class="keyword">if</span> (itemMap[id]) &#123;</div><div class="line">        <span class="comment">// 直接获取offTop，offsetHeight值</span></div><div class="line">        offTop = itemMap[id].offTop;</div><div class="line">        offsetHeight = itemMap[id].offsetHeight;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 设置该节点，并且设置节点属性：node，offTop，offsetHeight</span></div><div class="line">        node = <span class="built_in">document</span>.getElementById(id);</div><div class="line">        <span class="comment">// offsetHeight是自身元素的高度</span></div><div class="line">        offsetHeight = <span class="built_in">parseInt</span>(node.offsetHeight);</div><div class="line">        <span class="comment">// 元素的上外缘距离最近采用定位父元素内壁的距离</span></div><div class="line">        offTop = <span class="built_in">parseInt</span>(node.offsetTop);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (offTop + offsetHeight &gt; topViewPort &amp;&amp; offTop &lt; bottomViewPort) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/bimg/s2.jpg" alt=""></p>
<h3 id="性能收益"><a href="#性能收益" class="headerlink" title="性能收益"></a>性能收益</h3><p>如上代码，我们主要进行了两方面的性能考量：</p>
<p>1）延迟加载时间</p>
<p>2）渲染DOM时间</p>
<p>整体收益如下：</p>
<p>优化前延迟平均值：49.2ms     中间值：43ms；</p>
<p>优化后延迟平均值：17.1ms     中间值：11ms；</p>
<p>优化前渲染平均值：2129.6ms   中间值：2153.5ms；</p>
<p>优化后渲染平均值：120.5ms    中间值：86ms；</p>
<h2 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h2><p>做完这些，其实也远远没有达到所谓的“极致化”性能体验。我们无非就做了各种DOM缓存、映射、懒加载。如果继续分析edge case，我们还能做的更多，比如：DOM回收、墓碑和滚动锚定。这些其实很多都是借鉴客户端开发理念，但是超前的谷歌开发者团队也都有了自己的实现。比如在去年7月份的<br><a href="https://developers.google.com/web/updates/2016/07/infinite-scroller" target="_blank" rel="external">一篇文章：Complexities of an Infinite Scroller</a>就都有所提及。这里从原理（非代码）层面，也给大家做个介绍。</p>
<h3 id="DOM回收"><a href="#DOM回收" class="headerlink" title="DOM回收"></a>DOM回收</h3><p>它的原理是，对于需要产生的大量DOM节点（比如我们下拉加载的信息内容）不是主动用createElement的方式创建，而是回收利用那些已经移出视窗，暂时不会被需要的DOM节点。如图：</p>
<p><img src="/bimg/s3.gif" alt=""></p>
<p>虽然DOM节点本身并非耗能大户，但是也不是一点都不消耗性能，每一个节点都会增加一些额外的内存、布局、样式和绘制。同样需要注意的一点是，在一个较大的DOM中每一次重新布局或重新应用样式（在节点上增加或删除样式所触发的过程）的系统开销都会比较昂贵。所以进行DOM回收意味着我们会保持DOM节点在一个比较低的数量上，进而加快上面提到的这些处理过程。</p>
<p>据我观察，在真正产品线上使用这项技术的还比较少。可能是因为实现复杂度和收益比并不很高。但是，淘宝移动端检索页面实现了类似的思想。如下图，</p>
<p><img src="/bimg/s4.png" alt=""></p>
<p>每加载一次数据，就生成“.page-container  .J-PageContainer_页数”的div，在滚动多屏之后，早已移除视窗的div的子节点进行了remove()，并且为了保证滚动条的正确比例和防止高度塌陷，显示声明了2956px的高度。</p>
<h3 id="墓碑（Tombstones）"><a href="#墓碑（Tombstones）" class="headerlink" title="墓碑（Tombstones）"></a>墓碑（Tombstones）</h3><p>如之前所说，如果网络延迟较大，用户又飞快地滚动，很容易就把我们渲染的DOM节点都甩在千里之外。这样就会出现极差的用户体验。针对这种情况，我们就需要一个墓碑条目占位在对应位置。等到数据取到之后，再代替墓碑。墓碑也可以有一个独立的DOM元素池。并且也可以设计出一些漂亮的过渡。这种技术在国外的一些“引领技术潮流”的网站上，早已经有了应有。比如下图取自Facebook：</p>
<p><img src="/bimg/s5.png" alt=""></p>
<p>我在“简书”APP客户端上，也见过类似的方案。当然，人家是native…</p>
<p><img src="/bimg/s6.jpg" alt=""></p>
<h3 id="滚动锚定"><a href="#滚动锚定" class="headerlink" title="滚动锚定"></a>滚动锚定</h3><p>滚动锚定的触发时机有两个：一个是墓碑被替换时，另一个是窗口大小发生改变时（在设备发生翻转时也会发生）。这两种情况，都需要调整对应的滚动位置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你想提供一个高性能的有良好用户体验的功能时，可能技术上一个简单的问题，就会演变成复杂问题的。这篇文章便是一个例证。<br>随着 “Progressive Web Apps” 逐渐成为移动设备的一等公民（会吗？），高性能的良好体验会变得越来越重要。<br>开发者也必须持续的研究使用一些模式来应对性能约束。这些设计的基础当然都是成熟的技术为根本。</p>
<p>这篇文章参考了Flicker工程师，前YAHOO工程师Stephen Woods的《Building Touch Interfaces with HTML5》一书。以及王芃前辈对于《Complexities of an Infinite Scroller》一文的部分翻译。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://exp-team.github.io/blog/2017/02/25/js/infinite-scroll/" data-id="cizkwsma50000jkfywuovg4qs" class="article-share-link">Share</a>
      
        <!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="blog/2017/02/25/js/infinite-scroll/" data-title="设计高性能无限滚动加载，了解高效页面秘密" data-url="https://exp-team.github.io/blog/2017/02/25/js/infinite-scroll/"></div>
<!-- 多说评论框 end -->

      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2017/03/04/weekly/weekly-10111/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          expfe技术周刊第10111期
        
      </div>
    </a>
  
  
    <a href="/blog/2017/02/24/weekly/weekly-10110/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">expfe技术周刊第10110期</div>
    </a>
  
</nav>

  
</article>

  
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"exp-team"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/weekly/">weekly</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/other/">other</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pac/">pac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/program/">program</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/summary/">summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weekly/">weekly</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/js/" style="font-size: 17.5px;">js</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/pac/" style="font-size: 10px;">pac</a> <a href="/tags/program/" style="font-size: 15px;">program</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/tool/" style="font-size: 12.5px;">tool</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weekly/" style="font-size: 20px;">weekly</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2017/03/09/js/reduce/">面试题目别有洞天 -&gt; 从es6优雅解法，到降级polyfill，再到redux reducer迷之命名</a>
          </li>
        
          <li>
            <a href="/blog/2017/03/06/js/inNetwork/">由浅入深的前端面试题 和矫情的“浪漫主义”诗句</a>
          </li>
        
          <li>
            <a href="/blog/2017/03/04/weekly/weekly-10111/">expfe技术周刊第10111期</a>
          </li>
        
          <li>
            <a href="/blog/2017/02/25/js/infinite-scroll/">设计高性能无限滚动加载，了解高效页面秘密</a>
          </li>
        
          <li>
            <a href="/blog/2017/02/24/weekly/weekly-10110/">expfe技术周刊第10110期</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 exp developer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="https://apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>