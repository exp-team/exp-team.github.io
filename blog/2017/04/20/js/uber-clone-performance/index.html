<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>做出Uber移动网页版还不够 极致性能打造才见真章 | exp team</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="之前分享过两篇关于React技术栈的原创文章：

R">
<meta property="og:type" content="article">
<meta property="og:title" content="做出Uber移动网页版还不够 极致性能打造才见真章">
<meta property="og:url" content="https://exp-team.github.io/blog/2017/04/20/js/uber-clone-performance/index.html">
<meta property="og:site_name" content="exp team">
<meta property="og:description" content="之前分享过两篇关于React技术栈的原创文章：

R">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4363003-59027620881f3e91.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4363003-ea0f448ffd3ae4f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4363003-b7384bf2a9c9bb5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4363003-b4c9aa1eff18344c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4363003-29234133ac7f9edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4363003-1a5ca5dd910efece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4363003-456cb5a07f1acd0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/4363003-8823ee4b69444430.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-04-10T04:57:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="做出Uber移动网页版还不够 极致性能打造才见真章">
<meta name="twitter:description" content="之前分享过两篇关于React技术栈的原创文章：

R">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/4363003-59027620881f3e91.gif?imageMogr2/auto-orient/strip">
  
    <link rel="alternate" href="/atom.xml" title="exp team" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"> -->
  
  <link rel="stylesheet" href="/css/style.css">
  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b549e90ef81d82146548abb71d982d0e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">exp team</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">together, stronger</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/categories/weekly/">前端周刊</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://exp-team.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-js/uber-clone-performance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/04/20/js/uber-clone-performance/" class="article-date">
  <time datetime="2017-04-19T16:00:00.000Z" itemprop="datePublished">2017-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      做出Uber移动网页版还不够 极致性能打造才见真章
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前分享过两篇关于React技术栈的原创文章：</p>
<ul>
<li><a href="http://www.jianshu.com/p/cde3cf7e2760" target="_blank" rel="external">React+Redux打造“NEWS EARLY”单页应用 一个项目理解最前沿技术栈真谛</a></li>
<li><a href="http://www.jianshu.com/p/8e28be0e7ab1" target="_blank" rel="external">一个react+redux工程实例</a>。</li>
</ul>
<p>今天进一步剖析一个实际案例：<strong>Uber APP 移动网页版。</strong></p>
<p>如果你对React技术栈没有多大兴趣，或者不是很了解，也没有关系。因为读下来，你会发现，这篇文章的真谛其实在于<strong>性能优化</strong>上。</p>
<p>本文灵感和主体内容翻译自Narendra N Shetty的<a href="https://hackernoon.com/how-i-built-a-super-fast-uber-clone-for-mobile-web-863680d2100f" target="_blank" rel="external">文章：How I built a super fast Uber clone for mobile web</a>，同时进行了大量扩充以及深挖。</p>
<h2 id="出发点和产品雏形"><a href="#出发点和产品雏形" class="headerlink" title="出发点和产品雏形"></a>出发点和产品雏形</h2><p>很早以来，相信大家都会认同一个观点：<strong>移动端流量超越PC端是不争的事实。</strong>对于前端开发者来说，移动端web的开发同样非常有趣，也充满挑战。</p>
<p>这不，Uber最近发布了最新版本APP，全新样式，体验超棒。于是，笔者决定使用React来从零开始构建一个新的属于自己的Uber。</p>
<p>开发期间，笔者花费了很多时间在基础组件和样式搭建上。这环节中，主要应用了<a href="https://github.com/uber/react-map-gl" target="_blank" rel="external">Uber官方开放的React地图库</a>，并在地图上“目的地”和“起始点”之间采用svg-overlay和html-overlay去绘制路线。</p>
<p>最终的基本交互可以参考下面Gif图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-59027620881f3e91.gif?imageMogr2/auto-orient/strip" alt="uber.gif"></p>
<h2 id="走上优化之路"><a href="#走上优化之路" class="headerlink" title="走上优化之路"></a>走上优化之路</h2><p>现在，我们有基本的产品形态了。目前面临的问题在于提高产品的各方面性能体验。我使用了Chrome Lighthouse去检验产品的性能表现。最终得到的结果为：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-ea0f448ffd3ae4f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果1.png"></p>
<p>wow…<br>第一次绘制时间就已经<strong>接近2秒</strong>，后面的时间惨不忍睹就不要看了吧。<br>想象一下，一个用户拿出手机，企图叫车。主屏时间的绘制就超过了19189.9ms，这是极其不能忍受的。</p>
<p>接下来，什么也不说了，撸起袖子，想办法去优化吧。</p>
<h2 id="优化方法1－代码分离（Code-Splitting）"><a href="#优化方法1－代码分离（Code-Splitting）" class="headerlink" title="优化方法1－代码分离（Code Splitting）"></a>优化方法1－代码分离（Code Splitting）</h2><p>我最开始想到并使用的方法就是：Code Splitting（代码分离），正好我们可以借助webpack来实现这项技术。<br>什么是webpack code splitting呢? 您可以参考<a href="https://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">这里</a>，如果英语阅读吃力，可以参考下面引文：</p>
<blockquote>
<p>code splitting就是指将文件分割为块(chunk)，webpack使我们可以定义一些分割点(split point)，根据这些分割点对文件进行分块，并实现按需加载。</p>
</blockquote>
<p>因为笔者使用了React技术栈，并采用了react-router，所以代码的划分（split）就可以按照路由和加载时机进行。具体操作可以使用react-router的getComponent api来实现：</p>
<pre><code>&lt;Route path=&quot;home&quot; name=&quot;home&quot; getComponent={(nextState, cb) =&gt; {
    require.ensure([], (require) =&gt; {
        cb(null, require(&apos;../components/Home&apos;).default);
    }, &apos;HomeView&apos;);
}}&gt; 
</code></pre><p>只有当对应路由被请求时，相应的组件才会被加载呈现。</p>
<p>同时，笔者使用了webpack的CommonChunkPlugin插件提取第三方代码。这是出于什么考虑呢？</p>
<p>细心的读者可能会发现上面的code splitting也许会存在一个问题：<br><strong>按需（按路由）引入资源后，这些资源可能存在大量重复代码。尤其是我们使用的第三方资源。</strong><br>想明白这个问题，这时候，你应该就会明白CommonChunkPlugin这个插件的意义了。关于这个插件配置方法有多种，这里我们采用了：有选择性的提取（对象方式传参）：</p>
<pre><code>{
    &apos;entry&apos;: {
        &apos;app&apos;: &apos;./src/index.js&apos;,
        &apos;vendor&apos;: [
            &apos;react&apos;,
            &apos;react-redux&apos;,
            &apos;redux&apos;,
            &apos;react-router&apos;,
            &apos;redux-thunk&apos;
        ]
    },
    &apos;output&apos;: {
        &apos;path&apos;: path.resolve(__dirname, &apos;./dist&apos;),
        &apos;publicPath&apos;: &apos;/&apos;,
        &apos;filename&apos;: &apos;static/js/[name].[hash].js&apos;,
        &apos;chunkFilename&apos;: &apos;static/js/[name].[hash].js&apos;
    },
    &apos;plugins&apos;: [
        new webpack.optimize.CommonsChunkPlugin({
            name: [&apos;vendor&apos;], // 公共块的块名称
            minChunks: Infinity, // 最小被引用次数，最小是2。传递Infinity只是创建公共块，但不移动模块。 
            filename: &apos;static/js/[name].[hash].js&apos;, // 公共块的文件名
        }),
    ]
}
</code></pre><p>这样子，我们把公共代码（react、react-redux、redux、react-router、redux-thunk）专门抽取到vendor模块中。</p>
<p>通过上述方法，笔者欣喜地发现：<br>First meaningful paint时间由19189.9ms缩短到4584.3ms：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-b7384bf2a9c9bb5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果2"></p>
<p>这无疑是激动人心的。</p>
<h2 id="优化方法2－Server-side-rendering（服务端直出）"><a href="#优化方法2－Server-side-rendering（服务端直出）" class="headerlink" title="优化方法2－Server side rendering（服务端直出）"></a>优化方法2－Server side rendering（服务端直出）</h2><p>也许你一直在听说过“服务端渲染”或者“服务端直出”这样的名词。但是从未实践过，也从来没有了解过他的意义。好吧，这里我先描述一下，到底什么是服务端直出。</p>
<p>服务端直出，其实简单总结为服务器在接到来自浏览器第一次请求时，便返回一个“初步最终”HTML文档。这个HTML文档已经进行了数据拼接。这样用户能以最快的时间看到首屏的效果，当然这个效果是“阉割版”的，非最终版本。</p>
<p>这种方式主要是针对“前后分离”的传统模式。传统模式中，服务器返回HTML文档，之后浏览器解析文档标签，拉取CSS，之后拉取JS文件。JS文件加载完成之后，执行JS内容，并发送请求获取数据。最终，将数据渲染在页面上。</p>
<p>由此，Server side rendering方式将JS请求数据的过程放在了服务器上，甚至对于数据与HTML结合处理也可以在服务器上做。</p>
<p>这样一来，<strong>主要就是加快了首屏渲染时间。</strong>当然，使用服务端渲染，还能够优化前端渲染难以克服的SEO问题。</p>
<p>理论理解起来很简单，难处就在于服务器端环境的前端脚本如何处理，如何与客户端保持一致。</p>
<p>在这个项目中，我使用了Express作为nodeJS框架，结合react－router完成：</p>
<pre><code>server.use((req, res)=&gt; {
    match({
    &apos;routes&apos;: routes,
    &apos;location&apos;: req.url
    }, (error, redirectLocation, renderProps) =&gt; {
        if (error) {
            res.status(500).send(error.message);
        } 
        else if (redirectLocation) {
            res.redirect(302, redirectLocation.pathname + redirectLocation.search);
        } 
        else if (renderProps) {
            // Create a new Redux store instance
            const store = configureStore();

            // Render the component to a string
            const html = renderToString(&lt;Provider store={store}&gt;&lt;RouterContext {...renderProps} /&gt;&lt;/Provider&gt;);

            const preloadedState = store.getState();

            fs.readFile(&apos;./dist/index.html&apos;, &apos;utf8&apos;, function (err, file) {
                if (err) {
                    return console.log(err);
                }
                let document = file.replace(/&lt;div id=&quot;app&quot;&gt;&lt;\/div&gt;/, `&lt;div id=&quot;app&quot;&gt;${html}&lt;/div&gt;`);
                document = document.replace(/&apos;preloadedState&apos;/, `&apos;${JSON.stringify(preloadedState)}&apos;`);
                res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=31536000&apos;);
                res.setHeader(&quot;Expires&quot;, new Date(Date.now() + 2592000000).toUTCString());
                res.send(document);
            });
        } 
        else {
            res.status(404).send(&apos;Not found&apos;)
        }
    });
});
</code></pre><p>通过上述方法，我们欣喜地发现：<br>First meaningful paint时间已经缩短到921.5ms：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-b4c9aa1eff18344c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果3"></p>
<p>这无疑是令人振奋的。</p>
<h2 id="优化方法3－Compressed-static-assets（压缩静态文件）"><a href="#优化方法3－Compressed-static-assets（压缩静态文件）" class="headerlink" title="优化方法3－Compressed static assets（压缩静态文件）"></a>优化方法3－Compressed static assets（压缩静态文件）</h2><p>压缩文件，当然是一个容易想到而且行之有效的措施。为此，我使用了webpack的CompressionPlugin插件：</p>
<pre><code>{
    &apos;plugins&apos;: [
        new CompressionPlugin({
            test: /\.js$|\.css$|\.html$/
        })
    ]
}
</code></pre><p>同时，使用express-static-gzip来对服务端进行配置：</p>
<pre><code>server.use(&apos;/static&apos;, expressStaticGzip(&apos;./dist/static&apos;, {
    &apos;maxAge&apos;: 31536000,
    setHeaders: function(res, path, stat) {
    res.setHeader(&quot;Expires&quot;, new Date(Date.now() + 2592000000).toUTCString());
        return res;
    }
}));
</code></pre><p>express-static-gzip是一个处于express.static之上的中间件。如果对于指定路径的文件没有找到压缩版本，就使用为压缩版本进行返回。</p>
<p>经过此处理，我们缩短了400ms时间，OK，现在First meaningful paint时间为546.6ms.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-29234133ac7f9edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果4"></p>
<h2 id="优化方法4－Caching（缓存）"><a href="#优化方法4－Caching（缓存）" class="headerlink" title="优化方法4－Caching（缓存）"></a>优化方法4－Caching（缓存）</h2><p>截止到此，我们已经从最初的19189.9ms已经优化到546ms，我们当然继续可以在客户端进行<strong>静态文件缓存</strong>来使得加载时间变得更短。</p>
<p>笔者使用了<a href="https://github.com/GoogleChrome/sw-toolbox" target="_blank" rel="external">sw-toolbox</a>搭配service workers进行。</p>
<blockquote>
<p>sw-toolbox：A collection of service worker tools for offlining runtime requests.<br>Service Worker Toolbox provides some simple helpers for use in creating your own service workers. Specifically, it provides common caching strategies for dynamic content, such as API calls, third-party resources, and large or infrequently used local resources that you don’t want precached.</p>
</blockquote>
<p>简单翻译下：<br>Service Worker实现常见运行时缓存模式，例如动态内容、API调用以及第三方资源，实现方法就像编写README一样简单。</p>
<p>也许到这里你一头雾水，没关系，我们从最初开始，了解一下什么是service worker:</p>
<blockquote>
<p>在2014年，W3C公布了service worker的草案，service worker提供了很多新的能力，使得web app拥有与native app相同的离线体验、消息推送体验。<br>service worker是一段脚本，与web worker一样，也是在后台运行。<br>作为一个独立的线程，运行环境与普通脚本不同，所以不能直接参与web交互行为。native app可以做到离线使用、消息推送、后台自动更新，service worker的出现是正是为了使得web app也可以具有类似的能力。</p>
</blockquote>
<p>而sw-toolbox，顾名思义，就是service worker一个toolbox，具体我们看代码：</p>
<pre><code>toolbox.router.get(&apos;(.*).js&apos;, toolbox.fastest, {
    &apos;origin&apos;:/.herokuapp.com|localhost|maps.googleapis.com/,
    &apos;mode&apos;:&apos;cors&apos;,
    &apos;cache&apos;: {
        &apos;name&apos;: `js-assets-${VERSION}`,
        &apos;maxEntries&apos;: 50,
        &apos;maxAgeSeconds&apos;: 2592e3
    }
});
</code></pre><p>上面代码的意思是，我们对于get类型的请求，当请求内容为js脚本时，应用toolbox.fastest handler处理。<br>toolbox.fastest指示：对于这个请求，我们既从缓存中获取，也同时通过正常的请求network获取。<strong>这两种方式哪个返回快，就应用哪一个。</strong><br>另外，toolbox.router.get的第三个参数表示配置项。</p>
<p>考虑周到的读者可能会想，上面是对于支持Service worker的浏览器，那么对于不支持的浏览器呢？我们干脆设置：</p>
<pre><code>res.setHeader(&quot;Expires&quot;, new Date(Date.now() + 2592000000).toUTCString());
</code></pre><p>通过这样处理，我们来直观感受一下页面加载瀑布流：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-1a5ca5dd910efece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Service worker"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-456cb5a07f1acd0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不使用Service worker"></p>
<h2 id="优化方法5－Preload-and-then-load（预加载／延后加载）"><a href="#优化方法5－Preload-and-then-load（预加载／延后加载）" class="headerlink" title="优化方法5－Preload and then load（预加载／延后加载）"></a>优化方法5－Preload and then load（预加载／延后加载）</h2><p>如果你还没听说过“Preload”，不要紧。我们这就来了解一下：</p>
<blockquote>
<p>Preload作为一个新的web标准，旨在提高性能和为web开发人员提供更细粒度的加载控制。Preload使开发者能够自定义资源的加载逻辑，且无需忍受基于脚本的资源加载器带来的性能损失。</p>
</blockquote>
<p>换成你能听明白的话来说：<br><strong>preload建议允许始终预加载某些资源，浏览器必须请求preload标记的资源。</strong></p>
<p>这样子，究竟有什么意义呢？<br>举个例子：比如一些隐藏在CSS和Javascript中的资源。<br>当浏览器发现自己需要这些资源时已经为时已晚，所以大多数情况，这些资源的加载都会对页面渲染造成延迟。</p>
<p>preload的出现就是为了优化这个过程。<br>对于preload的兼容性，可以参考<a href="http://caniuse.com/#search=preload" target="_blank" rel="external">这里。</a></p>
<p>对于不支持preload的浏览器，笔者使用了prefetch来处理。<br>但于preload不同，prefetch的作用是告诉浏览器加载下一页面可能会用到的资源，注意，是下一页面，而不是当前页面。因此该方法的加载优先级非常低。</p>
<p>这些新标准其实很有意思，里面的内容远不止这些。有兴趣的同学可以自行了解，也欢迎与我讨论。</p>
<p>回到正题，我在head标签中使用：</p>
<pre><code>&lt;link rel=&quot;preload&quot; ... as=&quot;script&quot;&gt;
</code></pre><p>最终优化的结果如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-8823ee4b69444430.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终结果"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，使用React＋Webpack做出一个Uber已经不是重点了。真正激动人心的是整套流程的优化之路。我们使用了大量成熟的、未成熟（新技术），希望对读者有所启发！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://exp-team.github.io/blog/2017/04/20/js/uber-clone-performance/" data-id="cj1bn7dt00010dowh8tfkbn92" class="article-share-link">分享</a>
      
        <!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="blog/2017/04/20/js/uber-clone-performance/" data-title="做出Uber移动网页版还不够 极致性能打造才见真章" data-url="https://exp-team.github.io/blog/2017/04/20/js/uber-clone-performance/"></div>
<!-- 多说评论框 end -->

      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2017/04/20/js/twitter/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          解析Twitter前端架构 学习复杂场景数据设计
        
      </div>
    </a>
  
  
    <a href="/blog/2017/04/20/js/shuffle-array/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">关于数组乱序的深挖——“感觉一直在写毒代码”</div>
    </a>
  
</nav>

  
</article>

  
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"exp-team"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/weekly/">weekly</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/other/">other</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pac/">pac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/program/">program</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/summary/">summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weekly/">weekly</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/js/" style="font-size: 18px;">js</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/pac/" style="font-size: 10px;">pac</a> <a href="/tags/program/" style="font-size: 16px;">program</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/tool/" style="font-size: 14px;">tool</a> <a href="/tags/web/" style="font-size: 12px;">web</a> <a href="/tags/weekly/" style="font-size: 20px;">weekly</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2017/04/20/js/twitter/">解析Twitter前端架构 学习复杂场景数据设计</a>
          </li>
        
          <li>
            <a href="/blog/2017/04/20/js/uber-clone-performance/">做出Uber移动网页版还不够 极致性能打造才见真章</a>
          </li>
        
          <li>
            <a href="/blog/2017/04/20/js/shuffle-array/">关于数组乱序的深挖——“感觉一直在写毒代码”</a>
          </li>
        
          <li>
            <a href="/blog/2017/04/14/js/async/">ES6 Async/Await 完爆Promise的6个原因</a>
          </li>
        
          <li>
            <a href="/blog/2017/04/14/js/react-best-pratice/">通过实例，学习编写React组件的最佳实践</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 exp developer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/weekly/" class="mobile-nav-link">前端周刊</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="https://apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>