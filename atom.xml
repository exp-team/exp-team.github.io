<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>exp team</title>
  <subtitle>together, stronger</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://exp-team.github.io/"/>
  <updated>2017-03-06T11:14:08.000Z</updated>
  <id>https://exp-team.github.io/</id>
  
  <author>
    <name>exp developer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>由浅入深的前端面试题 和矫情的“浪漫主义”诗句</title>
    <link href="https://exp-team.github.io/blog/2017/03/06/js/inNetwork/"/>
    <id>https://exp-team.github.io/blog/2017/03/06/js/inNetwork/</id>
    <published>2017-03-05T16:00:00.000Z</published>
    <updated>2017-03-06T11:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>好吧，我承认太标题党了，这篇文章是通过一道前端面试题引出的纯技术讨论。我先要矫情无比的从中外诗歌说起。</p>
<p>传统的佛学经典里，被世人熟知的有这样一句话：“一花一世界，一叶一菩提，一木一浮生，一草一天堂，一砂一极乐，一方一净土，一笑一尘缘，一念一清静。”。</p>
<p>昔时佛祖拈花，惟迦叶微笑，既而步往极乐。从一朵花中便能悟出整个世界，得升天堂，佛祖就是佛祖，谁人能有这样的境界。</p>
<p>同时，早在18世纪，英国伟大的浪漫主义诗人Black名为《天真的暗示》的诗中，也类似写道：”To see a world in a grain of sand, and a heaven in a wild flower”，一颗沙里一个世界，一朵野花一座天堂。</p>
<p>转念，虽卑为码农，我们写出的代码，却彰显了功力：菜鸟和大神之间的差距，往往工程线上卑微的几行代码，便有天壤之差。</p>
<p>一道系列面试题，在JS知识体系中虽沧海一粟，但考察点充分评判面试者的能力。<br>管中窥豹，期待读者有不同想法与我讨论。</p>
<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>题目是我在《effective javascript》一书中提取的。这一星期陆陆续续面试了不少于10个人，其中不乏工作履历突出的候选者。<br>但是很遗憾没有能完全在较短时间内有较高质量的回答。</p>
<h2 id="题目前身"><a href="#题目前身" class="headerlink" title="题目前身"></a>题目前身</h2><p>这道题可以分为前后两个部分，第一部分很简单，一般有一定JS OOP基础的候选者应该都可以答好：</p>
<p>一个社交网络有一组成员（member），每个成员有一个自己的名字，和存储其朋友信息的列表。请实现这样一个Member构造器。</p>
<p>正确答案不难理解：</p>
<pre><code>function Member (name) {
    this.name = name;
    this.friends = [];
}
</code></pre><p>是不是非常简单。它的典型错误包括但是不限于：</p>
<pre><code>function Member (name) {
    this.name = name;
}
Member.prototype.friends = [];
</code></pre><p>关于方法和属性是应该放在原型上，还是构造函数中，如果您不明白的话，是时候补一补原型原型链的知识了。推荐给大家看一下我的同事颜海镜早在3年前的<a href="http://yanhaijing.com/javascript/2014/05/15/a-code-explain-javascript-oop/" target="_blank" rel="external">一篇文章</a></p>
<p>同样，这道题上我会顺便考察一下面试者对JS中变量的存储方式，包括堆栈存储的不同情况和引用赋值的掌握情况。</p>
<h2 id="题目变身"><a href="#题目变身" class="headerlink" title="题目变身"></a>题目变身</h2><p>以上是对JS基础的考察，但是在这道题目的基础上，我进行了更深一步提问。希望对候选者的临场思维、JS基础甚至一些设计能力，又更进一步认识。</p>
<p>我要实现一个带环社交网络（社交圈）：</p>
<pre><code>var a = new Member(&apos;Alice&apos;);
var b = new Member(&apos;Bob&apos;);
var c = new Member(&apos;Carol&apos;);
var d = new Member(&apos;Dieter&apos;);
var e = new Member(&apos;Eli&apos;);
var f = new Member(&apos;Fatima&apos;);

a.friends.push(b);
b.friends.push(c);
c.friends.push(e);
d.friends.push(b);
e.friends.push(d, f);
</code></pre><p>这种情况下，需要实现一个inNetwork方法，判断某目标成员是否在另一个对象成员的社交圈中。规定：顺着社交链能找到目标成员，就认为在社交圈中。否则，不在其社交圈。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果刚接触到这样的题目，尤其是在面试现场，作为面试者很可能会慌乱一下。这时候，需要做的就是先准确分析题目。<br>根据题目，画出符合上述题目代码的实例化网络：</p>
<p><img src="/bimg/network.png" alt="实例社交圈图示"></p>
<p>接下来思考，搜索意味着需要遍历整个社交网络。我们应该：</p>
<p>1）以单个根节点开始，</p>
<p>2）然后添加发现的节点，</p>
<p>3）移除访问过的节点，防止死环</p>
<p>最终实现：</p>
<pre><code>Member.prototype.inNetwork = function (target) {
    var visited = {};
    var worklist = [this]; // 用于存放社交链上的个体信息，初始时以“自己”作为根节点

    while (worklist.length &gt; 0) {
        // 将worklist里的最后一项成员删除并取出
        var member = worklist.pop();
        // 如果存在环的情况，需要避免重复访问
        if (member.name in visited) {
             continue;
        }
        visited[member.name] = member;
        if (member === target) {
            return true;
        }
        // 将当前成员的朋友列表加入worklist当中，他们都在根节点的社交链上
        member.friends.forEach(function(friend) {
            worklist.push(friend);
        })
    }
    return false;
}
</code></pre><p>我在代码中加上了注释，如果您还不明白也没有关系。建议去跑一下程序，进行debugger和console，尝试去理解。</p>
<p>测试：</p>
<pre><code>a.inNetwork(f) // true
f.inNetwork(a) //false
</code></pre><p>哈哈，果然Alice能通过朋友圈查找到Fatima，而Fatima却不能反向找到Alice!当然，这样我认为是违反人类社会常识的。但是，谁让他是题目呢？</p>
<p>一道简单的题却覆盖了很多知识点，比如：while循环中的流程控制（continue），数组的基本方法（pop,forEach,push），for…in等等。</p>
<p>它的典型错误包括但是不限于：使用对象承载worklist，然后用for…in循环遍历worklist。</p>
<p>这样做的问题在于：for…in循环并没有要求枚举对象的修改与当前循环保持一致。事实上，标准规范规定了：</p>
<p>“如果被枚举对象在枚举期间添加了新的属性，那么枚举期间并不能保证新添加的属性能够访问”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题考察了面试者包括JS OOP在内的多项基础，尤其是后半道考察了候选者的思维能力、反应能力。</p>
<p>扯回原诗句，谈一下感悟，在天体的转动和岁月的轮回中，我们分明的感受到每一个个体所拥有生命周期的单薄无力，在宏大的宇宙观中恐怕渺小不及沧海一粟。诗句的后半句拿出来共勉：“Hold infinity in the palm of your hand, and eternity in an hour 把无限放在你的手上，永恒在一刹那里收藏”。</p>
<p>在前端快速迭代发展的学习中，作为初学者，往往面对浩瀚的知识海洋望洋兴叹，此时基础便是那能够收藏“永恒和无限”的潘多拉魔盒。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好吧，我承认太标题党了，这篇文章是通过一道前端面试题引出的纯技术讨论。我先要矫情无比的从中外诗歌说起。&lt;/p&gt;
&lt;p&gt;传统的佛学经典里，被世人熟知的有这样一句话：“一花一世界，一叶一菩提，一木一浮生，一草一天堂，一砂一极乐，一方一净土，一笑一尘缘，一念一清静。”。&lt;/p&gt;

    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10111期</title>
    <link href="https://exp-team.github.io/blog/2017/03/04/weekly/weekly-10111/"/>
    <id>https://exp-team.github.io/blog/2017/03/04/weekly/weekly-10111/</id>
    <published>2017-03-03T16:00:00.000Z</published>
    <updated>2017-03-06T10:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>2.27-3.3，买了书也不读，还要不要买</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="买了书也不读，还要不要买？"><a href="#买了书也不读，还要不要买？" class="headerlink" title="买了书也不读，还要不要买？"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713060&amp;idx=1&amp;sn=f6cfb8bac38591a6df87b3ebe290166c&amp;chksm=bec065b789b7eca1290b229ad77e1ceca7b3f6de389e8dee5a10ef8b47c2b0a8edf495f9c57a&amp;mpshare=1&amp;scene=1&amp;srcid=0301cCLRYnLwWQBj5dqpl8ej#rd" target="_blank" rel="external">买了书也不读，还要不要买？</a></h3><p>这个问题困扰了我很久，答案是继续买，读书也不要停</p>
<h3 id="30-分钟学会-Flex-布局"><a href="#30-分钟学会-Flex-布局" class="headerlink" title="30 分钟学会 Flex 布局"></a><a href="https://zhuanlan.zhihu.com/p/25303493" target="_blank" rel="external">30 分钟学会 Flex 布局</a></h3><p>温故而知新可以为师矣，10分钟温习一下</p>
<h3 id="有了它，就能轻松管理你的多个-Node-版本"><a href="#有了它，就能轻松管理你的多个-Node-版本" class="headerlink" title="有了它，就能轻松管理你的多个 Node 版本"></a><a href="https://www.h5jun.com/post/manage_node_with_n.html" target="_blank" rel="external">有了它，就能轻松管理你的多个 Node 版本</a></h3><p>爱折腾的小伙伴，试试这个吧，node的版本真是让人头疼</p>
<a id="more"></a>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="小公司的前端应该怎么做？"><a href="#小公司的前端应该怎么做？" class="headerlink" title="小公司的前端应该怎么做？"></a><a href="http://www.cnblogs.com/yexiaochai/p/5311712.html" target="_blank" rel="external">小公司的前端应该怎么做？</a></h3><h3 id="没有循环的JavaScript"><a href="#没有循环的JavaScript" class="headerlink" title="没有循环的JavaScript"></a><a href="https://github.com/Findow-team/Blog/issues/16" target="_blank" rel="external">没有循环的JavaScript</a></h3><h3 id="延迟加载-Lazyload-三种实现方式"><a href="#延迟加载-Lazyload-三种实现方式" class="headerlink" title="延迟加载(Lazyload)三种实现方式"></a><a href="https://zhuanlan.zhihu.com/p/25455672" target="_blank" rel="external">延迟加载(Lazyload)三种实现方式</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2.27-3.3，买了书也不读，还要不要买&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;买了书也不读，还要不要买？&quot;&gt;&lt;a href=&quot;#买了书也不读，还要不要买？&quot; class=&quot;headerlink&quot; title=&quot;买了书也不读，还要不要买？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650713060&amp;amp;idx=1&amp;amp;sn=f6cfb8bac38591a6df87b3ebe290166c&amp;amp;chksm=bec065b789b7eca1290b229ad77e1ceca7b3f6de389e8dee5a10ef8b47c2b0a8edf495f9c57a&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0301cCLRYnLwWQBj5dqpl8ej#rd&quot;&gt;买了书也不读，还要不要买？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;这个问题困扰了我很久，答案是继续买，读书也不要停&lt;/p&gt;
&lt;h3 id=&quot;30-分钟学会-Flex-布局&quot;&gt;&lt;a href=&quot;#30-分钟学会-Flex-布局&quot; class=&quot;headerlink&quot; title=&quot;30 分钟学会 Flex 布局&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25303493&quot;&gt;30 分钟学会 Flex 布局&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;温故而知新可以为师矣，10分钟温习一下&lt;/p&gt;
&lt;h3 id=&quot;有了它，就能轻松管理你的多个-Node-版本&quot;&gt;&lt;a href=&quot;#有了它，就能轻松管理你的多个-Node-版本&quot; class=&quot;headerlink&quot; title=&quot;有了它，就能轻松管理你的多个 Node 版本&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.h5jun.com/post/manage_node_with_n.html&quot;&gt;有了它，就能轻松管理你的多个 Node 版本&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;爱折腾的小伙伴，试试这个吧，node的版本真是让人头疼&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>设计高性能无限滚动加载，了解高效页面秘密</title>
    <link href="https://exp-team.github.io/blog/2017/02/25/js/infinite-scroll/"/>
    <id>https://exp-team.github.io/blog/2017/02/25/js/infinite-scroll/</id>
    <published>2017-02-24T16:00:00.000Z</published>
    <updated>2017-03-06T10:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>UX Planet论坛上有过这么一篇<a href="https://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11" target="_blank" rel="external">热门文章: Infinite Scrolling Best Practices</a>，它从UX角度分析了无限滚动加载的设计实践。</p>
<p>无限滚动加载在互联网上到处都有应用：<br>豆瓣首页是一个，Facebook的Timeline是一个，Tweeter的话题列表也是一个。当你向下滚动，新的内容就神奇的“无中生有”了。这是一个得到广泛赞扬的用户体验。</p>
<p>无限滚动加载背后的技术挑战其实比想象中要多不少。尤其是要考虑页面性能，需要做到极致。<br>本文通过代码实例，来实现一个无限滚动加载效果。更重要的是，在实现过程中，对于页面性能的分析和处理力图做到最大化，希望对读者有所启发，同时也欢迎与我讨论。</p>
<h2 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h2><p>在开启我们的代码之前，有必要先了解一下常用的性能测量手段：</p>
<p>1）使用window.performance </p>
<p>HTML5带来的performance API功能强大。我们可以使用其performance.now()精确计算程序执行时间。performance.now()与Date.now()不同的是，返回了以微秒（百万分之一秒）为单位的时间，更加精准。并且与 Date.now() 会受系统程序执行阻塞的影响不同，performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。<br>同时，也可以使用performance.mark()标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。</p>
<p>2）使用console.time方法与console.timeEnd方法</p>
<p>其中console.time方法用于标记开始时间，console.timeEnd方法用于标记结束时间，并且将结束时间与开始时间之间经过的毫秒数在控制台中输出。</p>
<p>3）使用专业的测量工具／平台：jsPerf</p>
<p>这次实现中，我们使用第二种方法，因为它已经完全可以满足我们的需求，且兼容性更加全面。</p>
<h2 id="整体思路和方案设计"><a href="#整体思路和方案设计" class="headerlink" title="整体思路和方案设计"></a>整体思路和方案设计</h2><p>我们要实现的页面样例如图，</p>
<p><img src="/bimg/s1.png" alt=""></p>
<p>它能够做到无限下拉加载内容。我把红线标出的部分叫做一个block-item，后续也都用这种命名。</p>
<p>1）关于设计方案，肯定第一个最基本、最朴素的思想是下拉到底部之后发送ajax异步请求，成功之后的回调里进行页面拼接。</p>
<p>2）但是观察页面布局，很明显图片较多，每一个block-item区块都有一张配图。当加载后的内容插入到页面中时，浏览器就开始获取图片。这意味着所有的图像同时下载，浏览器中的下载通道将被占满。同时，由于内容优先于用户浏览而加载，所以可能被迫下载底部那些永远也不会被用户浏览到的图像。<br>所以，我们需要设计一个懒加载效果，使得页面速度更快，并且节省用户的流量费用和延长电池寿命。</p>
<p>3）上一条提到的懒加载实现上，为了避免到真正的页面底部时才进行加载和渲染，而造成用户较长时间等待。我们可以设置一个合理阈值，在用户滚动到页面底部之前，先进行提前加载。</p>
<p>4）另外，页面滚动的事件肯定是需要监听的。同时，页面滚动问题也比较棘手，后面将专为滚动进行分析。</p>
<p>5）DOM操作我们知道是及其缓慢而低效的，有兴趣的同学可以研究一下jsPerf上一些经典的benchmark，比如<a href="http://jsperf.com/jquery-cache-vs-dom-querying" target="_blank" rel="external">这篇</a>。关于造成这种缓慢的原因，社区上同样有很多文章有过分析，这里就不再深入。但我想总结并补充的是：DOM操作，光是为了找一个节点，就从本质上比简单的检索内存中的值要慢。一些DOM操作还需要重新计算样式来读取或检索一个值。更突出的问题在于：DOM操作是阻塞的，所以当有一个DOM操作在进行时，其他的什么都不能做，包括用户与页面的交互（除了滚动）。这是一个极度伤害用户体验的事实。</p>
<p>所以，在下面的效果实现中，我采用了大量“不可思议”的DOM缓存，甚至极端的缓存everything。当然，这样做的收益也在最后部分有所展现。</p>
<h3 id="滚动问题"><a href="#滚动问题" class="headerlink" title="滚动问题"></a>滚动问题</h3><p>滚动问题不难想象在于高频率的触发滚动事件处理上。具我亲测，在极端case下，滚动及其卡顿。即使滚动不卡顿，你可以打开Chrome控制台发现，帧速率也非常慢。关于帧速率的问题，我们有著名的16.7毫秒理论。关于这个时间分析，社区上也有不少文章阐述，这里不再展开。</p>
<p>针对于此，有很多读者会立刻想到“截流和防抖动函数”（Throttle和Debounce）。<br>简单总结一下：</p>
<p>1）Throttle允许我们限制激活响应的数量。我们可以限制每秒回调的数量。反过来，也就是说在激活下一个回调之前要等待多少时间;</p>
<p>2）Debounce意味着当事件发生时，我们不会立即激活回调。相反，我们等待一定的时间并检查相同的事件是否再次触发。如果是，我们重置定时器，并再次等待。如果在等待期间没有发生相同的事件，我们就立即激活回调。</p>
<p>具体这里就不代码实现了。原理明白之后，应该不难写出。</p>
<p>但是我这里想从移动端主要浏览器处理滚动的方式入手，来思考这个问题：</p>
<p>1）在Android机器上，用户滚动屏幕时，滚动事件高频率发生——在Galaxy－SIII手机上，大约频率是一秒一百次。这意味着，滚动处理函数也被调用了数百次，而这些又都是成本较大的函数。</p>
<p>2）在Safari浏览器上，我们遇到的问题恰恰是相反的：用户每次滚动屏幕时，滚动事件只在滚动动画停止时才触发。当用户在iPhone上滚动屏幕时，不会运行更新界面的代码（滚动停止时才会运行一次）。</p>
<p>另外，我想也许会有读者想到rAf（requestAnimationFrame），但是据我观察，很多前端其实并不明白requestAnimationFrame技术的原理和解决的问题。只是机械地把动画性能、掉帧问题甩到这么一个名词上。在真实项目中，也没有亲自实现过，更不要说考虑requestAnimationFrame的兼容性情况了。这里场景我并不会使用rAf，因为。setTimeout的定时器值推荐最小使用16.7ms（原因请去社区上找答案，不再细讲），我们这里并不会超过这个限制，并且考虑兼容性。关于这项技术的使用，如果有问题，欢迎留言讨论。</p>
<p>基于以上，我的解决方案是既不同于Throttle，也不同于Debounce，但是和这两个思想，尤其是Throttle又比较类似：把滚动事件替换为一个带有计时器的滚动处理程序，每100毫秒进行简单检查，看这段时间内用户是否滚动过。如果没有，则什么都不做；如果有，就进行处理。</p>
<h3 id="用户体验优化小窍门"><a href="#用户体验优化小窍门" class="headerlink" title="用户体验优化小窍门"></a>用户体验优化小窍门</h3><p>在图像加载完成时，使用淡入（fade in）效果出现。这在实际情况上会稍微慢一下，应该慢一个过渡执行时间。但用户体验上感觉会更快。这是已经被证实且普遍应用的小“trick”。但是据我感觉，它确实有效。我们的代码实现也采用了这个小窍门。不过类似这种“社会心理学”范畴的东西，显然不是本文研究的重点。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>代码上将会采用：超前阈值的懒加载＋DOM Cache和图片Cache＋滚动throttle模拟＋CSS fadeIn动画。<br>具体功能封装上和一些实现层面的东西，请您继续阅读。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h3><p>整体结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"exp-list-box"</span> <span class="attr">id</span>=<span class="string">"expListBox"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"exp-list"</span> <span class="attr">id</span>=<span class="string">"expList"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui-refresh-down"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>主体内容放在id为“expListBox”的container里面，id为“expList”的ul是页面加载内容的容器。<br>因为每次加载并append进入HTML的内容相对较多。我使用了模版来取代传统的字符串拼接。前端模版这次选用了我的同事<a href="https://github.com/yanhaijing/template.js" target="_blank" rel="external">颜海镜大神的开源作品</a>，模版结构为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">#dataList.forEach(function</span> (<span class="attr">v</span>) &#123;#&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="attr">class</span>=<span class="string">"slide"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;#=v.href#&gt;"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"img"</span> <span class="attr">src</span>=<span class="string">"data:image/gif;base64,R0lGODdhAQABAPAAAP%2F%2F%2FwAAACwAAAAAAQABAEACAkQBADs%3D"</span> </span></div><div class="line">                <span class="attr">data-src</span>=<span class="string">"&lt;#=v.src#&gt;"</span>&gt;</div><div class="line">                <span class="tag">&lt;/<span class="name">img</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.title#</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"writer"</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.writer#</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"good-num"</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.succNum#</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">#&#125;)#</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上模版内容由每次ajax请求到的数据填充，并添加进入页面，构成每个block-item。<br>这里需要注意观察，有助于对后面逻辑的理解。页面中一个block-item下div属性存有该block-item的eid值，对应class叫做”slide”，子孙节点包含有一个image标签，src初始赋值为1px的空白图进行占位。真实图片资源位置存储在”data-src”中。<br>另外，请求返回的数据dataList可以理解为由9个对象构成的数组，也就是说，每次请求加载9个block-item。</p>
<h3 id="样式亮点"><a href="#样式亮点" class="headerlink" title="样式亮点"></a>样式亮点</h3><p>样式方面不是这篇文章的重点，挑选最核心的一行来说明一下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.slide</span> <span class="selector-class">.img</span>&#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">90px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">-webkit-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">-moz-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">-o-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唯一需要注意的是image的opacity设置为0，图片将会在成功请求并渲染后调整为1，辅助transition属性实现一个fade in效果。<br>对应我们上面所提到的那个“trick”</p>
<h3 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h3><p>我是完全按照业务需求来设计，并没有做抽象。其实这样的一个下拉加载功能完全可以抽象出来。有兴趣的读者可以下去自己进行封装和抽象。<br>我们先把精力集中在逻辑处理上。<br>下面进入我们最核心的逻辑部分，为了防止全局污染，我把它放入了一个立即执行函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fetching = <span class="literal">false</span>; </div><div class="line">    <span class="keyword">var</span> page = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> slideCache = [];</div><div class="line">    <span class="keyword">var</span> itemMap = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> lastScrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line">    <span class="keyword">var</span> scrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line">    <span class="keyword">var</span> innerHeight;</div><div class="line">    <span class="keyword">var</span> topViewPort;</div><div class="line">    <span class="keyword">var</span> bottomViewPort;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isVisible</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...判断元素是否在可见区域</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateItemCache</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="comment">// ....更新DOM缓存</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fetchContent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...ajax请求数据</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleDefer</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...懒加载实现</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleScroll</span> (<span class="params">e, force</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...滚动处理程序</span></div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">    fetchContent();</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>我认为好的编程习惯是在程序开头部分便声明所有的变量，防止“变量提升”带来的潜在困扰，并且也有利于程序的整体把控。<br>我们来看一下变量设置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加载中状态锁</span></div><div class="line"><span class="number">1</span>）<span class="keyword">var</span> fetching = <span class="literal">false</span>;</div><div class="line"><span class="comment">// 用于加载时发送请求参数，表示第几屏内容，初始为1，以后每请求一次，递增1</span></div><div class="line"><span class="number">2</span>）<span class="keyword">var</span> page = <span class="number">1</span>; </div><div class="line"><span class="comment">// 只缓存最新一次下拉数据生成的DOM节点，即需要插入的dom缓存数组</span></div><div class="line"><span class="number">3</span>）<span class="keyword">var</span> slideCache = []; </div><div class="line"><span class="comment">// 用于已经生成的DOM节点储存，存有item的offsetTop，offsetHeight</span></div><div class="line"><span class="number">4</span>) <span class="keyword">var</span> slideMap = &#123;&#125;; </div><div class="line"><span class="comment">// pageYOffset设置或返回当前页面相对于窗口显示区左上角的Y位置。</span></div><div class="line"><span class="number">5</span>）<span class="keyword">var</span> lastScrollY = <span class="built_in">window</span>.pageYOffset; <span class="keyword">var</span> scrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line"><span class="comment">// 浏览器窗口的视口（viewport）高度</span></div><div class="line"><span class="number">6</span>）<span class="keyword">var</span> innerHeight;</div><div class="line"><span class="comment">// isVisible的上下阈值边界</span></div><div class="line"><span class="number">7</span>) <span class="keyword">var</span> topViewPort; </div><div class="line"><span class="number">8</span>) <span class="keyword">var</span> bottomViewPort;</div></pre></td></tr></table></figure>
<p>关于DOM cache的变量详细说明，在后文有提供。</p>
<p>同样，我们有5个函数。在上面的代码中，注释已经写明白了每个方法的具体作用。接下来，我们逐个分析。</p>
<h4 id="滚动处理程序handleScroll"><a href="#滚动处理程序handleScroll" class="headerlink" title="滚动处理程序handleScroll"></a>滚动处理程序handleScroll</h4><p>它接受两个变量，第二个是一个布尔值force，表示是否强制触发滚动程序执行。</p>
<p>核心思路是：如果时间间隔100毫秒内，没有发生滚动，且并未强制触发，则do nothing，间隔100毫秒之后再次查询，然后直接return。<br>其中，是否发生滚动由lastScrollY === window.scrollY来判断。<br>在100毫秒之内发生滚动或者强制触发时，需要判断是否滚动已接近页面底部。如果是，则拉取数据，调用fetchContent方法，并调用懒加载方法handleDefer。<br>并且在这个处理程序中，我们计算出来了isVisible区域的上下阈值。我们使用600作为浮动区间，这么做的目的是在一定范围内提前加载图片，节省用户等待时间。当然，如果我们进行抽象时，可以把这个值进行参数化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleScroll</span> (<span class="params">e, force</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果时间间隔内，没有发生滚动，且并未强制触发加载，则do nothing，再次间隔100毫秒之后查询</span></div><div class="line">    <span class="keyword">if</span> (!force &amp;&amp; lastScrollY === <span class="built_in">window</span>.scrollY) &#123;</div><div class="line">        <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 更新文档滚动位置</span></div><div class="line">        lastScrollY = <span class="built_in">window</span>.scrollY;</div><div class="line">    &#125;</div><div class="line">    scrollY = <span class="built_in">window</span>.scrollY;</div><div class="line">    <span class="comment">// 浏览器窗口的视口（viewport）高度赋值</span></div><div class="line">    innerHeight = <span class="built_in">window</span>.innerHeight;</div><div class="line">    <span class="comment">// 计算isVisible上下阈值</span></div><div class="line">    topViewPort = scrollY - <span class="number">1000</span>;</div><div class="line">    bottomViewPort = scrollY + innerHeight + <span class="number">600</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否需要加载</span></div><div class="line">    <span class="comment">// document.body.offsetHeight;返回当前网页高度 </span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY + innerHeight + <span class="number">200</span> &gt; <span class="built_in">document</span>.body.offsetHeight) &#123;</div><div class="line">        fetchContent();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 实现懒加载</span></div><div class="line">    handleDefer();</div><div class="line">    <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="拉取数据"><a href="#拉取数据" class="headerlink" title="拉取数据"></a>拉取数据</h4><p>这里我用到了自己封装的ajax接口方法，它基于zepto的ajax方法，只不过又手动采用了promise包装一层。实现比较简单，当然有兴趣可以找我要一下代码，这里不再详细说了。<br>我们使用前端模版进行HTML渲染，同时调用updateItemCache，将此次数据拉取生成的DOM节点缓存。之后手动触发handleScroll，更新文档滚动位置和懒加载处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchContent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 设置加载状态锁</span></div><div class="line">    <span class="keyword">if</span> (fetching) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        fetching = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    ajax(&#123;</div><div class="line">        <span class="attr">url</span>: (!location.pathname.indexOf(<span class="string">'/m/'</span>) ? <span class="string">'/m'</span> : <span class="string">''</span>)</div><div class="line">            + <span class="string">'/list/asyn?page='</span> + page + (+<span class="keyword">new</span> <span class="built_in">Date</span>),</div><div class="line">        <span class="attr">timeout</span>: <span class="number">300000</span>,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'json'</span></div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (data.errno) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'render'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> dataList = data.data.list;</div><div class="line">        <span class="keyword">var</span> len = dataList.length;</div><div class="line">        <span class="keyword">var</span> ulContainer = <span class="built_in">document</span>.getElementById(<span class="string">'expList'</span>);</div><div class="line">        <span class="keyword">var</span> str = <span class="string">''</span>;</div><div class="line">        <span class="keyword">var</span> frag = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> tpl = __inline(<span class="string">'content.tmpl'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            str = tpl(&#123;<span class="attr">dataList</span>: dataList&#125;);</div><div class="line">        &#125;</div><div class="line">        frag.innerHTML = str;</div><div class="line">        ulContainer.appendChild(frag);</div><div class="line">        <span class="comment">// 更新缓存</span></div><div class="line">        updateItemCache(frag);</div><div class="line">        <span class="comment">// 已经拉去完毕，设置标识为true</span></div><div class="line">        fetching = <span class="literal">false</span>;</div><div class="line">        <span class="comment">// 强制触发</span></div><div class="line">        handleScroll(<span class="literal">null</span>, <span class="literal">true</span>);</div><div class="line">        page++;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'render'</span>);</div><div class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">xhr, type</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Refresh:Ajax Error!'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h4><p>之前参数里提到过，一共有两个用于缓存的对象／数组：</p>
<p>1）slideCache：缓存最近一次加载过的数据生成的DOM内容，缓存方式为数组储存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">slideCache = [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">id</span>: <span class="string">"s-97r45"</span>,</div><div class="line">        <span class="attr">img</span>: img DOM节点,</div><div class="line">        <span class="attr">node</span>: 父容器DOM node,类似&lt;div id=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"slide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</div><div class="line">        <span class="attr">src</span>: 图片资源地址</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">]</div></pre></td></tr></table></figure>
<p>slideCache由updateItemCache函数更新，主要用于懒加载时的赋值src。这样我们做到“只写入DOM”原则，不需要再从DOM读取。</p>
<p>2）slideMap：缓存DOM节点的高度和offsetTop，以DOM节点的id为索引。存储方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">slideMap = &#123;</div><div class="line">    s<span class="number">-97</span>r45: &#123;</div><div class="line">        <span class="attr">node</span>: DOM node,类似&lt;div id=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"slide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</div><div class="line">        <span class="attr">offTop</span>: <span class="number">300</span>,</div><div class="line">        <span class="attr">offsetHeight</span>: <span class="number">90</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>slideMap根据isVisible方法的参数进行更新和读取。使得我们在判断是否isVisible时，大量减少读取DOM的操作。   </p>
<h4 id="懒加载程序"><a href="#懒加载程序" class="headerlink" title="懒加载程序"></a>懒加载程序</h4><p>在上面的滚动处理程序中，我们调用了handleDefer函数。我们看一下这个函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDefer</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 时间记录</span></div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'defer'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 获取dom缓存</span></div><div class="line">    <span class="keyword">var</span> list = slideCache;</div><div class="line">    <span class="comment">// 对于遍历list里的每一项，都使用一个变量，而不是在循环内部声明。节省内存，把性能高效，做到极致。</span></div><div class="line">    <span class="keyword">var</span> thisImg;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</div><div class="line">        thisImg = list[i].img; <span class="comment">// 这里我们都是从内存中读取，而不用读取DOM节点</span></div><div class="line">        <span class="keyword">var</span> deferSrc = list[i].src; <span class="comment">// 这里我们都是从内存中读取，而不用读取DOM节点</span></div><div class="line">        <span class="comment">// 判断元素是否可见</span></div><div class="line">        <span class="keyword">if</span> (isVisible(list[i].id)) &#123;</div><div class="line">            <span class="comment">// 这个函数是图片onload逻辑</span></div><div class="line">            <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> node = thisImg;</div><div class="line">                <span class="keyword">var</span> src = deferSrc;</div><div class="line">                <span class="comment">// 创建一个闭包</span></div><div class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    node.src = src;</div><div class="line">                    node.style.opacity = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">            img.onload = handler();</div><div class="line">            img.src = list[i].src;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'defer'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要思路就是对DOM缓存中的每一项进行循环遍历。在循环中，判断每一项是否已经进入isVisible区域。如果进入isVisible区域，则对当前项进行真实src赋值，并设置opacity为1。</p>
<h4 id="更新拉取数据生成的DOM缓存"><a href="#更新拉取数据生成的DOM缓存" class="headerlink" title="更新拉取数据生成的DOM缓存"></a>更新拉取数据生成的DOM缓存</h4><p>针对每一个slide类，我们缓存对应DOM节、id、子元素img DOM节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateItemCache</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> list = node.querySelectorAll(<span class="string">'.slide'</span>);</div><div class="line">    <span class="keyword">var</span> len = list.length;</div><div class="line">    slideCache = [];</div><div class="line">    <span class="keyword">var</span> obj;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        obj = &#123;</div><div class="line">            <span class="attr">node</span>: list[i],</div><div class="line">            <span class="attr">id</span>: list[i].getAttribute(<span class="string">'id'</span>),</div><div class="line">            <span class="attr">img</span>: list[i].querySelector(<span class="string">'.img'</span>)</div><div class="line">        &#125;</div><div class="line">        obj.src = obj.img.getAttribute(<span class="string">'data-src'</span>);</div><div class="line">        slideCache.push(obj);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="是否在isVisible区域判断"><a href="#是否在isVisible区域判断" class="headerlink" title="是否在isVisible区域判断"></a>是否在isVisible区域判断</h4><p>该函数接受相应DOM id，并进行判断。<br>如果判断条件晦涩难懂的话，你一定要手动画画图理解一下。如果你就是懒得画图，那么也没关系，我帮你画好了，只是丑一些。。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVisible</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> offTop;</div><div class="line">    <span class="keyword">var</span> offsetHeight;</div><div class="line">    <span class="keyword">var</span> data;</div><div class="line">    <span class="keyword">var</span> node;</div><div class="line"></div><div class="line">    <span class="comment">// 判断此元素是否已经懒加载正确渲染，分为在屏幕之上（已经懒加载完毕）和屏幕外，已经添加到dom中，但是还未请求图片（懒加载之前）</span></div><div class="line">    <span class="keyword">if</span> (itemMap[id]) &#123;</div><div class="line">        <span class="comment">// 直接获取offTop，offsetHeight值</span></div><div class="line">        offTop = itemMap[id].offTop;</div><div class="line">        offsetHeight = itemMap[id].offsetHeight;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 设置该节点，并且设置节点属性：node，offTop，offsetHeight</span></div><div class="line">        node = <span class="built_in">document</span>.getElementById(id);</div><div class="line">        <span class="comment">// offsetHeight是自身元素的高度</span></div><div class="line">        offsetHeight = <span class="built_in">parseInt</span>(node.offsetHeight);</div><div class="line">        <span class="comment">// 元素的上外缘距离最近采用定位父元素内壁的距离</span></div><div class="line">        offTop = <span class="built_in">parseInt</span>(node.offsetTop);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (offTop + offsetHeight &gt; topViewPort &amp;&amp; offTop &lt; bottomViewPort) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/bimg/s2.jpg" alt=""></p>
<h3 id="性能收益"><a href="#性能收益" class="headerlink" title="性能收益"></a>性能收益</h3><p>如上代码，我们主要进行了两方面的性能考量：</p>
<p>1）延迟加载时间</p>
<p>2）渲染DOM时间</p>
<p>整体收益如下：</p>
<p>优化前延迟平均值：49.2ms     中间值：43ms；</p>
<p>优化后延迟平均值：17.1ms     中间值：11ms；</p>
<p>优化前渲染平均值：2129.6ms   中间值：2153.5ms；</p>
<p>优化后渲染平均值：120.5ms    中间值：86ms；</p>
<h2 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h2><p>做完这些，其实也远远没有达到所谓的“极致化”性能体验。我们无非就做了各种DOM缓存、映射、懒加载。如果继续分析edge case，我们还能做的更多，比如：DOM回收、墓碑和滚动锚定。这些其实很多都是借鉴客户端开发理念，但是超前的谷歌开发者团队也都有了自己的实现。比如在去年7月份的<br><a href="https://developers.google.com/web/updates/2016/07/infinite-scroller" target="_blank" rel="external">一篇文章：Complexities of an Infinite Scroller</a>就都有所提及。这里从原理（非代码）层面，也给大家做个介绍。</p>
<h3 id="DOM回收"><a href="#DOM回收" class="headerlink" title="DOM回收"></a>DOM回收</h3><p>它的原理是，对于需要产生的大量DOM节点（比如我们下拉加载的信息内容）不是主动用createElement的方式创建，而是回收利用那些已经移出视窗，暂时不会被需要的DOM节点。如图：</p>
<p><img src="/bimg/s3.gif" alt=""></p>
<p>虽然DOM节点本身并非耗能大户，但是也不是一点都不消耗性能，每一个节点都会增加一些额外的内存、布局、样式和绘制。同样需要注意的一点是，在一个较大的DOM中每一次重新布局或重新应用样式（在节点上增加或删除样式所触发的过程）的系统开销都会比较昂贵。所以进行DOM回收意味着我们会保持DOM节点在一个比较低的数量上，进而加快上面提到的这些处理过程。</p>
<p>据我观察，在真正产品线上使用这项技术的还比较少。可能是因为实现复杂度和收益比并不很高。但是，淘宝移动端检索页面实现了类似的思想。如下图，</p>
<p><img src="/bimg/s4.png" alt=""></p>
<p>每加载一次数据，就生成“.page-container  .J-PageContainer_页数”的div，在滚动多屏之后，早已移除视窗的div的子节点进行了remove()，并且为了保证滚动条的正确比例和防止高度塌陷，显示声明了2956px的高度。</p>
<h3 id="墓碑（Tombstones）"><a href="#墓碑（Tombstones）" class="headerlink" title="墓碑（Tombstones）"></a>墓碑（Tombstones）</h3><p>如之前所说，如果网络延迟较大，用户又飞快地滚动，很容易就把我们渲染的DOM节点都甩在千里之外。这样就会出现极差的用户体验。针对这种情况，我们就需要一个墓碑条目占位在对应位置。等到数据取到之后，再代替墓碑。墓碑也可以有一个独立的DOM元素池。并且也可以设计出一些漂亮的过渡。这种技术在国外的一些“引领技术潮流”的网站上，早已经有了应有。比如下图取自Facebook：</p>
<p><img src="/bimg/s5.png" alt=""></p>
<p>我在“简书”APP客户端上，也见过类似的方案。当然，人家是native…</p>
<p><img src="/bimg/s6.jpg" alt=""></p>
<h3 id="滚动锚定"><a href="#滚动锚定" class="headerlink" title="滚动锚定"></a>滚动锚定</h3><p>滚动锚定的触发时机有两个：一个是墓碑被替换时，另一个是窗口大小发生改变时（在设备发生翻转时也会发生）。这两种情况，都需要调整对应的滚动位置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你想提供一个高性能的有良好用户体验的功能时，可能技术上一个简单的问题，就会演变成复杂问题的。这篇文章便是一个例证。<br>随着 “Progressive Web Apps” 逐渐成为移动设备的一等公民（会吗？），高性能的良好体验会变得越来越重要。<br>开发者也必须持续的研究使用一些模式来应对性能约束。这些设计的基础当然都是成熟的技术为根本。</p>
<p>这篇文章参考了Flicker工程师，前YAHOO工程师Stephen Woods的《Building Touch Interfaces with HTML5》一书。以及王芃前辈对于《Complexities of an Infinite Scroller》一文的部分翻译。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UX Planet论坛上有过这么一篇&lt;a href=&quot;https://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10110期</title>
    <link href="https://exp-team.github.io/blog/2017/02/24/weekly/weekly-10110/"/>
    <id>https://exp-team.github.io/blog/2017/02/24/weekly/weekly-10110/</id>
    <published>2017-02-23T16:00:00.000Z</published>
    <updated>2017-03-06T10:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>2.20-2.24，我预见了所有悲伤，但依然愿意前往</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="假如未来已经设定"><a href="#假如未来已经设定" class="headerlink" title="假如未来已经设定"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713029&amp;idx=1&amp;sn=2a8fa3a0f0980e08f85884ddf4c69cb8&amp;chksm=bec0659689b7ec805b636d54cbb0d041283c004941a025bb69ed6d56606af734124da58e67ae&amp;mpshare=1&amp;scene=1&amp;srcid=0214ZjRyXl5OqRZgInG4xTkI#rd" target="_blank" rel="external">假如未来已经设定</a></h3><p>我预见了所有悲伤，但依然愿意前往，脑洞很大的文章，你有没有想过如果未来是已经确定，就像手心的纹路确定了我们的命运一样</p>
<h3 id="JavaScript-简史：JavaScript-的过去、现在和未来"><a href="#JavaScript-简史：JavaScript-的过去、现在和未来" class="headerlink" title="JavaScript 简史：JavaScript 的过去、现在和未来"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964302&amp;idx=1&amp;sn=58cedeefd6390b642cb9b3d36645bc43&amp;chksm=843aed28b34d643eacb32c9005a1bcf816b0b11e965df5408045efa677b7fe9c04c00d8d7f70&amp;mpshare=1&amp;scene=1&amp;srcid=0218Ka8Y2Dt48RKcIueksYsr#rd" target="_blank" rel="external">JavaScript 简史：JavaScript 的过去、现在和未来</a></h3><p>我看到最全的js历史，从诞生到现在，每一次成长在这里都有记录，js发展到今天历史上有一些关键点和关键的人和公司</p>
<h3 id="职场中脱颖而出的成长秘诀"><a href="#职场中脱颖而出的成长秘诀" class="headerlink" title="职场中脱颖而出的成长秘诀"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651225540&amp;idx=1&amp;sn=0e18e698880f426ddca78bf7fa3640ee&amp;chksm=bd49a4408a3e2d56c4797aa49d7f3f0380ab58ad06b2d92a7d9df86b32eee82f6decd5ab660f&amp;mpshare=1&amp;scene=1&amp;srcid=0208fCIyROm3JSq69KeCtWdL#rd" target="_blank" rel="external">职场中脱颖而出的成长秘诀</a></h3><p>跳槽季了，结尾推荐了一些跳槽的指导文章，但我认为更重要的是如何让自己脱颖而出</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="2016－JavaScript之星"><a href="#2016－JavaScript之星" class="headerlink" title="2016－JavaScript之星"></a><a href="https://github.com/fezaoduke/TranslationInstitute/blob/master/JavaScript%E4%B9%8B%E6%98%9F-2016.md" target="_blank" rel="external">2016－JavaScript之星</a></h3><h3 id="JavaScript-启动性能瓶颈分析与解决方案"><a href="#JavaScript-启动性能瓶颈分析与解决方案" class="headerlink" title="JavaScript 启动性能瓶颈分析与解决方案"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247484987&amp;idx=1&amp;sn=7f20da20bc6baed62ca8ff115209942b&amp;chksm=972364f9a054edefccebc89bb4b39150328f84fc6a3da53dafa9563df7375fef00b3a1a4c483&amp;mpshare=1&amp;scene=1&amp;srcid=0213dAmdg84IPINoZZxbZPTH#rd" target="_blank" rel="external">JavaScript 启动性能瓶颈分析与解决方案</a></h3><h3 id="JavaScript-数组方法对比"><a href="#JavaScript-数组方法对比" class="headerlink" title="JavaScript 数组方法对比"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651225575&amp;idx=1&amp;sn=b25f4e9aaf7ba48f97f7ee0e266edd39&amp;chksm=bd49a4638a3e2d75e9df776fc6a2fc7cfc7c182867f92771367935e2cafce7cc18a078eb0f3c&amp;mpshare=1&amp;scene=1&amp;srcid=0209qfeI7mg9ILGs7hpiJhZ7#rd" target="_blank" rel="external">JavaScript 数组方法对比</a></h3><h3 id="javascript实现排序算法"><a href="#javascript实现排序算法" class="headerlink" title="javascript实现排序算法"></a><a href="https://segmentfault.com/a/1190000006899632" target="_blank" rel="external">javascript实现排序算法</a></h3><h3 id="扩展运算符的6个重要用途"><a href="#扩展运算符的6个重要用途" class="headerlink" title="扩展运算符的6个重要用途"></a><a href="https://rockjins.js.org/2017/02/09/spread-operator/" target="_blank" rel="external">扩展运算符的6个重要用途</a></h3><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="为什么学前端"><a href="#为什么学前端" class="headerlink" title="为什么学前端"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjAzMDA1MQ==&amp;mid=2648945771&amp;idx=1&amp;sn=846eccef058fa7789cfd831f5740f631&amp;scene=0#wechat_redirect" target="_blank" rel="external">为什么学前端</a></h3><h3 id="你真的了解setTimeout和setInterval吗？"><a href="#你真的了解setTimeout和setInterval吗？" class="headerlink" title="你真的了解setTimeout和setInterval吗？"></a><a href="http://qingbob.com/difference-between-settimeout-setinterval/" target="_blank" rel="external">你真的了解setTimeout和setInterval吗？</a></h3><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a><a href="http://mp.weixin.qq.com/s/Hcp60sfDOyXcP9TM0CX2Bw" target="_blank" rel="external">前端性能优化</a></h3><h3 id="界面组件化设计"><a href="#界面组件化设计" class="headerlink" title="界面组件化设计"></a><a href="https://github.com/fezaoduke/TranslationInstitute/blob/master/%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6%E5%8C%96%E8%AE%BE%E8%AE%A1.md" target="_blank" rel="external">界面组件化设计</a></h3><h3 id="CSS4-Selectors"><a href="#CSS4-Selectors" class="headerlink" title="CSS4 Selectors"></a><a href="https://gokulkrishh.github.io/css/2017/02/16/CSS4-selectors.html" target="_blank" rel="external">CSS4 Selectors</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="你是不是该跳槽了？"><a href="#你是不是该跳槽了？" class="headerlink" title="你是不是该跳槽了？"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713033&amp;idx=1&amp;sn=3b4add19dda1ae277868528edabc31b4&amp;chksm=bec0659a89b7ec8cc0213bf055c5b727b2660b7c33f358810c292520539baec8dc0943e6cae3&amp;mpshare=1&amp;scene=1&amp;srcid=0217aS0DFFlvnQJp0WZyfAH9#rd" target="_blank" rel="external">你是不是该跳槽了？</a></h3><p>公司是不是在成长？你自己是不是在成长？公司的成长和自己有没有关系？干的开不开心？如果这几个问题都是肯定的回答，那么就该留下共同成长。反之就该毫不犹豫的离开</p>
<h3 id="不学会这个，跳槽，永远解决不了问题！！！"><a href="#不学会这个，跳槽，永远解决不了问题！！！" class="headerlink" title="不学会这个，跳槽，永远解决不了问题！！！"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTQ4MjUxOQ==&amp;mid=2455353498&amp;idx=1&amp;sn=b7378bb0b6fe838be758b11da1bc46f7&amp;chksm=8d7412e2ba039bf43dc230abf4c0ca6dd00fd5056df69fc91ebbb751e6ee50778ec854dcc08d&amp;mpshare=1&amp;scene=1&amp;srcid=02099iM3bNl94v33mVPMZNWp#rd" target="_blank" rel="external">不学会这个，跳槽，永远解决不了问题！！！</a></h3><p>跳槽是规划未来，而不是逃避现在；自己内在的问题，跳槽解决不了的；跳槽，是为了更好的外部环境</p>
<h3 id="程序员职业生涯巡礼"><a href="#程序员职业生涯巡礼" class="headerlink" title="程序员职业生涯巡礼"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713017&amp;idx=1&amp;sn=e85b005041cd76e4ae5bbbc1623095c4&amp;chksm=bec065ea89b7ecfcde5771d6f4032a6eb962052a6daa6db30630747a0e1633fee067ed8202e0&amp;mpshare=1&amp;scene=1&amp;srcid=0206Ja6WbmRXBs8yb0GVAgEj#rd" target="_blank" rel="external">程序员职业生涯巡礼</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2.20-2.24，我预见了所有悲伤，但依然愿意前往&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;假如未来已经设定&quot;&gt;&lt;a href=&quot;#假如未来已经设定&quot; class=&quot;headerlink&quot; title=&quot;假如未来已经设定&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650713029&amp;amp;idx=1&amp;amp;sn=2a8fa3a0f0980e08f85884ddf4c69cb8&amp;amp;chksm=bec0659689b7ec805b636d54cbb0d041283c004941a025bb69ed6d56606af734124da58e67ae&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0214ZjRyXl5OqRZgInG4xTkI#rd&quot;&gt;假如未来已经设定&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我预见了所有悲伤，但依然愿意前往，脑洞很大的文章，你有没有想过如果未来是已经确定，就像手心的纹路确定了我们的命运一样&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-简史：JavaScript-的过去、现在和未来&quot;&gt;&lt;a href=&quot;#JavaScript-简史：JavaScript-的过去、现在和未来&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 简史：JavaScript 的过去、现在和未来&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;amp;mid=2650964302&amp;amp;idx=1&amp;amp;sn=58cedeefd6390b642cb9b3d36645bc43&amp;amp;chksm=843aed28b34d643eacb32c9005a1bcf816b0b11e965df5408045efa677b7fe9c04c00d8d7f70&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0218Ka8Y2Dt48RKcIueksYsr#rd&quot;&gt;JavaScript 简史：JavaScript 的过去、现在和未来&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我看到最全的js历史，从诞生到现在，每一次成长在这里都有记录，js发展到今天历史上有一些关键点和关键的人和公司&lt;/p&gt;
&lt;h3 id=&quot;职场中脱颖而出的成长秘诀&quot;&gt;&lt;a href=&quot;#职场中脱颖而出的成长秘诀&quot; class=&quot;headerlink&quot; title=&quot;职场中脱颖而出的成长秘诀&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651225540&amp;amp;idx=1&amp;amp;sn=0e18e698880f426ddca78bf7fa3640ee&amp;amp;chksm=bd49a4408a3e2d56c4797aa49d7f3f0380ab58ad06b2d92a7d9df86b32eee82f6decd5ab660f&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0208fCIyROm3JSq69KeCtWdL#rd&quot;&gt;职场中脱颖而出的成长秘诀&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;跳槽季了，结尾推荐了一些跳槽的指导文章，但我认为更重要的是如何让自己脱颖而出&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>从一道面试题的进阶，到“我可能看了假源码”（2）</title>
    <link href="https://exp-team.github.io/blog/2017/02/20/js/es5-shim-bind/"/>
    <id>https://exp-team.github.io/blog/2017/02/20/js/es5-shim-bind/</id>
    <published>2017-02-19T16:00:00.000Z</published>
    <updated>2017-02-20T00:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://exp-team.github.io/blog/2017/01/20/js/bind/">从一道面试题的进阶，到“我可能看了假源码”</a>中，由浅入深介绍了关于一篇经典面试题的解法。<br>最后在皆大欢喜的结尾中，突生变化，悬念又起。这一篇，就是为了解开这个悬念。</p>
<p>如果你还没有看过<a href="https://exp-team.github.io/blog/2017/01/20/js/bind/">前传</a>，可以参看前情回顾：</p>
<p>回顾1. 题目是模拟实现ES5中原生bind函数；<br>回顾2. 我们通过4种递进实现达到了完美状态；<br>回顾3. 可是ES5-shim中的实现，又让我们大跌眼镜…</p>
<h2 id="ES5-shim的悬念"><a href="#ES5-shim的悬念" class="headerlink" title="ES5-shim的悬念"></a>ES5-shim的悬念</h2><p>ES5-shim实现方式源码贴在了最后，我们看看他做了什么奇怪的事情：<br>1）从结果上看，返回了bound函数。<br>2）bound函数是这样子声明的：</p>
<pre><code>bound = Function(&apos;binder&apos;, &apos;return function (&apos; + boundArgs.join(&apos;,&apos;) + &apos;){ return binder.apply(this, arguments); }&apos;)(binder);
</code></pre><p>3）bound使用了系统自己的构造函数Function来声明，第一个参数是binder，函数体内又binder.apply(this, arguments)。<br>我们知道这种动态创建函数的方式，类似eval。最好不要使用它，因为用它定义函数比用传统方式要慢得多。<br>4）那么ES5-shim抽风了吗？</p>
<h2 id="追根问底"><a href="#追根问底" class="headerlink" title="追根问底"></a>追根问底</h2><p>答案肯定是没抽风，他这样做是有理由的。</p>
<h3 id="神秘的函数的length属性"><a href="#神秘的函数的length属性" class="headerlink" title="神秘的函数的length属性"></a>神秘的函数的length属性</h3><p>你可能不知道，每个函数都有length属性。对，就像数组和字符串那样。函数的length属性，用于表示函数的形参个数。更重要的是函数的length属性值是不可重写的。我写了个测试代码来证明：</p>
<pre><code>function test (){}
test.length  // 输出0
test.hasOwnProperty(&apos;length&apos;)  // 输出true
Object.getOwnPropertyDescriptor(&apos;test&apos;, &apos;length&apos;) 
// 输出：
// configurable: false, 
// enumerable: false,
// value: 4, 
// writable: false 
</code></pre><h3 id="拨云见日"><a href="#拨云见日" class="headerlink" title="拨云见日"></a>拨云见日</h3><p>说到这里，那就好解释了。<br>ES5-shim是为了最大限度的进行兼容，包括对返回函数length属性的还原。如果按照我们之前实现的那种方式，length值始终为零。<br>所以：既然不能修改length的属性值，那么在初始化时赋值总可以吧！<br>于是我们可通过eval和new Function的方式动态定义函数来。<br>同时，很有意思的是，源码里有这样的注释：</p>
<pre><code>// XXX Build a dynamic function with desired amount of arguments is the only
// way to set the length property of a function.
// In environments where Content Security Policies enabled (Chrome extensions,
// for ex.) all use of eval or Function costructor throws an exception.
// However in all of these environments Function.prototype.bind exists
// and so this code will never be executed.
</code></pre><p>他解释了为什么要使用动态函数，就如同我们上边所讲的那样，是为了保证length属性的合理值。但是在一些浏览器中出于安全考虑，使用eval或者Function构造器都会被抛出异常。但是，巧合也就是这些浏览器基本上都实现了bind函数，这些异常又不会被触发。</p>
<p>So, What a coincidence!</p>
<h3 id="叹为观止"><a href="#叹为观止" class="headerlink" title="叹为观止"></a>叹为观止</h3><p>我们明白了这些，再看他的进一步实现：</p>
<pre><code>if (!isCallable(target)) {
    throw new TypeError(&apos;Function.prototype.bind called on incompatible &apos; + target);
}
</code></pre><p>这是为了保证调用的正确性，他使用了isCallable做判断，isCallable很好实现：</p>
<pre><code>isCallable = function isCallable(value) { 
    if (typeof value !== &apos;function&apos;) { 
        return false; 
    }
}
</code></pre><p>重设绑定函数的length属性：</p>
<pre><code>var boundLength = max(0, target.length - args.length);
</code></pre><p>构造函数调用情况，在binder中也有效兼容。如果你不明白什么是构造函数调用情况，可以参考<a href="https://exp-team.github.io/blog/2017/01/20/js/bind/">上一篇</a>。</p>
<pre><code>if (this instanceof bound) { 
    ... // 构造函数调用情况
} else {
    ... // 正常方式调用
}

if (target.prototype) {
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    // Clean up dangling references.
    Empty.prototype = null;
}
</code></pre><h2 id="无穷无尽"><a href="#无穷无尽" class="headerlink" title="无穷无尽"></a>无穷无尽</h2><p>当然，ES5-shim里还归纳了几项todo…</p>
<pre><code>// TODO
// 18. Set the [[Extensible]] internal property of F to true.
// 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
// 20. Call the [[DefineOwnProperty]] internal method of F with
//   arguments &quot;caller&quot;, PropertyDescriptor {[[Get]]: thrower, [[Set]]:
//   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
//   false.
// 21. Call the [[DefineOwnProperty]] internal method of F with
//   arguments &quot;arguments&quot;, PropertyDescriptor {[[Get]]: thrower,
//   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
//   and false.
// 22. Return F.
</code></pre><p>比较简单，我就不再翻译了。</p>
<h2 id="源码回放"><a href="#源码回放" class="headerlink" title="源码回放"></a>源码回放</h2><pre><code>bind: function bind(that) {
    var target = this;
    if (!isCallable(target)) {
        throw new TypeError(&apos;Function.prototype.bind called on incompatible &apos; + target);
    }
    var args = array_slice.call(arguments, 1);
    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                array_concat.call(args, array_slice.call(arguments))
            );
            if ($Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                array_concat.call(args, array_slice.call(arguments))
            );
        }
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i &lt; boundLength; i++) {
        array_push.call(boundArgs, &apos;$&apos; + i);
    }
    bound = Function(&apos;binder&apos;, &apos;return function (&apos; + boundArgs.join(&apos;,&apos;) + &apos;){ return binder.apply(this, arguments); }&apos;)(binder);

    if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过学习ES5-shim的源码实现bind方法，结合前一篇，希望读者能对bind和JS包括闭包，原型原型链，this等一系列知识点能有更深刻的理解。<br>同时在程序设计上，尤其是逻辑的严密性上，有所积累。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇&lt;a href=&quot;https://exp-team.github.io/blog/2017/01/20/js/bind/&quot;&gt;从一道面试题的进阶，到“我可能看了假源码”&lt;/a&gt;中，由浅入深介绍了关于一篇经典面试题的解法。&lt;br&gt;最后在皆大欢喜的结尾中，突生变化，悬念又起
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从一道面试题的进阶，到“我可能看了假源码”</title>
    <link href="https://exp-team.github.io/blog/2017/02/20/js/bind/"/>
    <id>https://exp-team.github.io/blog/2017/02/20/js/bind/</id>
    <published>2017-02-19T16:00:00.000Z</published>
    <updated>2017-02-22T13:52:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天想谈谈一道前端面试题，我做面试官的时候经常喜欢用它来考察面试者的基础是否扎实，以及逻辑、思维能力和临场表现，题目是：“模拟实现ES5中原生bind函数”。<br>也许这道题目已经不再新鲜，部分读者也会有思路来解答。社区上关于原生bind的研究也很多，比如用它来实现函数“颗粒化（currying）”，<br>或者“反颗粒化（uncurrying）”。<br>但是，我确信有很多细节是您注意不到的，也是社区上关于这个话题普遍缺失的。<br>这篇文章面向有较牢固JS基础的读者，会从最基本的理解入手，一直到分析ES5-shim实现bind源码，相信不同程度的读者都能有所收获。<br>也欢迎大家与我讨论。</p>
<h2 id="bind函数究竟是什么"><a href="#bind函数究竟是什么" class="headerlink" title="bind函数究竟是什么?"></a>bind函数究竟是什么?</h2><p>在开启我们的探索之前，有必要先明确一下bind到底实现了什么：<br>1）简单粗暴地来说，bind是用于绑定this指向的。（如果你还不了解JS中this的指向问题，以及执行环境上下文的奥秘，这篇文章暂时就不太适合阅读）。</p>
<p>2）bind使用语法：</p>
<pre><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre><p>bind方法会创建一个新函数。当这个新函数被调用时，bind的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。本文不打算科普基础，如果您还不清楚，请<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">参考MDN内容</a>。</p>
<p>3)bind返回的绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给模拟函数。</p>
<h2 id="初级实现"><a href="#初级实现" class="headerlink" title="初级实现"></a>初级实现</h2><p>了解了以上内容，我们来实现一个初级的bind函数Polyfill:</p>
<pre><code>Function.prototype.bind = function (context) {
    var me = this;
    var argsArray = Array.prototype.slice.call(arguments);
    return function () {
        return me.apply(context, argsArray.slice(1))
    }
}
</code></pre><p>这是一般“表现良好”的面试者所能给我提供的答案，如果面试者能写到这里，我会给他60分。<br>我们先简要解读一下：<br>基本原理是使用apply进行模拟。函数体内的this，就是需要绑定this的实例函数，或者说是原函数。最后我们使用apply来进行参数（context）绑定，并返回。<br>同时，将第一个参数（context）以外的其他参数，作为提供给原函数的预设参数，这也是基本的“颗粒化（curring）”基础。</p>
<h2 id="初级实现的加分项"><a href="#初级实现的加分项" class="headerlink" title="初级实现的加分项"></a>初级实现的加分项</h2><p>上面的实现（包括后面的实现），其实是一个典型的<a href="https://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="external">“Monkey patching(猴子补丁)”</a>，即“给内置对象扩展方法”。所以，如果面试者能进行一下“嗅探”，进行兼容处理，就是锦上添花了，我会给10分的附加分。</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) {
    ...
}
</code></pre><h2 id="颗粒化（curring）实现"><a href="#颗粒化（curring）实现" class="headerlink" title="颗粒化（curring）实现"></a>颗粒化（curring）实现</h2><p>上述的实现方式中，我们返回的参数列表里包含：atgsArray.slice(1)，他的问题在于存在预置参数功能丢失的现象。<br>想象我们返回的绑定函数中，如果想实现预设传参（就像bind所实现的那样），就面临尴尬的局面。真正实现颗粒化的“完美方式”是：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(context, finalArgs);
    }
}
</code></pre><p>如果面试者能够给出这样的答案，我内心独白会是“不错啊，貌似你就是我要找的那个TA～”。但是，我们注意在上边bind方法介绍的第三条提到：bind返回的函数如果作为构造函数，搭配new关键字出现的话，我们的绑定this就需要“被忽略”。</p>
<h2 id="构造函数场景下的兼容"><a href="#构造函数场景下的兼容" class="headerlink" title="构造函数场景下的兼容"></a>构造函数场景下的兼容</h2><p>有了上边的讲解，不难理解需要兼容构造函数场景的实现：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var F = function () {};
    F.prototype = this.prototype;
    var bound = function () {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(this instanceof F ? this : context || this, finalArgs);
    }
    bound.prototype = new F();
    return bound;
}
</code></pre><p>如果面试者能够写成这样，我几乎要给满分，会帮忙联系HR谈薪酬了。当然，还可以做的更加严谨。</p>
<h2 id="更严谨的做法"><a href="#更严谨的做法" class="headerlink" title="更严谨的做法"></a>更严谨的做法</h2><p>我们需要调用bind方法的一定要是一个函数，所以可以在函数体内做一个判断：</p>
<pre><code>if (typeof this !== &quot;function&quot;) {
  throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}
</code></pre><p>做到所有这一切，我会很开心的给满分。其实MDN上有个自己实现的polyfill，就是如此实现的。<br>另外，《JavaScript Web Application》一书中对bind()的实现，也是如此。</p>
<p>故事貌似要画上休止符了——</p>
<h2 id="一切还没完，高潮即将上演"><a href="#一切还没完，高潮即将上演" class="headerlink" title="一切还没完，高潮即将上演"></a>一切还没完，高潮即将上演</h2><p>如果你认为这样就完了，其实我会告诉你说，高潮才刚要上演。曾经的我也认为上述方法已经比较完美了，直到我看了es5-shim源码（已适当删减）：</p>
<pre><code>bind: function bind(that) {
    var target = this;
    if (!isCallable(target)) {
        throw new TypeError(&apos;Function.prototype.bind called on incompatible &apos; + target);
    }
    var args = array_slice.call(arguments, 1);
    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                array_concat.call(args, array_slice.call(arguments))
            );
            if ($Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                array_concat.call(args, array_slice.call(arguments))
            );
        }
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i &lt; boundLength; i++) {
        array_push.call(boundArgs, &apos;$&apos; + i);
    }
    bound = Function(&apos;binder&apos;, &apos;return function (&apos; + boundArgs.join(&apos;,&apos;) + &apos;){ return binder.apply(this, arguments); }&apos;)(binder);

    if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
}
</code></pre><p>看到了这样的实现，心中的困惑太多，不禁觉得我看了“假源码”。但是仔细分析一下，剩下就是一个大写的 。。。服！<br>这里先留一个悬念，不进行源码分析。读者可以自己先研究一下。如果想看源码分析，点击<a href="https://exp-team.github.io/blog/2017/02/20/js/es5-shim-bind/">这篇文章的后续－源码解读</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过比对几版的polyfill实现，对于bind应该有了比较深刻的认识。作为这道面试题的考察点，肯定不是让面试者实现低版本浏览器的向下兼容，因为我们有了es5-shim,es5-sham处理兼容性问题，并且无脑兼容我也认为是历史的倒退。<br>回到这道题考查点上，他有效的考察了很重要的知识点：比如this的指向，JS的闭包，原型原型链功力，设计程序上的兼容考虑等等硬素质。<br>在前端技术快速发展迭代的今天，在“前端市场是否饱和”“前端求职火爆异常”“前端入门简单，钱多人傻”的浮躁环境下，对基础内功的修炼就显得尤为重要，这也是你在前端路上能走多远、走多久的关键。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想谈谈一道前端面试题，我做面试官的时候经常喜欢用它来考察面试者的基础是否扎实，以及逻辑、思维能力和临场表现，题目是：“模拟实现ES5中原生bind函数”。&lt;br&gt;也许这道题目已经不再新鲜，部分读者也会有思路来解答。社区上关于原生bind的研究也很多，比如用它来实现函数“
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10101期</title>
    <link href="https://exp-team.github.io/blog/2017/01/21/weekly/weekly-10101/"/>
    <id>https://exp-team.github.io/blog/2017/01/21/weekly/weekly-10101/</id>
    <published>2017-01-20T16:00:00.000Z</published>
    <updated>2017-02-19T12:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.16-1.21，马上要放假了，提前祝大家春节快乐，年终总结还没写的抓紧了，本期送个大家一副对联</p>
<p>上联：微博知乎占头条谁与争锋</p>
<p>下联：桌面移动待前端一统江湖</p>
<p>横批：瞬息万变</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="二十个令程序员泪流满面的瞬间"><a href="#二十个令程序员泪流满面的瞬间" class="headerlink" title="二十个令程序员泪流满面的瞬间"></a><a href="http://mp.weixin.qq.com/s?__biz=MzI2MzEzNzQ3MQ==&amp;mid=2650307110&amp;idx=1&amp;sn=e7a247e1dd3b86d3441806ad24cb094c&amp;chksm=f24cabf6c53b22e086a09b8481b10879f073e56073290e4f75dddb55cc74ff2b0d76ea15dad0&amp;mpshare=1&amp;scene=1&amp;srcid=0119Hrto64icL7EJf7WWxzwI#rd" target="_blank" rel="external">二十个令程序员泪流满面的瞬间</a></h3><p>只有程序员能看懂的gif图，感同身受，泪流满面啊，%&gt;_&lt;%</p>
<h3 id="2017年的前端该学些什么-md"><a href="#2017年的前端该学些什么-md" class="headerlink" title="2017年的前端该学些什么.md"></a><a href="https://github.com/fezaoduke/TranslationInstitute/blob/master/2017%E5%B9%B4%E7%9A%84%E5%89%8D%E7%AB%AF%E8%AF%A5%E5%AD%A6%E4%BA%9B%E4%BB%80%E4%B9%88.md" target="_blank" rel="external">2017年的前端该学些什么.md</a></h3><p>17年你打算学点啥？给自己设定好规划了没？还在迷茫的同学看看这篇文章吧，2017一起加油</p>
<h3 id="搜罗一切webpack的好文章好工具"><a href="#搜罗一切webpack的好文章好工具" class="headerlink" title="搜罗一切webpack的好文章好工具"></a><a href="https://github.com/webpack-china/awesome-webpack-cn" target="_blank" rel="external">搜罗一切webpack的好文章好工具</a></h3><p>webpakc2发布了，又到了伤筋动骨，加班熬夜的时候了，关于webpack的一切文章都在这里</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="掌握这5大核心概念，你就理解了React"><a href="#掌握这5大核心概念，你就理解了React" class="headerlink" title="掌握这5大核心概念，你就理解了React"></a><a href="https://zhuanlan.zhihu.com/p/24833815" target="_blank" rel="external">掌握这5大核心概念，你就理解了React</a></h3><p>react就这5个东西，还没入门的同学，或者深陷其中的同学快来围观，react不难，难得是用react做东西</p>
<h3 id="一个react-redux工程实例"><a href="#一个react-redux工程实例" class="headerlink" title="一个react+redux工程实例"></a><a href="http://www.jianshu.com/p/8e28be0e7ab1?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="external">一个react+redux工程实例</a></h3><h3 id="揭秘babel的魔法之class继承的处理2"><a href="#揭秘babel的魔法之class继承的处理2" class="headerlink" title="揭秘babel的魔法之class继承的处理2"></a><a href="http://www.jianshu.com/p/95901615f322" target="_blank" rel="external">揭秘babel的魔法之class继承的处理2</a></h3><h3 id="全栈JS工程师的崛起"><a href="#全栈JS工程师的崛起" class="headerlink" title="全栈JS工程师的崛起"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651225356&amp;idx=1&amp;sn=4740cca7ab89b4449bfe5438e1427729&amp;chksm=bd49a4888a3e2d9e8c625d116fcc42db25c11421ba79d47dff272f0db8f6e5427d1bdbf3fe1b&amp;mpshare=1&amp;scene=1&amp;srcid=0120NQv87HQjc6Q50a1LLF0w#rd" target="_blank" rel="external">全栈JS工程师的崛起</a></h3><p>先精后广，一专多长，不想成为全栈的工程师，不是好工程师，一起加油</p>
<h3 id="250行实现一个简单的MVVM"><a href="#250行实现一个简单的MVVM" class="headerlink" title="250行实现一个简单的MVVM"></a><a href="https://zhuanlan.zhihu.com/p/24475845" target="_blank" rel="external">250行实现一个简单的MVVM</a></h3><p>一直想动手写一个mvvm框架，就从这篇文章开始吧</p>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="Google发布新的图像压缩技术，最高可节省75％带宽"><a href="#Google发布新的图像压缩技术，最高可节省75％带宽" class="headerlink" title="Google发布新的图像压缩技术，最高可节省75％带宽"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659598877&amp;idx=1&amp;sn=704e7d5a05adaff567c9adf015753124&amp;chksm=8be9970fbc9e1e191b0f3cf92a9dd6e76ad4a8d0fff38a30ed772033eb0ac10f6356d2a4f528&amp;mpshare=1&amp;scene=1&amp;srcid=0118TvMOVHhoZN10kF4DDpc6#rd" target="_blank" rel="external">Google发布新的图像压缩技术，最高可节省75％带宽</a></h3><h3 id="Bluebird-是如何做到比原生实现更快的？"><a href="#Bluebird-是如何做到比原生实现更快的？" class="headerlink" title="Bluebird 是如何做到比原生实现更快的？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964223&amp;idx=1&amp;sn=f2c37c05fb6ad370a67c59ca745bd7bf&amp;chksm=843aec99b34d658f043acdea3a3c5b948d664cff48947f4616ccebac4548c5b57978c0d3be38&amp;mpshare=1&amp;scene=1&amp;srcid=0117zptRUZNoEger5avSAAem#rd" target="_blank" rel="external">Bluebird 是如何做到比原生实现更快的？</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="你可能不知道的-Mac-技巧-文本操作"><a href="#你可能不知道的-Mac-技巧-文本操作" class="headerlink" title="你可能不知道的 Mac 技巧 - 文本操作"></a><a href="https://zhuanlan.zhihu.com/p/24921055" target="_blank" rel="external">你可能不知道的 Mac 技巧 - 文本操作</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.16-1.21，马上要放假了，提前祝大家春节快乐，年终总结还没写的抓紧了，本期送个大家一副对联&lt;/p&gt;
&lt;p&gt;上联：微博知乎占头条谁与争锋&lt;/p&gt;
&lt;p&gt;下联：桌面移动待前端一统江湖&lt;/p&gt;
&lt;p&gt;横批：瞬息万变&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;二十个令程序员泪流满面的瞬间&quot;&gt;&lt;a href=&quot;#二十个令程序员泪流满面的瞬间&quot; class=&quot;headerlink&quot; title=&quot;二十个令程序员泪流满面的瞬间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MzEzNzQ3MQ==&amp;amp;mid=2650307110&amp;amp;idx=1&amp;amp;sn=e7a247e1dd3b86d3441806ad24cb094c&amp;amp;chksm=f24cabf6c53b22e086a09b8481b10879f073e56073290e4f75dddb55cc74ff2b0d76ea15dad0&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0119Hrto64icL7EJf7WWxzwI#rd&quot;&gt;二十个令程序员泪流满面的瞬间&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;只有程序员能看懂的gif图，感同身受，泪流满面啊，%&amp;gt;_&amp;lt;%&lt;/p&gt;
&lt;h3 id=&quot;2017年的前端该学些什么-md&quot;&gt;&lt;a href=&quot;#2017年的前端该学些什么-md&quot; class=&quot;headerlink&quot; title=&quot;2017年的前端该学些什么.md&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/fezaoduke/TranslationInstitute/blob/master/2017%E5%B9%B4%E7%9A%84%E5%89%8D%E7%AB%AF%E8%AF%A5%E5%AD%A6%E4%BA%9B%E4%BB%80%E4%B9%88.md&quot;&gt;2017年的前端该学些什么.md&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;17年你打算学点啥？给自己设定好规划了没？还在迷茫的同学看看这篇文章吧，2017一起加油&lt;/p&gt;
&lt;h3 id=&quot;搜罗一切webpack的好文章好工具&quot;&gt;&lt;a href=&quot;#搜罗一切webpack的好文章好工具&quot; class=&quot;headerlink&quot; title=&quot;搜罗一切webpack的好文章好工具&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/webpack-china/awesome-webpack-cn&quot;&gt;搜罗一切webpack的好文章好工具&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;webpakc2发布了，又到了伤筋动骨，加班熬夜的时候了，关于webpack的一切文章都在这里&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>伍酱的2016</title>
    <link href="https://exp-team.github.io/blog/2017/01/21/other/wujiang-2016/"/>
    <id>https://exp-team.github.io/blog/2017/01/21/other/wujiang-2016/</id>
    <published>2017-01-20T16:00:00.000Z</published>
    <updated>2017-02-19T12:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>二零一六年，是对我来说非常不一样的一年。</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/me.JPG" alt="&quot;Cooks Beach&quot;"></p>
<h2 id="例行总结"><a href="#例行总结" class="headerlink" title="例行总结"></a>例行总结</h2><ul>
<li>读书41本，目标50，<strong>不达标</strong>；</li>
<li>理财，实盘-7.17%，大盘沪指-12.31%，跑赢大盘，目标10%，<strong>不达标</strong>；（出国期间管都没管，要什么自行车）</li>
<li>2016年的技术规划，在我离职时把我能做的都做完了，<strong>get√</strong></li>
<li>新西兰环岛，<strong>get√</strong></li>
</ul>
<p>搞siao，啥都不达标，总结啥！？哦~</p>
<a id="more"></a>
<h2 id="此处开始-——-抒情随意总结"><a href="#此处开始-——-抒情随意总结" class="headerlink" title="此处开始 —— 抒情随意总结"></a>此处开始 —— 抒情随意总结</h2><p>2016年6月，结束了在大百度的工作，我贡献了3年多青春的”初恋”。上半年的故事，之前在<a href="/archives/resign-from-baidu/">《离职这件小事》</a>里已经说得差不多了，姑且当做上半年总结吧。</p>
<p>希望鸡神眷顾我找到靠谱的新工作~</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/chicken.JPG" alt=""></p>
<p>随后，说走就走，开展了为期6个月的新西兰打工旅行。换宿、<a href="/archives/work-whv/">打季节工</a>、半年换了3辆战车、以露营为主的自驾环南北岛……从来没有过那么颠沛流离、充满对未知的恐惧，当然也带着一丝对未来小刺激的期待，像我之前说的，每一天都需要勇气来生活。</p>
<p>2016年下半年的生活的可能性和丰富度，时间只有半年，却比我以往的26年都要多，刺激得不行不行的。于是我变成了一个有故事的女同学，哈哈，故事、人物和感受太多，一时之间，不知从何说起。（让你懒惰之前不写日志！！）</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/farm.JPG" alt="&quot;Kerikeri Nursery&quot;"></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/hitch-hike.JPG" alt="&quot;Hitch hike in Paihia&quot;"></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/fishing.JPG" alt="&quot;Fishing&quot;"></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/Tongariro.JPG" alt="&quot;Tongariro National Park&quot;"></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/camp.JPG" alt="&quot;camping&quot;"></p>
<p>原本有占据2页的篇幅（写于奥克兰机场），记录一个我精心挑选的年度最佳的故事，但是在跟我爸妈聊天后，我决定删掉。出来行走江湖，谁没有几个悲伤的故事，不用时刻拿出来卖惨，我重新认识一个<strong>坚强和强悍抗压的自己</strong>已经够了，哈哈，成长的代价。</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/deleted-post.JPG" alt=""></p>
<p>很好奇发生了什么是不是？我就不说~ 简而言之，就是发生了一个（或者几个）小插曲，让我变得一无所有，差点没有办法回国，我崩溃了一小下，不过很快收拾好心情妥善处理好一切。这些我当时没有跟任何人说，几个小伙伴知道都是我事后说的，不想家人或者朋友干担心瞎着急。</p>
<p>前几天，我跟爸妈说起我在新西兰经历的各种，也包括那些小插曲，并没有收到爸妈的安慰，那个瞬间我真怀疑自己到底是不是亲生的，哈哈。我遇到的“大麻烦”，在阅历丰富的爸妈眼里，不值一提。</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/car.JPG" alt=""></p>
<p>爸妈说：</p>
<blockquote>
<p>你以为自己有多大损失、多委屈，比起你能安全回国，根本不算事儿。你出发之前，我们劝你不要停留那么久，在那边玩2、3个礼拜就算了。但是你坚持要留那么久，我们也只能支持你。</p>
<p>发生这样的事情，完全在我们意料之中，这就是为什么你出国前我们联系到奥克兰的阿姨，让你有事去找她帮忙。你在国外时，我们每天都在担心。你会不会开车冲下山？会不会撞到别人？会不会遇到坏人？会不会失联，从此人间蒸发？</p>
</blockquote>
<p>惊奇地发现，在我出发前后，他们说的话是一样的，但作为听众的我，感受却大不相同。真倒霉起来，老天爷要耍我的话，他们担心的事情是真会变成现实的，最坏情况是客死异乡，而我在途中真实遇到的若干次意外，跟死神擦身而过。细思极恐，他们的担心不无道理，真苦了他们天天为我担惊受怕。</p>
<p><strong>感谢爸妈</strong>，在那么担心的情况下，没有干预我的决定，尊重我的选择。<br><strong>感谢老天</strong>，我顺利安全回国了。</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/airport.JPG" alt="&quot;Auckland Airport&quot;"></p>
<h2 id="神秘的旅伴-——-猩爷"><a href="#神秘的旅伴-——-猩爷" class="headerlink" title="神秘的旅伴 —— 猩爷"></a>神秘的旅伴 —— 猩爷</h2><p>嗯，虽然我自认为找工作、沟通和抗压的技能指数爆表（了不起！）但是这一路走下来，我特别想<strong>感谢我的旅伴 —— 猩爷</strong></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/b-1.JPG" alt="&quot;猩爷的沙滩写真&quot;"></p>
<p>旅行是最能看清楚一个人的时候，因为大家会遇到各种难题各种令人崩溃的事情，变态、极端到你这辈子可能都不会再有机会遇到。我崩溃的时候，还是她把我拉回来的，真真了不起！</p>
<ul>
<li>吃苦耐劳</li>
<li>一身洪荒之力无处释放</li>
<li>做得一桌好菜</li>
<li>搭得一顶好帐篷</li>
<li>开得一手好车（自称“青秀山车神”）</li>
<li>夕阳红爬山队的教练和打杂</li>
</ul>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/b-2.JPG" alt="&quot;悬崖边上的猩爷&quot;"></p>
<p>在那么艰苦的荒野求生中，我还是长胖了，真的要好好感谢她（咬牙切齿）</p>
<p>（上述各种都是猩爷做，你做了什么？）噢~ 我一般什么都不做，在旁边做<strong>鼓励师</strong>和<strong>卖萌机器人</strong>，衬托能干的她，哈哈哈！</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p><code>问</code> 澳洲的WHV签证还申请吗？<br><code>答</code> 不要。这半年我感觉够够的，后悔得要死，跟我想的完全不一样。短期内也不想旅行了，哈哈。</p>
<p><code>问</code> 如果时光倒流，可以再选一次，还要去新西兰吗？<br><code>答</code> 去啊，说走还走！不去永远不知道，喜欢或者不喜欢，开心抑或不开心，总得经历过才知道，美不在天堂，而在前往天堂的路上，也许这就是成长的代价吧。</p>
<p>原文链接：<a href="http://www.wuyuying.com/archives/year-2016?fr=exp-fe" target="_blank" rel="external">http://www.wuyuying.com/archives/year-2016/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二零一六年，是对我来说非常不一样的一年。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.sinacloud.net/woodysblog/2016/me.JPG&quot; alt=&quot;&amp;quot;Cooks Beach&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;例行总结&quot;&gt;&lt;a href=&quot;#例行总结&quot; class=&quot;headerlink&quot; title=&quot;例行总结&quot;&gt;&lt;/a&gt;例行总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;读书41本，目标50，&lt;strong&gt;不达标&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;理财，实盘-7.17%，大盘沪指-12.31%，跑赢大盘，目标10%，&lt;strong&gt;不达标&lt;/strong&gt;；（出国期间管都没管，要什么自行车）&lt;/li&gt;
&lt;li&gt;2016年的技术规划，在我离职时把我能做的都做完了，&lt;strong&gt;get√&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;新西兰环岛，&lt;strong&gt;get√&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;搞siao，啥都不达标，总结啥！？哦~&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="https://exp-team.github.io/categories/other/"/>
    
    
      <category term="other" scheme="https://exp-team.github.io/tags/other/"/>
    
      <category term="summary" scheme="https://exp-team.github.io/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10100期</title>
    <link href="https://exp-team.github.io/blog/2017/01/13/weekly/weekly-10100/"/>
    <id>https://exp-team.github.io/blog/2017/01/13/weekly/weekly-10100/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2017-01-13T12:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.8-1.13，新的一期，继续积累！</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="《JS-闯关记》之原型及原型链"><a href="#《JS-闯关记》之原型及原型链" class="headerlink" title="《JS 闯关记》之原型及原型链"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ%3D%3D&amp;mid=2650101216&amp;idx=1&amp;sn=dcc39636ebff46aca84df68533fb0742&amp;chksm=f07509c8c70280deb444e9ac5405982e0892f1331bdc02a48f4161dba0f27dcde8f4acf2cd07&amp;scene=0" target="_blank" rel="external">《JS 闯关记》之原型及原型链</a></h3><p>原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的<strong>proto</strong> 属性指向创建它的构造函数的 prototype（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、<strong>proto</strong> 这五个概念入手。</p>
<h3 id="H5项目常见问题及注意事项"><a href="#H5项目常见问题及注意事项" class="headerlink" title="H5项目常见问题及注意事项"></a><a href="http://www.open-open.com/lib/view/open1449325854077.html" target="_blank" rel="external">H5项目常见问题及注意事项</a></h3><p>再也不用为PM嘴中的“H5”发愁了。</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="揭秘babel的魔法之class魔法处理"><a href="#揭秘babel的魔法之class魔法处理" class="headerlink" title="揭秘babel的魔法之class魔法处理"></a><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjE5NzAyMA==&amp;mid=2649879842&amp;idx=1&amp;sn=0e7eb27fd9bb7f5ba9bbd2b3640ba663&amp;chksm=f0ded0d1c7a959c785fd8c8b384e348506ea4dd40ca72a8fac00aa4f34ab07aacab6aa92514b&amp;mpshare=1&amp;scene=1&amp;srcid=01132iAX9Sp6Gpll9otS2un8&amp;key=59506e83f2f7e1fd47b66ec743010bafb62e75b40f02a088b7a58ef822f0fcfe14c244308ee819c24dd7303946792d0ace78d7c18cb31a020ca5b42528939fa5ce021ed6ae7a77d738521132ff2afee9&amp;ascene=0&amp;uin=NjI4NTQ2ODIx&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46" target="_blank" rel="external">揭秘babel的魔法之class魔法处理</a></h3><p>揭秘Babel的同时，在复习一遍原型链基础支持～</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="如何让你的-CSS-更具有可维护性？——大神有绝招-amp"><a href="#如何让你的-CSS-更具有可维护性？——大神有绝招-amp" class="headerlink" title="如何让你的 CSS 更具有可维护性？——大神有绝招&amp;)"></a><a href="https://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964179&amp;idx=1&amp;sn=f7088de66f09efd35057541695582d52&amp;chksm=843aecb5b34d65a3ff8d67142403f3463e08f57041f4212e991248f49770b59943d5c65545bc&amp;mpshare=1&amp;scene=1&amp;srcid=0111H4YARr96el0lj1WY0J09&amp;key=f27a3d85b887ad782291dcbcbc6989e0bb3335f0f66ac9cc6b6994c455227fac808715c21fb47af4ad18b5ff25efbb9aca75f3d0bbf57baefb60f1d36971b42fa9d323e2b3d80208070837dfd770fa49&amp;ascene=0&amp;uin=NjI4NTQ2ODIx&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46" target="_blank" rel="external">如何让你的 CSS 更具有可维护性？——大神有绝招</a>&amp;)</h3><p>这篇文章教你一种方法，能够写出更具有可维护性的CSS，它就是”BEM”。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="回顾-2016-年-Node-js-十大文章-amp"><a href="#回顾-2016-年-Node-js-十大文章-amp" class="headerlink" title="回顾 2016 年 Node.js 十大文章&amp;)"></a><a href="https://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964196&amp;idx=1&amp;sn=d52e8258b54e0d807e14efa5a2791f84&amp;chksm=843aec82b34d65944704e1f7fc04747934bad078ad91906781f21edeb204a9a55f4d9f129369&amp;mpshare=1&amp;scene=1&amp;srcid=0111eOoheFnpABemlLvmHvL9&amp;key=b43a3af60b96e11e86b22b45b526335d70f3fbb0d1f05d664eb97888d1744e7026b64c4bdae93ab2ceb9092123f81dfcaecf157e9a43e4e2bed516a6b9db9e4e0fe03330913f5cfcf971d9ac46dfaf8e&amp;ascene=0&amp;uin=NjI4NTQ2ODIx&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46" target="_blank" rel="external">回顾 2016 年 Node.js 十大文章</a>&amp;)</h3><p>对于Node.js开发者来说，2016是振奋人心的一年。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.8-1.13，新的一期，继续积累！&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;《JS-闯关记》之原型及原型链&quot;&gt;&lt;a href=&quot;#《JS-闯关记》之原型及原型链&quot; class=&quot;headerlink&quot; title=&quot;《JS 闯关记》之原型及原型链&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ%3D%3D&amp;amp;mid=2650101216&amp;amp;idx=1&amp;amp;sn=dcc39636ebff46aca84df68533fb0742&amp;amp;chksm=f07509c8c70280deb444e9ac5405982e0892f1331bdc02a48f4161dba0f27dcde8f4acf2cd07&amp;amp;scene=0&quot;&gt;《JS 闯关记》之原型及原型链&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的&lt;strong&gt;proto&lt;/strong&gt; 属性指向创建它的构造函数的 prototype（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、&lt;strong&gt;proto&lt;/strong&gt; 这五个概念入手。&lt;/p&gt;
&lt;h3 id=&quot;H5项目常见问题及注意事项&quot;&gt;&lt;a href=&quot;#H5项目常见问题及注意事项&quot; class=&quot;headerlink&quot; title=&quot;H5项目常见问题及注意事项&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1449325854077.html&quot;&gt;H5项目常见问题及注意事项&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;再也不用为PM嘴中的“H5”发愁了。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>如何使用PAC文件“科学上网”</title>
    <link href="https://exp-team.github.io/blog/2017/01/13/tool/using-pac/"/>
    <id>https://exp-team.github.io/blog/2017/01/13/tool/using-pac/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2017-01-15T12:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>万里长城是我们中华民族的瑰宝，是我们民族的骄傲，是世界八大奇迹之一，是我们中华的代表，它让我们避免了外族的侵略！</p>
<p>嗯，不过对我们现代中华儿女，我们要做的就是！翻越它去征服世界上所有的蛮夷之地！</p>
<a id="more"></a>
<h2 id="GFW"><a href="#GFW" class="headerlink" title="GFW"></a>GFW</h2><p>令人敬畏的Great Fire Wall，说起他的由来。。。等下，我有个顺丰快递。</p>
<h2 id="为什么要“科学上网”"><a href="#为什么要“科学上网”" class="headerlink" title="为什么要“科学上网”"></a>为什么要“科学上网”</h2><p>由于GFW的存在，我们失去了不少与友善外族沟通交流的机会，例如Facebook，Twitter，Instagram。我们只能靠那些处于水深火热环境中的朋友给我们搬运回来外族的消息。不过据说这些东西也不好玩，毕竟上面大部分都是外族百姓，我们不玩也罢。</p>
<p>然而！对我们技术宅们，不能与外族高端人士沟通，实属悲哀之事。既然州官不让，那百姓们就自己想办法咯。</p>
<p>“科学上网”方法其实有很多，今天介绍一个我个人比较认同的一个方法吧。</p>
<h2 id="通过PAC文件“科学上网”"><a href="#通过PAC文件“科学上网”" class="headerlink" title="通过PAC文件“科学上网”"></a>通过PAC文件“科学上网”</h2><p>首先，你要有一个可用的代理。没有代理的话就自己想办法搞一个吧。我不教╭(╯^╰)╮</p>
<p>PAC(Proxy Auto Config)实际上就是一个脚本(Script)，通过这个脚本，我们能够让系统判断在怎么样的情形下，要利用哪一台Proxy来进行联机。</p>
<p>在“科学上网”方面呢，我们可以让系统确认，哪些网站通过代理访问，哪些直接通过本机网络访问，这样一来避免了直接整机挂VPN而导致国内不少网站访问不了的尴尬情况。</p>
<p><strong>PAC文件采用JavaScript编写，想要实现高级规则，最好有点JavaScript基础^_^</strong></p>
<h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><p>先新建一个*.pac文件，然后输(fu)入(zhi)以下代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'DIRECT'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FindProxyForURL是PAC文件的“主函数”，PAC文件一定要定义它，所有的请求都会进入这个方法，然后匹配规则。</p>
<p>其中 <em>return ‘DIRECT’;</em> 表示直接使用本机网络直接访问，这一段目前的含义是所有请求通过本机网络直接访问。</p>
<p>PAC一共支持三种访问方式</p>
<ul>
<li>DIRECT <em>直接联机而不透过 Proxy</em></li>
<li>PROXY host:port <em>使用指定的 Proxy 伺服机</em></li>
<li>SOCKS host:port <em>使用指定的 Socks 伺服机</em></li>
</ul>
<p>比如将代码改成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'PROXY 127.0.0.1:7070'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则表示所有的请求，以HTTP方式，通过本机的7070端口访问。</p>
<h3 id="通过域名匹配规则"><a href="#通过域名匹配规则" class="headerlink" title="通过域名匹配规则"></a>通过域名匹配规则</h3><p>我这里就介绍一个比较常用的规则，通过域名匹配，如果一个请求在一个域名下，我们就走代理访问。</p>
<p>直接上代码吧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> autoproxy_host = &#123;</div><div class="line">    <span class="string">"google.com"</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">"twitter.com"</span>: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> lastPos;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> (autoproxy_host.hasOwnProperty(host)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'PROXY 127.0.0.1:7070'</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        lastPos = host.indexOf(<span class="string">'.'</span>) + <span class="number">1</span>;</div><div class="line">        host = host.slice(lastPos);</div><div class="line">    &#125; <span class="keyword">while</span> (lastPos &gt;= <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'DIRECT'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实会Js的朋友应该很容易就能看懂了，不断分隔域名，然后去匹配autoproxy_host中设定好了的域名，如果匹配上了，我们就通过本机7070端口代理访问，否则就直接通过本机网络访问。比如这里，访问google.com和twitter.com的时候，就通过代理访问。</p>
<p>实际上用的时候，记得把127.0.0.1:7070换成你自己代理，如果是SSH的代理，就用SOCKS就好了。</p>
<h3 id="使用PAC文件"><a href="#使用PAC文件" class="headerlink" title="使用PAC文件"></a>使用PAC文件</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>Windows上面使用PAC文件很简单，新建一个你的PAC文件，放在一个固定的位置，比如</p>
<p>D:\学习资料\国外学习资料\中外文化交流\跨越\别看\说了别看\搞毛啊\setting.pac</p>
<p>然后，Internet设置 -&gt; 连接 -&gt; 局域网设置 </p>
<p><img src="/bimg/pac-win-1.jpg" alt=""></p>
<p>勾选“自动检测设置”以及“使用自动配置脚本”，在“地址”里面填写</p>
<p>file:\\\ 加 文件路径，如下</p>
<p><img src="/bimg/pac-win-2.jpg" alt=""></p>
<p>然后多确认几次就好了，打开浏览器或者IE（没错我就是来黑IE的）试试看吧！</p>
<h4 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX"></a>Mac OSX</h4><p>Mac上面比较麻烦，因为最新的OSX是不支持本地文件设置的，你需要填写一个网络地址。比较好的办法是你现在本地建立一个服务器，然后把你的pac文件丢进去，然后通过http能访问就好了。</p>
<p>在Mac上建立本地服务器的方法很多，比如自带的apache。直接在命令行输入</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apachectl start</div></pre></td></tr></table></figure>
<p>一般默认的目录都是 /Library/WebServer/Documents，你也可以修改/etc/apache2/httpd.conf里面的DocumentRoot配置项，修改服务器的默认路径。</p>
<p>把pac文件放进根目录，然后就可以直接通过 <a href="http://localhost/file.pac" target="_blank" rel="external">http://localhost/file.pac</a> 来访问了。</p>
<p>接下来是配置网络，系统偏好 -&gt; 网络 -&gt; 高级 -&gt; 代理</p>
<p>勾选“Automatic Proxy Configuration”，在右侧填写pac文件路径就好了。</p>
<p><img src="/bimg/pac-mac-1.png" alt=""></p>
<p>至此，大伙儿就开开心心地来“科学上网”吧！！！\(^o^)/！！</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>然后，没错，我就是被颜大大拜托过来耍宝的！=￣ω￣=</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;万里长城是我们中华民族的瑰宝，是我们民族的骄傲，是世界八大奇迹之一，是我们中华的代表，它让我们避免了外族的侵略！&lt;/p&gt;
&lt;p&gt;嗯，不过对我们现代中华儿女，我们要做的就是！翻越它去征服世界上所有的蛮夷之地！&lt;/p&gt;
    
    </summary>
    
      <category term="tool" scheme="https://exp-team.github.io/categories/tool/"/>
    
    
      <category term="tool" scheme="https://exp-team.github.io/tags/tool/"/>
    
      <category term="pac" scheme="https://exp-team.github.io/tags/pac/"/>
    
  </entry>
  
  <entry>
    <title>揭秘babel的魔法之class继承的处理</title>
    <link href="https://exp-team.github.io/blog/2017/01/12/js/babel-class2/"/>
    <id>https://exp-team.github.io/blog/2017/01/12/js/babel-class2/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-01-16T07:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你已经看过第一篇<a href="http://www.jianshu.com/p/d36fb31f9cff" target="_blank" rel="external">揭秘babel的魔法之class魔法处理</a>，这篇将会是一个延伸；<br>如果你还没看过，并且也不想<a href="http://www.jianshu.com/p/d36fb31f9cff" target="_blank" rel="external">现在就去读一下</a>，单独看这篇也没有关系，并不存在理解上的障碍。</p>
<p>上一篇针对Babel对ES6里面基础“class”的编译进行了分析。这一篇将会对class的继承，包括extends和super进行讲解。</p>
<p>什么？你还不了解ES6如何实现继承？没关系，下文内容也有详细示例。</p>
<p>再啰嗦一句，这一系列的文章并不是科普ECMAScript新规范。她的意义在于分析Babel对ES6的编译，从而希望读者对JS语言基础，程序设计理念等有更深刻的认识。</p>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>在这篇文章中，我会讲解Babel如何处理ES6 Class里面的继承功能，同样，这其实是一系列语法糖的实现。<br>我们先来温习一下实现方式：</p>
<h3 id="ES6-实现继承"><a href="#ES6-实现继承" class="headerlink" title="ES6 实现继承"></a>ES6 实现继承</h3><p>首先，我们定义一个父类：</p>
<pre><code>class Person {
    constructor(){
        this.type = &apos;person&apos;
    }
}
</code></pre><p>这个类包含了一个实例属性。</p>
<p>然后，实现一个Student类，这个“学生”类继承“人”类：</p>
<pre><code>class Student extends Person {
    constructor(){
        super()
    }
}
</code></pre><p>从简出发，我们定义的Person类只包含了type为person的这一个属性，不含有方法。所以我们extends+super()之后，Student类<br>也继承了同样的属性。<br>如下：</p>
<pre><code>var student1 = new Student();
student1.type // &quot;person&quot;
</code></pre><p>我们进一步可以验证原型链上的关系：</p>
<pre><code>student1 instanceof Student // true
student1 instanceof Person // true
student1.hasOwnProperty(&apos;type&apos;) // true
</code></pre><p>一切看上去cool极了，我们实现了ES6里面的继承。并且用instanceof验证了ES6中一系列的实质就是“魔法糖”的本质。<br>那么，经过Babel编译，我们的代码是什么样呢？</p>
<h3 id="Babel-transformation"><a href="#Babel-transformation" class="headerlink" title="Babel transformation"></a>Babel transformation</h3><p>我们一步一步来看，</p>
<p>Step1: Person定义</p>
<pre><code>class Person {
    constructor(){
        this.type = &apos;person&apos;
    }
}
</code></pre><p>被编译为：</p>
<pre><code>var Person = function Person() {
    _classCallCheck(this, Person);
    this.type = &apos;person&apos;;
};
</code></pre><p>如果你看过这一篇的<a href="http://www.jianshu.com/p/d36fb31f9cff" target="_blank" rel="external">前传</a>，<br>你应该就熟悉这一系列的变换，也可能会记得_classCallCheck函数到底是什么鬼。这里因为篇幅和去冗余的原因，就不再展开。</p>
<p>Step2：Student探秘<br>我们这次尝试观察Student子类：</p>
<pre><code>class Student extends Person {
    constructor(){
        super()
    }
}
</code></pre><p>编译结果：</p>
<pre><code>// 实现定义Student构造函数，它是一个自执行函数，接受父类构造函数为参数
var Student = (function(_Person) {
    // 实现对父类原型链属性的继承
    _inherits(Student, _Person);

    // 将会返回这个函数作为完整的Student构造函数
    function Student() {
        // 使用检测
        _classCallCheck(this, Student);  
        // _get的返回值可以先理解为父类构造函数       
        _get(Object.getPrototypeOf(Student.prototype), &apos;constructor&apos;, this).call(this);
    }

    return Student;
})(Person);

// _x为Student.prototype.__proto__
// _x2为&apos;constructor&apos;
// _x3为this
var _get = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
        var object = _x,
            property = _x2,
            receiver = _x3;
        _again = false;
        // Student.prototype.__proto__为null的处理
        if (object === null) object = Function.prototype;
        // 以下是为了完整复制父类原型链上的属性，包括属性特性的描述符
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);
            if (parent === null) {
                return undefined;
            } else {
                _x = parent;
                _x2 = property;
                _x3 = receiver;
                _again = true;
                desc = parent = undefined;
                continue _function;
            }
        } else if (&apos;value&apos; in desc) {
            return desc.value;
        } else {
            var getter = desc.get;
            if (getter === undefined) {
                return undefined;
            }
            return getter.call(receiver);
        }
    }
};

function _inherits(subClass, superClass) {
    // superClass需要为函数类型，否则会报错
    if (typeof superClass !== &apos;function&apos; &amp;&amp; superClass !== null) {
        throw new TypeError(&apos;Super expression must either be null or a function, not &apos; + typeof superClass);
    }
    // Object.create第二个参数是为了修复子类的constructor
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    // Object.setPrototypeOf是否存在做了一个判断，否则使用__proto__
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
</code></pre><p>虽然我加上了注释，但是这一坨代码仍然看上去恶心极了！没关系，下面我们进行拆解，你很快就能明白。</p>
<p>Step3：抽丝剥茧<br>我们首先看Student的编译结果：</p>
<pre><code>var Student = (function(_Person) {
    _inherits(Student, _Person);

    function Student() {
        _classCallCheck(this, Student);            
        _get(Object.getPrototypeOf(Student.prototype), &apos;constructor&apos;, this).call(this);
    }

    return Student;
})(Person);
</code></pre><p>这是一个自执行函数，它接受一个参数Person（就是他要继承的父类），返回一个构造函数Student。</p>
<p>上面_inherits方法的本质其实就是让Student子类继承Person父类原型链上的方法。它实现原理可以归结为一句话：</p>
<pre><code>Student.prototype = Object.create(Person.prototype);
Object.setPrototypeOf(Student, Person)
</code></pre><p>注意，Object.create接收第二个参数，这就实现了对Student的constructor修复。<br>如果你不了解Object.create，那么<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">请参考这里。</a></p>
<p>以上通过_inherits实现了对父类原型链上属性的继承，那么对于父类的实例属性（就是constructor定义的属性）的继承，也可以归结为一句话：</p>
<pre><code>Person.call(this);
</code></pre><p>如果你还不理解使用call或者apply或者bind来改变JS中this的指向，那么请参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external">这篇文章。</a></p>
<p>这样，我们便透析了Babel编译这一切的秘密。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你看完这一系列的文章可能会有体会：我想灌输的肯定不是ES6新特性的使用，关于这些东西有太多的文章、博客、书籍去讨论。</p>
<p>我是在讲Babel对这些新特性的编译产出，那为什么我会在乎这些呢？<br>其实通过分析，我们悄然回顾了JS中很多重点以及难点，还包括程序设计上的一些小思想。<br>最近面试了很多前端“新同学”：有的人痴迷于框架，可以使用React或者Vue比照tutorial做出页面炫酷的交互，甚至自觉SPA也不在话下；<br>有的人ES6、ES7了解很多，generator，async都能说出一二，仿佛Promise处理异步已经成为了“时代弃儿”。<br>可是同样是这些人，对原型原型链、this、作用域、闭包都没有深刻地理解和掌握。<br>同样是这些页面，即便用callback处理异步回调，嵌套最多也不到两层。</p>
<p>也许，同样一批人也会问：“我能用前端框架、ES6撸出好多页面，可是为什么感觉进步很慢处于瓶颈中、面试也总被挂呢？”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你已经看过第一篇&lt;a href=&quot;http://www.jianshu.com/p/d36fb31f9cff&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;揭秘babel的魔法之class魔法处理&lt;/a&gt;，这篇将会是一个延伸；&lt;br&gt;如果你还没看过，并
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>深入新版BS4源码 探索flex和工程化sass奥秘</title>
    <link href="https://exp-team.github.io/blog/2017/01/12/program/BS4/"/>
    <id>https://exp-team.github.io/blog/2017/01/12/program/BS4/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-02-19T12:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>你可能已经听说了一个“大新闻”：Bootstrap4 合并了代号为#21389的PR，宣布<a href="https://github.com/twbs/bootstrap/pull/21389" target="_blank" rel="external">放弃支持IE9，并默认使用flexbox弹性盒模型</a>。<br>这标志着前端开发全面步入“现代浏览器”的时代进一步来临；样式处理也再一次面向未来，拥抱更加灵活的弹性盒模型－Flex布局。</p>
<p>这篇文章会带你深入Bootstrap最新版源码，窥探其架构组织奥秘，并解析最具亮点的栅格化系统。<br>你也会了解到sass的高阶用法和flex最新语法奥秘。</p>
<h2 id="BS4的新特性"><a href="#BS4的新特性" class="headerlink" title="BS4的新特性"></a>BS4的新特性</h2><p>在开启我们的探索之前，有必要先梳理一下BS4添加的新特性：<br>1）从Less迁移到Sass：<br>现在，Bootstrap已加入Sass的大家庭中。得益于Libsass（Sass 解析器），Bootstrap的编译速度比以前更快；<br>2）改进网格系统：<br>新增一个网格层适配移动设备，并整顿语义混合。<br>3）默认弹性盒模型（flexbox）：<br>这是项划时代的变动，利用flexbox的优势快速布局。<br>4）废弃了wells、thumbnails和panels，使用cards代替。<br>5）新的自定义选项：<br>不再像上个版本一样，将渐变、淡入淡出、阴影等效果分放在单独的样式表中。而是将所有选项都移到一个Sass变量中。<br>想要给全局或考虑不到的角落定义一个默认效果？很简单，只要更新变量值，然后重新编译就可以了。<br>6）使用rem和em单位。<br>7）重构所有JavaScript插件：<br>Bootstrap 4用ES6重写了所有插件。现在提供UMD支持、泛型拆解方法、选项类型检查等特性。<br>8）改进工具提示和popovers自动定位：<br>这部分要感谢Tether（A positioning engine to make overlays, tooltips and dropdowns better）工具的帮助，<br>如果你还不知道Tether是什么，可以去他家<a href="https://github.com/HubSpot/tether" target="_blank" rel="external">Github地址</a>。</p>
<h2 id="BS4栅格系统揭秘"><a href="#BS4栅格系统揭秘" class="headerlink" title="BS4栅格系统揭秘"></a>BS4栅格系统揭秘</h2><p>了解了以上新特性，我们主要研究BS从诞生以来最大的“卖点”－栅格系统。</p>
<h2 id="一个栅格实例"><a href="#一个栅格实例" class="headerlink" title="一个栅格实例"></a>一个栅格实例</h2><p>我们选取代表性的BS4官网范例，可以<a href="http://v4.bootcss.com/examples/dashboard/#" target="_blank" rel="external">在线参考</a>, 或者参看以下截图，<br>在大屏幕下，我们看到：</p>
<p>当屏幕宽度小于576px时候，我们有：</p>
<p>对应代码：</p>
<pre><code>&lt;div class=&quot;col-6 col-sm-3&quot;&gt;
    ...
&lt;/div&gt;
&lt;div class=&quot;col-6 col-sm-3&quot;&gt;
    ...
&lt;/div&gt;
&lt;div class=&quot;col-6 col-sm-3&quot;&gt;
    ...
&lt;/div&gt;
&lt;div class=&quot;col-6 col-sm-3&quot;&gt;
    ...
&lt;/div&gt;
</code></pre><p>.col-6 class样式在源码里面可以简单归纳（不完全）为：</p>
<pre><code>.col-6 {
    -webkit-box-flex: 0;
    -webkit-flex: 0 0 50%;
    -ms-flex: 0 0 50%;
    flex: 0 0 50%;
    max-width: 50%;
}
</code></pre><p>.col-sm-3 class在源码里面可以归纳为：</p>
<pre><code>.col-sm-3{
    -webkit-box-flex: 0;
    -webkit-flex: 0 0 25%;
        -ms-flex: 0 0 25%;
            flex: 0 0 25%;
    max-width: 25%;
}
</code></pre><h3 id="两种类的共存和交替作用"><a href="#两种类的共存和交替作用" class="headerlink" title="两种类的共存和交替作用"></a>两种类的共存和交替作用</h3><p>我们看到，代码里设置了这两个class进行样式声明，很明显他们的样式属性是有冲突的，那么他们是如何做到“和平共处”交替发挥作用的呢？</p>
<p>1）在屏幕宽度大于576px时候，我们发现.col-sm-3并没有起作用，这时候起作用的是.col-6。<br>我们在源码里发现.col-sm-<em>的样式声明全部在@media (min-width: 576px) {…}的媒体查询中，<br>这就保证了在576px宽度以上的屏幕，只有在媒体查询之外的.col-</em>样式声明发挥了作用。</p>
<p>2）在屏幕宽度小于576px时候，命中媒体查询，命中.col-sm-3的样式声明。他的优先级一定大于.col-6（媒体查询优先级高），这时候就保证了移动端的样式“占上风”。</p>
<h3 id="flex讲解"><a href="#flex讲解" class="headerlink" title="flex讲解"></a>flex讲解</h3><p>我们从样式代码里看到类似flex: 0 0 25%的声明，为了理解它，我们从flex属性入手：<br>flex属性是flex-grow, flex-shrink 和 flex-basis的简写（类似backgroud是很多背景属性的简写一样），<br>它的默认值为0 1 auto。后两个属性可选。语法格式如下：</p>
<pre><code>.item {
    flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]
}
</code></pre><p>1）flex-grow：属性定义项目的放大比例，默认为0。我们看到BS代码里这个值一直为0，即如果存在剩余空间，也不放大。</p>
<p>2）flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p>3）flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。<br>浏览器根据这个属性，计算主轴是否有多余空间。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。<br>当然BS4这里设置为比例值，这也是响应式自然而然实现的基础。</p>
<h2 id="SASS在BS4工程化中的伟大作用"><a href="#SASS在BS4工程化中的伟大作用" class="headerlink" title="SASS在BS4工程化中的伟大作用"></a>SASS在BS4工程化中的伟大作用</h2><p>看到此，不难明白BS4栅格的实现，但是这并不是此文的最终目的。我们可以深入更多，比如，BS4的栅格系统里，一行一共是12栏。他的媒体查询断点又包括：xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px。<br>参考其源码dist/css目录下样式代码，我们会想组织生成如此大量的CSS样式，不用预处理器简直是反人类的。而BS4却是把sass用到了极致。</p>
<h3 id="col-sm-是如何生成的"><a href="#col-sm-是如何生成的" class="headerlink" title=".col-sm-*是如何生成的"></a>.col-sm-*是如何生成的</h3><p>我们深入其scss目录下，scss/mixins/_grid.scss文件：</p>
<pre><code>@if $enable-grid-classes {
    @include make-grid-columns();
}
</code></pre><p>在enable-grid-classes变量为true的情况下（默认为true），调用make-grid-columns()</p>
<p>make-grid-columns()这个mixin定义在scss/mixins/_grid-reamework.scss文件中（找的我好心累。。。）：</p>
<pre><code>@mixin make-grid-columns($columns: $grid-columns, $gutters: $grid-gutter-widths, $breakpoints: $grid-breakpoints) {
    ...
}
</code></pre><p>这个mixin接受三个参数：<br>1）$columns表示栅格数目默认为12<br>2）$gutters默认为30<br>3）$breakpoints表示断点设置，这是一个全局变量，为map类型。<br>这些你可以在scss/mixins/_breakpoints.scss文件中和scss/_variables.scss文件中找到。</p>
<p>认识了这些参数，我们看.col-sm-<em>具体实现，下面代码我已经进行过大范围精简，只保留col-sm-</em>相关部分，并且加了注释：</p>
<pre><code>@each $breakpoint in map-keys($breakpoints) {
    // Returns a blank string if smallest breakpoint, otherwise returns the name with a dash infront.
    $infix: breakpoint-infix($breakpoint, $breakpoints);
    // Media of at least the minimum breakpoint width. No query for the smallest breakpoint.
    // Makes the @content apply to the given breakpoint and wider.
    @include media-breakpoint-up($breakpoint, $breakpoints) {
        @for $i from 1 through $columns {
            .col#{$infix}-#{$i} {
                @include make-col($i, $columns);
            }
        }
    }
}
</code></pre><p>我们一步一步来分析：<br>1）@each $breakpoint in map-keys($breakpoints)，对每一个断点进行遍历；<br>2）breakpoint-infix是一个函数，它定义在css/mixins/_breakpoints.scss文件当中， 返回一个带破折号的断点标识字符串，比如这里我们关系的就是“-sm”；<br>3）media-breakpoint-up是一个mixin：</p>
<pre><code>@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {
    $min: breakpoint-min($name, $breakpoints);
    @if $min {
        @media (min-width: $min) {
        @content;
    }
    } @else {
        @content;
    }
}
</code></pre><p>4）breakpoint-min又是一个函数，它返回了断点的具体数值。这里是用来拼媒体查询条件的。<br>5）最后最关键样式的生成又使用了另外一个定义在css/mixins/_grid.scss文件当中的mixin:</p>
<pre><code>@mixin make-col($size, $columns: $grid-columns) {
    flex: 0 0 percentage($size / $columns);
    max-width: percentage($size / $columns);
}
</code></pre><p>到此为止，我们深入了Bootstrap V4的scss/目录下的源码，研究涉及了：<br>css/mixins/_grid-framework.scss文件;<br>css/mixins/_breakpoints.scss文件;<br>css/mixins/_grid.scss文件;<br>css/_variables.scss文件;<br>css/bootstrap-gris.scss文件;<br>……</p>
<p>如果你理解了这些，那么再去读bootstrap新版源码就不会存在任何难度。相信你也能够在全局上，以“上帝视角”了解sass所起的作用，大型样式框架的架构组织。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读源码的栅格系统部分，我们应该认识到sass对于这样大型样式框架系统的重要意义：<br>1）css模块化在管理组织上的灵活性；<br>2）复用的意义，我们使用了大量的mixin,function,全局变量；<br>3）像JS一样神奇的语法，包括条件、遍历等等等等。<br>我们也应该对flex这一神器有了更加深刻的认识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可能已经听说了一个“大新闻”：Bootstrap4 合并了代号为#21389的PR，宣布&lt;a href=&quot;https://github.com/twbs/bootstrap/pull/21389&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;放弃支持IE
    
    </summary>
    
      <category term="program" scheme="https://exp-team.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://exp-team.github.io/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>揭秘babel的魔法之class魔法处理</title>
    <link href="https://exp-team.github.io/blog/2017/01/12/program/babel-class/"/>
    <id>https://exp-team.github.io/blog/2017/01/12/program/babel-class/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-01-15T12:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年，很多人已经开始接触ES6环境，并且早已经用在了生产当中。我们知道ES6在大部分浏览器还是跑不通的，因此我们使用了伟大的Babel来进行编译。很多人可能没有关心过，经过Babel编译之后，我们华丽的ES6代码究竟变成了什么样子？</p>
<p>这篇文章，针对Babel对ES6里面“类class”的编译进行分析，你可以在线<a href="https://babeljs.io/repl/" target="_blank" rel="external">测试编译结果</a>，毕竟纸上得来终觉浅，自己动手，才能真正体会其中的奥秘。</p>
<p>另外，如果你还不明白JS中原型链等OOP相关知识，建议出门左转找到经典的《JS高级程序设计》来补课；如果你对JS中，通过原型链来实现继承一直云里雾里，安利一下我的同事，前端著名网红<a href="http://yanhaijing.com/javascript/2014/11/09/object-inherit-of-js/" target="_blank" rel="external">颜海镜大大早在2014年的文章</a></p>
<a id="more"></a>
<h2 id="为什么使用选择Babel"><a href="#为什么使用选择Babel" class="headerlink" title="为什么使用选择Babel"></a>为什么使用选择Babel</h2><p>Babel：The compiler for writing next generation JavaScript；<br>我们知道，现在大部分浏览器或者类似NodeJS的javascript引擎还不能直接支持ES6语法。但这并不构成障碍，比如Babel的出现，使得我们在生产环境中书写ES6代码成为了现实，它工作原理是编译ES6的新特性为老版本的ES5，从而得到宿主环境的支持。</p>
<h2 id="Class例子"><a href="#Class例子" class="headerlink" title="Class例子"></a>Class例子</h2><p>在这篇文章中，我会讲解Babel如何处理ES6新特性：Class，这其实是一系列语法糖的实现。</p>
<h3 id="Old-school方式实现继承"><a href="#Old-school方式实现继承" class="headerlink" title="Old school方式实现继承"></a>Old school方式实现继承</h3><p>在探究ES6之前，我们先来回顾一下ES5环境下，我们如何实现类的继承：</p>
<pre><code>// Person是一个构造器
function Person(name) {
    this.type = &apos;Person&apos;;
    this.name = name;
}

// 我们可以通过prototype的方式来加一条实例方法
Person.prototype.hello = function() {
    console.log(&apos;hello &apos; + this.name);
}

// 对于私有属性(Static method)，我们当然不能放在原型链上了。我们可以直接放在构造函数上面
Person.fn = function() {
    console.log(&apos;static&apos;);
};
</code></pre><p>我们可以这么应用：</p>
<pre><code>var julien = new Person(&apos;julien&apos;);
var darul = new Person(&apos;darul&apos;);
julien.hello(); // &apos;hello julien&apos;
darul.hello(); // &apos;hello darul&apos;
Person.fn(); // &apos;static&apos;

// 这样会报错，因为fn是一个私有属性
julien.fn(); //Uncaught TypeError: julien.fn is not a function
</code></pre><h3 id="New-school方式-ES6-实现继承"><a href="#New-school方式-ES6-实现继承" class="headerlink" title="New school方式(ES6)实现继承"></a>New school方式(ES6)实现继承</h3><p>在ES6环境下，我们当然迫不及待地试一试Class：</p>
<pre><code>class Person {
    constructor(name) {
        this.name = name;
        this.type=&quot;person&quot;
    }
    hello() {
        console.log(&apos;hello &apos; + this.name);
    }
    static fn() {
        console.log(&apos;static&apos;);
    };
}
</code></pre><p>这样写起来当然很cool，但是经过Babel编译，我们的代码是什么样呢？</p>
<h3 id="Babel-transformation"><a href="#Babel-transformation" class="headerlink" title="Babel transformation"></a>Babel transformation</h3><p>我们一步一步来看，</p>
<p>Step1: 定义<br>我们从最简单开始，试试不加任何方法和属性的情况下，</p>
<pre><code>Class Person{}
</code></pre><p>被编译为：</p>
<pre><code>function _classCallCheck(instance, Constructor) {
    // 检查是否成功创建了一个对象
    if (!(instance instanceof Constructor)) {  
        throw new TypeError(&quot;Cannot call a class as a function&quot;); 
    } 
}

var Person = function Person() {
    _classCallCheck(this, Person);
};
</code></pre><p>你可能会一头雾水,_classCallCheck是什么？其实很简单，它是为了保证调用的安全性。<br>比如我们这么调用：</p>
<pre><code>// ok
var p = new Person();
</code></pre><p>是没有问题的，但是直接调用：</p>
<pre><code>// Uncaught TypeError: Cannot call a class as a function
Person();
</code></pre><p>就会报错，这就是_classCallCheck所起的作用。具体原理自己看代码就好了，很好理解。</p>
<p>我们发现，Class关键字会被编译成构造函数，于是我们便可以通过new来实现实例的生成。</p>
<p>Step2：Constructor探秘<br>我们这次尝试加入constructor,再来看看编译结果：</p>
<pre><code>class Person() {
    constructor(name) {  
        this.name = name;
        this.type = &apos;person&apos;
    }
}
</code></pre><p>编译结果：</p>
<pre><code>var Person = function Person(name) {
    _classCallCheck(this, Person);
    this.type = &apos;person&apos;;
    this.name = name;
};
</code></pre><p>看上去棒极了，我们继续探索。</p>
<p>Step3：增加方法<br>我们尝试给Person类添加一个方法：hello：</p>
<pre><code>class Person {
    constructor(name) {
        this.name = name;
        this.type = &apos;person&apos;
    }

    hello() {
        console.log(&apos;hello &apos; + this.name);
    }
}
</code></pre><p>编译结果(已做适当省略)：</p>
<pre><code>// 如上，已经解释过
function _classCallCheck.... 

// MAIN FUNCTION
var _createClass = (function () { 
    function defineProperties(target, props) { 
        for (var i = 0; i &lt; props.length; i++) { 
            var descriptor = props[i]; 
            descriptor.enumerable = descriptor.enumerable || false; 
            descriptor.configurable = true; 
            if (&apos;value&apos; in descriptor) 
            descriptor.writable = true; 
            Object.defineProperty(target, descriptor.key, descriptor); 
        } 
    } 
    return function (Constructor, protoProps, staticProps) { 
        if (protoProps) 
            defineProperties(Constructor.prototype, protoProps); 
        if (staticProps) 
            defineProperties(Constructor, staticProps); 
        return Constructor; 
    }; 
})();

var Person = (function () {
    function Person(name) {
        _classCallCheck(this, Person);

        this.name = name;
    }

    _createClass(Person, [{
        key: &apos;hello&apos;,
        value: function hello() {
            console.log(&apos;hello &apos; + this.name);
        }
    }]);

    return Person;
})();
</code></pre><p>Oh…no,看上去有很多需要消化!不要急，我尝试先把他精简一下，并加上注释，你就会明白核心思路：</p>
<pre><code>var _createClass = (function () {   
    function defineProperties(target, props) { 
        // 对于每一个定义的属性props，都要完全拷贝它的descriptor,并扩展到target上
    }  
    return defineProperties(Constructor.prototype, protoProps);    
})();

var Person = (function () {
    function Person(name) { // 同之前... }

    _createClass(Person, [{
        key: &apos;hello&apos;,
        value: function hello() {
            console.log(&apos;hello &apos; + this.name);
        }
    }]);

    return Person;
})();
</code></pre><p>如果你不明白defineProperty方法, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">请参考这里</a></p>
<p>现在，我们知道我们添加的方法：</p>
<pre><code>hello() {
    console.log(&apos;hello &apos; + this.name);
}
</code></pre><p>被编译为：</p>
<pre><code>_createClass(
    Person, [{
    key: &apos;hello&apos;,
    value: function hello() {
        console.log(&apos;hello &apos; + this.name);
    }
}]);
</code></pre><p>而_createClass接受2个－3个参数，分别表示：</p>
<pre><code>参数1 =&gt; 我们要扩展属性的目标对象，这里其实就是我们的Person
参数2 =&gt; 需要在目标对象原型链上添加的属性，这是一个数组
参数3 =&gt; 需要在目标对象上添加的属性，这是一个数组
</code></pre><p>这样，Babel的魔法就一步一步被揭穿了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望这篇文章能够让你了解到Babel是如何初步把我们ES6 Class语法编译成ES5的。下一篇文章我会继续介绍Babel如何处理子类的Super(), 并会通过一段函数桥梁，使得ES5环境下也能够继承ES6定义的Class。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年，很多人已经开始接触ES6环境，并且早已经用在了生产当中。我们知道ES6在大部分浏览器还是跑不通的，因此我们使用了伟大的Babel来进行编译。很多人可能没有关心过，经过Babel编译之后，我们华丽的ES6代码究竟变成了什么样子？&lt;/p&gt;
&lt;p&gt;这篇文章，针对Babel对ES6里面“类class”的编译进行分析，你可以在线&lt;a href=&quot;https://babeljs.io/repl/&quot;&gt;测试编译结果&lt;/a&gt;，毕竟纸上得来终觉浅，自己动手，才能真正体会其中的奥秘。&lt;/p&gt;
&lt;p&gt;另外，如果你还不明白JS中原型链等OOP相关知识，建议出门左转找到经典的《JS高级程序设计》来补课；如果你对JS中，通过原型链来实现继承一直云里雾里，安利一下我的同事，前端著名网红&lt;a href=&quot;http://yanhaijing.com/javascript/2014/11/09/object-inherit-of-js/&quot;&gt;颜海镜大大早在2014年的文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="program" scheme="https://exp-team.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://exp-team.github.io/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10011期</title>
    <link href="https://exp-team.github.io/blog/2017/01/07/weekly/weekly-10011/"/>
    <id>https://exp-team.github.io/blog/2017/01/07/weekly/weekly-10011/</id>
    <published>2017-01-06T16:00:00.000Z</published>
    <updated>2017-01-13T10:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.1-1.7，2017年的第一期，美好的事情即将发生，翘首期待。</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="2016年javascript回顾"><a href="#2016年javascript回顾" class="headerlink" title="2016年javascript回顾"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651224793&amp;idx=1&amp;sn=68ae9a4b327ac26d141484392afa52ac&amp;chksm=bd49a35d8a3e2a4bac8fac53163bad6526ee2824f77e5491cbbf6010eb98cf545956bc5367b3&amp;mpshare=1&amp;scene=1&amp;srcid=0106gQOA9sJ99tDSaTQzGVOA#rd" target="_blank" rel="external">2016年javascript回顾</a></h3><p>又是一篇非常好的导读文章，本文仅仅是16年js的导读文章，17年值得期待。</p>
<h3 id="JavaScript-全栈工程师培训教程"><a href="#JavaScript-全栈工程师培训教程" class="headerlink" title="JavaScript 全栈工程师培训教程"></a><a href="http://www.ruanyifeng.com/blog/2016/11/javascript.html" target="_blank" rel="external">JavaScript 全栈工程师培训教程</a></h3><p>阮一峰老师的又一大作，本文重在理解各种技术想要解决的问题，掌握基本用法，为进一步自学打下基础。</p>
<h3 id="JavaScript模块化编程简史（2009-2016）"><a href="#JavaScript模块化编程简史（2009-2016）" class="headerlink" title="JavaScript模块化编程简史（2009-2016）"></a><a href="http://mp.weixin.qq.com/s/Z8bG125LvKJFIpF8w3efRg" target="_blank" rel="external">JavaScript模块化编程简史（2009-2016）</a></h3><p>@余果 整理的js模块发展史，如果你搞不懂AMD,CMD,UMD,commonjs那就来看看这篇文章吧。</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="如何写好-JavaScript-的函数？没那么简单！"><a href="#如何写好-JavaScript-的函数？没那么简单！" class="headerlink" title="如何写好 JavaScript 的函数？没那么简单！"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964169&amp;idx=1&amp;sn=bc46bd908a439dad80ee19b796eb8fe7&amp;chksm=843aecafb34d65b9fdb0d6c379faf0cf80872fe4dea097b0b7de898f378f22da6aae70dd49ab&amp;mpshare=1&amp;scene=1&amp;srcid=0105fgcdjqeGJs4cCmQhP0r8#rd" target="_blank" rel="external">如何写好 JavaScript 的函数？没那么简单！</a></h3><p>没有最好的选择，只有最适合的，来看看这篇文章对参数的诠释吧，很小的一个点，却饱含了很多哲学。</p>
<h3 id="在-2017-年如何成为一名更好的-Node-js-开发者"><a href="#在-2017-年如何成为一名更好的-Node-js-开发者" class="headerlink" title="在 2017 年如何成为一名更好的 Node.js 开发者"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964152&amp;idx=1&amp;sn=c16caec1507ee0d6f97e14169c6fe697&amp;chksm=843aecdeb34d65c8d8fb0b1d1691125501972e790ce7a191037495f003ee9eed2756f20634c7&amp;mpshare=1&amp;scene=1&amp;srcid=0104Cyk96Ol4lpv3AiHFq3Md#rd" target="_blank" rel="external">在 2017 年如何成为一名更好的 Node.js 开发者</a></h3><h3 id="月薪三万与月薪三千的区别-——-浅谈-API-设计"><a href="#月薪三万与月薪三千的区别-——-浅谈-API-设计" class="headerlink" title="月薪三万与月薪三千的区别 —— 浅谈 API 设计"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964146&amp;idx=1&amp;sn=6ca5de478d3c9c4a700a9ef281ee505d&amp;chksm=843aecd4b34d65c276da8566f2cfa57c43123a287013f59c07f61de0bd2c99556f2b1828aae6&amp;mpshare=1&amp;scene=1&amp;srcid=01035xFI3xqOddQHKYEUIt6K#rd" target="_blank" rel="external">月薪三万与月薪三千的区别 —— 浅谈 API 设计</a></h3><p>本文看起来就是微博上的红绿灯大战哈，来看看一段代码是怎么进化和演进的。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="Browserscope"><a href="#Browserscope" class="headerlink" title="Browserscope"></a><a href="http://www.browserscope.org/" target="_blank" rel="external">Browserscope</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.1-1.7，2017年的第一期，美好的事情即将发生，翘首期待。&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;2016年javascript回顾&quot;&gt;&lt;a href=&quot;#2016年javascript回顾&quot; class=&quot;headerlink&quot; title=&quot;2016年javascript回顾&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651224793&amp;amp;idx=1&amp;amp;sn=68ae9a4b327ac26d141484392afa52ac&amp;amp;chksm=bd49a35d8a3e2a4bac8fac53163bad6526ee2824f77e5491cbbf6010eb98cf545956bc5367b3&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0106gQOA9sJ99tDSaTQzGVOA#rd&quot;&gt;2016年javascript回顾&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;又是一篇非常好的导读文章，本文仅仅是16年js的导读文章，17年值得期待。&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-全栈工程师培训教程&quot;&gt;&lt;a href=&quot;#JavaScript-全栈工程师培训教程&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 全栈工程师培训教程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/11/javascript.html&quot;&gt;JavaScript 全栈工程师培训教程&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;阮一峰老师的又一大作，本文重在理解各种技术想要解决的问题，掌握基本用法，为进一步自学打下基础。&lt;/p&gt;
&lt;h3 id=&quot;JavaScript模块化编程简史（2009-2016）&quot;&gt;&lt;a href=&quot;#JavaScript模块化编程简史（2009-2016）&quot; class=&quot;headerlink&quot; title=&quot;JavaScript模块化编程简史（2009-2016）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/Z8bG125LvKJFIpF8w3efRg&quot;&gt;JavaScript模块化编程简史（2009-2016）&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;@余果 整理的js模块发展史，如果你搞不懂AMD,CMD,UMD,commonjs那就来看看这篇文章吧。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10010期</title>
    <link href="https://exp-team.github.io/blog/2016/12/31/weekly/weekly-10010/"/>
    <id>https://exp-team.github.io/blog/2016/12/31/weekly/weekly-10010/</id>
    <published>2016-12-30T16:00:00.000Z</published>
    <updated>2017-01-13T08:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>12.26-12.31，2016年最后一期了，2016你有什么后悔的事吗？2017你有什么想去做的事吗？欢迎在评论区留言。</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="2016，你有什么后悔的事吗？"><a href="#2016，你有什么后悔的事吗？" class="headerlink" title="2016，你有什么后悔的事吗？"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712946&amp;idx=1&amp;sn=b34c2783ebda8a16722d18d5cc542adc&amp;chksm=bec0652189b7ec377b7da8b7e5baffc1f9c535f6ed4178cf88b6eb5b1cde21a3212c73c7668a&amp;mpshare=1&amp;scene=1&amp;srcid=1228MrSq7al4EQSvvud9dZad#rd" target="_blank" rel="external">2016，你有什么后悔的事吗？</a></h3><p>欢迎大家在评论区留言讨论。</p>
<h3 id="2016前端开发技术巡礼"><a href="#2016前端开发技术巡礼" class="headerlink" title="2016前端开发技术巡礼"></a><a href="http://www.infoq.com/cn/articles/2016-review-frontend" target="_blank" rel="external">2016前端开发技术巡礼</a></h3><p>本文才算是真正的16年前端总结，蜻蜓点水的提到了各种前端新技术，看得人热血沸腾，感叹技术发展太快了。</p>
<h3 id="张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）"><a href="#张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）" class="headerlink" title="张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTE4Njc4NQ==&amp;mid=2657611912&amp;idx=1&amp;sn=f91c228764f9a3b4ed696276fae1ee1b&amp;chksm=bd6f01868a188890c72c32e3082f2bc36d7f79efab345a9a58595a4a19c9fa39f522e9981b2d&amp;mpshare=1&amp;scene=1&amp;srcid=1228p1Ap3ZKbPl1Lwsajn0Cy#rd" target="_blank" rel="external">张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）</a></h3><p>小程序在微信没有入口，没有流量，小程序的入口在无处无在的二维码，这终将是一个伟大的平台。</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="为什么总有人黑-JavaScript？"><a href="#为什么总有人黑-JavaScript？" class="headerlink" title="为什么总有人黑 JavaScript？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651551609&amp;idx=1&amp;sn=7396635dddfb6ebe6949aa2ee8b38132&amp;chksm=8025a0b8b75229aef34f72ec0c5fed8ccc46a0553e4002b395485e8db89213e84aa52c6d0df3&amp;mpshare=1&amp;scene=1&amp;srcid=1230e73LuUspDg41MwU0OaKY#rd" target="_blank" rel="external">为什么总有人黑 JavaScript？</a></h3><p>因为火呗，用的人多才会有人黑，不过每一门语言都不是完美的，js作为领域语言，肯定是有一些槽点的。</p>
<h3 id="ES6-新特性汇总（一图全览）"><a href="#ES6-新特性汇总（一图全览）" class="headerlink" title="ES6 新特性汇总（一图全览）"></a><a href="https://zhuanlan.zhihu.com/p/24570791" target="_blank" rel="external">ES6 新特性汇总（一图全览）</a></h3><h3 id="为什么这样也能运行-concat-1-2-3"><a href="#为什么这样也能运行-concat-1-2-3" class="headerlink" title="为什么这样也能运行? [ ].concat[1,2,3]"></a><a href="http://mp.weixin.qq.com/s?__biz=MzI0NTAyNjE0NQ==&amp;mid=2675577402&amp;idx=1&amp;sn=ca14e15fc6255f133fcf48fd6cd5f64f&amp;chksm=f3da6e34c4ade722e5b81ca75ffcf899e7d82c16add6510cf164de5dc0f6c0916dbe8c5d5628&amp;mpshare=1&amp;scene=1&amp;srcid=1227FMaDJKLPEhwS0b4ZEywu#rd" target="_blank" rel="external">为什么这样也能运行? [ ].concat[1,2,3]</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="我的效率工具箱"><a href="#我的效率工具箱" class="headerlink" title="我的效率工具箱"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxODE1MDYwMQ==&amp;mid=2650898818&amp;idx=1&amp;sn=9ad15d6a89fd7ac39887d2abc86fefb6&amp;chksm=802f8424b7580d323d78b3853dbf9d7bc5ed90cd951c7cae28fae18b460b22e87c5f54e1fcb5&amp;mpshare=1&amp;scene=1&amp;srcid=1227ezYVN9AGExsE4uYYOnPr#rd" target="_blank" rel="external">我的效率工具箱</a></h3><p>工欲善其事必先利其器，也欢迎大家积极分享自己的工具。</p>
<h3 id="前端疲劳"><a href="#前端疲劳" class="headerlink" title="前端疲劳"></a><a href="http://www.jianshu.com/p/a2eff3d721cb" target="_blank" rel="external">前端疲劳</a></h3><p>看完上面的2016前端开发技术巡礼，你一定会感叹前端的繁荣，或者如果你是一个关注新技术的前端，一定会有疲劳的感觉，那不妨看看这篇文章，也许对你有帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;12.26-12.31，2016年最后一期了，2016你有什么后悔的事吗？2017你有什么想去做的事吗？欢迎在评论区留言。&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;2016，你有什么后悔的事吗？&quot;&gt;&lt;a href=&quot;#2016，你有什么后悔的事吗？&quot; class=&quot;headerlink&quot; title=&quot;2016，你有什么后悔的事吗？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650712946&amp;amp;idx=1&amp;amp;sn=b34c2783ebda8a16722d18d5cc542adc&amp;amp;chksm=bec0652189b7ec377b7da8b7e5baffc1f9c535f6ed4178cf88b6eb5b1cde21a3212c73c7668a&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1228MrSq7al4EQSvvud9dZad#rd&quot;&gt;2016，你有什么后悔的事吗？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;欢迎大家在评论区留言讨论。&lt;/p&gt;
&lt;h3 id=&quot;2016前端开发技术巡礼&quot;&gt;&lt;a href=&quot;#2016前端开发技术巡礼&quot; class=&quot;headerlink&quot; title=&quot;2016前端开发技术巡礼&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/2016-review-frontend&quot;&gt;2016前端开发技术巡礼&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;本文才算是真正的16年前端总结，蜻蜓点水的提到了各种前端新技术，看得人热血沸腾，感叹技术发展太快了。&lt;/p&gt;
&lt;h3 id=&quot;张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）&quot;&gt;&lt;a href=&quot;#张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）&quot; class=&quot;headerlink&quot; title=&quot;张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NTE4Njc4NQ==&amp;amp;mid=2657611912&amp;amp;idx=1&amp;amp;sn=f91c228764f9a3b4ed696276fae1ee1b&amp;amp;chksm=bd6f01868a188890c72c32e3082f2bc36d7f79efab345a9a58595a4a19c9fa39f522e9981b2d&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1228p1Ap3ZKbPl1Lwsajn0Cy#rd&quot;&gt;张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;小程序在微信没有入口，没有流量，小程序的入口在无处无在的二维码，这终将是一个伟大的平台。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10001期</title>
    <link href="https://exp-team.github.io/blog/2016/12/24/weekly/weekly-10001/"/>
    <id>https://exp-team.github.io/blog/2016/12/24/weekly/weekly-10001/</id>
    <published>2016-12-23T16:00:00.000Z</published>
    <updated>2017-01-13T08:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>12.18-12.24，本期的主题是你认为你的核心竞争力在哪？。</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="若你已做多年前端（5年-），你觉得你目前的核心竞争力在哪？"><a href="#若你已做多年前端（5年-），你觉得你目前的核心竞争力在哪？" class="headerlink" title="若你已做多年前端（5年+），你觉得你目前的核心竞争力在哪？"></a><a href="https://www.zhihu.com/question/53542412/answer/137031732?utm_source=wechat_timeline&amp;utm_medium=social&amp;from=groupmessage&amp;isappinstalled=0" target="_blank" rel="external">若你已做多年前端（5年+），你觉得你目前的核心竞争力在哪？</a></h3><p>我觉得大概在知识，经验，软素质等方面。</p>
<h3 id="不管你在哪里上班，至少记住这个字！"><a href="#不管你在哪里上班，至少记住这个字！" class="headerlink" title="不管你在哪里上班，至少记住这个字！"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTU0NDA4Nw==&amp;mid=2655455671&amp;idx=1&amp;sn=ee93cea6da065486ebdd5b5f42004511&amp;chksm=bc8a7dcf8bfdf4d9b4eda79b07a76c5f3be24636a6622100ed5407cce51c2b85c44c7be6a8b0&amp;mpshare=1&amp;scene=1&amp;srcid=1220ANjVrdaoTRU3L9m99ql8#rd" target="_blank" rel="external">不管你在哪里上班，至少记住这个字！</a></h3><p>你也许认为本文是鸡汤文，但我不这么认为，我其实很希望自己能早点看到这篇文章，不管你做什么工作，如果你做到本文提到的点，那你应该不会太差。</p>
<h3 id="React-组件间通讯"><a href="#React-组件间通讯" class="headerlink" title="React 组件间通讯"></a><a href="http://taobaofed.org/blog/2016/11/17/react-components-communication/" target="_blank" rel="external">React 组件间通讯</a></h3><p>最近面试了很多人，发现能把这个问题讲清楚的，真没有几个人。。。很尴尬。实在不能想象是怎么用react做东西的。</p>
<a id="more"></a>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="构建稳固的、可升缩的CSS框架的八大原则"><a href="#构建稳固的、可升缩的CSS框架的八大原则" class="headerlink" title="构建稳固的、可升缩的CSS框架的八大原则"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651224670&amp;idx=1&amp;sn=e16a0b2da4b9a3f9bb55fcd5fe603e70&amp;chksm=bd49a3da8a3e2acca118d85fb0fa88faf78e96cc0f08453ae6c23121f0fc026fad0683455e27&amp;mpshare=1&amp;scene=1&amp;srcid=1223bBlXwr3WWFNjdQsaSIGh#rd" target="_blank" rel="external">构建稳固的、可升缩的CSS框架的八大原则</a></h3><h3 id="移动前端自适应解决方案和比较"><a href="#移动前端自适应解决方案和比较" class="headerlink" title="移动前端自适应解决方案和比较"></a><a href="http://caibaojian.com/mobile-responsive-example.html" target="_blank" rel="external">移动前端自适应解决方案和比较</a></h3><p>其实大部分文章对rem布局的原理介绍都够详细，只是告诉大家就是这么算，而没讲清楚原理，其实rem布局的原理是百分比，后面我会写一篇博文来介绍这个。</p>
<h3 id="移动端页面开发适配-rem布局原理"><a href="#移动端页面开发适配-rem布局原理" class="headerlink" title="移动端页面开发适配 rem布局原理"></a><a href="https://segmentfault.com/a/1190000007526917" target="_blank" rel="external">移动端页面开发适配 rem布局原理</a></h3><h3 id="CSS技巧——rgba函数的妙用"><a href="#CSS技巧——rgba函数的妙用" class="headerlink" title="CSS技巧——rgba函数的妙用"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964048&amp;idx=1&amp;sn=4aa86d29933d97712fc5d0e9759c6d1e&amp;chksm=843aec36b34d652035357816d5a7b915cb0edf4f10bbe66297a263ed0111de5b422f4c88f29f&amp;mpshare=1&amp;scene=1&amp;srcid=1220EgDbzJA2TWxwqPZHEih4" target="_blank" rel="external">CSS技巧——rgba函数的妙用</a></h3><p>本文巧妙通过透明度实现了只改父元素的背景色，就能更改子元素的背景的功能。</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="230行实现一个简单的MVVM"><a href="#230行实现一个简单的MVVM" class="headerlink" title="230行实现一个简单的MVVM"></a><a href="https://zhuanlan.zhihu.com/p/24475845" target="_blank" rel="external">230行实现一个简单的MVVM</a></h3><h3 id="用React、Redux、Immutable做俄罗斯方块-掘金技术征文"><a href="#用React、Redux、Immutable做俄罗斯方块-掘金技术征文" class="headerlink" title="用React、Redux、Immutable做俄罗斯方块 | 掘金技术征文"></a><a href="https://gold.xitu.io/post/585a3e151b69e60056fe44fb" target="_blank" rel="external">用React、Redux、Immutable做俄罗斯方块 | 掘金技术征文</a></h3><h3 id="在-ECMAScript-2016-中被忽视的一个小变化"><a href="#在-ECMAScript-2016-中被忽视的一个小变化" class="headerlink" title="在 ECMAScript 2016 中被忽视的一个小变化"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964027&amp;idx=1&amp;sn=9f53a1ed65ec4ef7e724aaccd4defba6&amp;chksm=843aec5db34d654b6527673369a7194650ee37eed6da82f4a5dd9d6baaaa996e151061337dc2&amp;mpshare=1&amp;scene=1&amp;srcid=1220PrBGzLB0Ar5B2byuSTuq" target="_blank" rel="external">在 ECMAScript 2016 中被忽视的一个小变化</a></h3><p>ES62016种严格模式不能再es6函数中显示开始了，会报语法错误。</p>
<h3 id="JavaScript函数式编程（一）"><a href="#JavaScript函数式编程（一）" class="headerlink" title="JavaScript函数式编程（一）"></a><a href="https://zhuanlan.zhihu.com/p/21714695" target="_blank" rel="external">JavaScript函数式编程（一）</a></h3><p>本文和相面的一篇文章介绍和函数式编程的相关知识。</p>
<h3 id="JavaScript函数式编程（二）"><a href="#JavaScript函数式编程（二）" class="headerlink" title="JavaScript函数式编程（二）"></a><a href="https://segmentfault.com/a/1190000006219749" target="_blank" rel="external">JavaScript函数式编程（二）</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="从培训班出来之后找工作的经历，教会了我这五件事"><a href="#从培训班出来之后找工作的经历，教会了我这五件事" class="headerlink" title="从培训班出来之后找工作的经历，教会了我这五件事"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651224587&amp;idx=1&amp;sn=43b51b0a5f1e1c86cf0fb9ea7f6bb588&amp;chksm=bd49a38f8a3e2a9994a656260d7d6b8d08949b43a35d8aae6950b3eb4aac3d8b05b699fe2d35&amp;mpshare=1&amp;scene=1&amp;srcid=1220pmS2Q9AQ7ua05gMy4e8L#rd" target="_blank" rel="external">从培训班出来之后找工作的经历，教会了我这五件事</a></h3><p>本文作者通过自己亲身经历诉说了自己参加培训后出来找工作的经历，作者统计了自己的50多次面试情况，告诉大家面试的技巧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;12.18-12.24，本期的主题是你认为你的核心竞争力在哪？。&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;若你已做多年前端（5年-），你觉得你目前的核心竞争力在哪？&quot;&gt;&lt;a href=&quot;#若你已做多年前端（5年-），你觉得你目前的核心竞争力在哪？&quot; class=&quot;headerlink&quot; title=&quot;若你已做多年前端（5年+），你觉得你目前的核心竞争力在哪？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/53542412/answer/137031732?utm_source=wechat_timeline&amp;amp;utm_medium=social&amp;amp;from=groupmessage&amp;amp;isappinstalled=0&quot;&gt;若你已做多年前端（5年+），你觉得你目前的核心竞争力在哪？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我觉得大概在知识，经验，软素质等方面。&lt;/p&gt;
&lt;h3 id=&quot;不管你在哪里上班，至少记住这个字！&quot;&gt;&lt;a href=&quot;#不管你在哪里上班，至少记住这个字！&quot; class=&quot;headerlink&quot; title=&quot;不管你在哪里上班，至少记住这个字！&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTU0NDA4Nw==&amp;amp;mid=2655455671&amp;amp;idx=1&amp;amp;sn=ee93cea6da065486ebdd5b5f42004511&amp;amp;chksm=bc8a7dcf8bfdf4d9b4eda79b07a76c5f3be24636a6622100ed5407cce51c2b85c44c7be6a8b0&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1220ANjVrdaoTRU3L9m99ql8#rd&quot;&gt;不管你在哪里上班，至少记住这个字！&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;你也许认为本文是鸡汤文，但我不这么认为，我其实很希望自己能早点看到这篇文章，不管你做什么工作，如果你做到本文提到的点，那你应该不会太差。&lt;/p&gt;
&lt;h3 id=&quot;React-组件间通讯&quot;&gt;&lt;a href=&quot;#React-组件间通讯&quot; class=&quot;headerlink&quot; title=&quot;React 组件间通讯&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://taobaofed.org/blog/2016/11/17/react-components-communication/&quot;&gt;React 组件间通讯&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;最近面试了很多人，发现能把这个问题讲清楚的，真没有几个人。。。很尴尬。实在不能想象是怎么用react做东西的。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10000期</title>
    <link href="https://exp-team.github.io/blog/2016/12/17/weekly/weekly-10000/"/>
    <id>https://exp-team.github.io/blog/2016/12/17/weekly/weekly-10000/</id>
    <published>2016-12-16T16:00:00.000Z</published>
    <updated>2017-01-13T08:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>12.11-12.17，合抱之木生于毫末，九层之台起于垒土。</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="资深Web技术专家曹刘阳：2016年前端技术观察"><a href="#资深Web技术专家曹刘阳：2016年前端技术观察" class="headerlink" title="资深Web技术专家曹刘阳：2016年前端技术观察"></a><a href="http://geek.csdn.net/news/detail/128912" target="_blank" rel="external">资深Web技术专家曹刘阳：2016年前端技术观察</a></h3><p>合抱之木生于毫末，九层之台起于垒土，万丈高楼平地起。万里长城非一日而成，冰冻三尺非一日之寒。旧雨三年精化碧，孤灯午夜眼常青。不积跬步无以至千里，不积小流无以成江河。决定你速度的是智商，决定你高度的是基础。偷的懒迟早要补上，切记赶早不赶晚。</p>
<h3 id="开源大神-James-Kyle-写给-JavaScript-的一封信"><a href="#开源大神-James-Kyle-写给-JavaScript-的一封信" class="headerlink" title="开源大神 James Kyle 写给 JavaScript 的一封信"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650963957&amp;idx=1&amp;sn=d39eda3548256310ddcc249ce29af42a&amp;chksm=843a1393b34d9a85d08139aa53d6d885efbf117a3e6320a52433f5784d606bd20d14101f6928&amp;mpshare=1&amp;scene=1&amp;srcid=1213wlqwX0Q6DkZD9Wqn8Wb4#rd" target="_blank" rel="external">开源大神 James Kyle 写给 JavaScript 的一封信</a></h3><p>请尊重开源的人，他们是最无私的，向开源致敬。</p>
<h3 id="五个典型的-JavaScript-面试题"><a href="#五个典型的-JavaScript-面试题" class="headerlink" title="五个典型的 JavaScript 面试题"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650963939&amp;idx=1&amp;sn=ffa0ce59fc3a5691ee5be7520d1692d2&amp;chksm=843a1385b34d9a932f11138f3332231b26c71067b2ebc59e31f27faedb7a40c9b960bb4330a2&amp;mpshare=1&amp;scene=1&amp;srcid=1212E8wJvLX84dWuLLgI0PLy#rd" target="_blank" rel="external">五个典型的 JavaScript 面试题</a></h3><p>你一定知道我们最近在招人吧，如果你对这五个题都能看懂，那么快快发你的简历发给我吧。</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JavaScript-中-console-的用法"><a href="#JavaScript-中-console-的用法" class="headerlink" title="JavaScript 中 console 的用法"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651224517&amp;idx=2&amp;sn=a2a36361fa8010e8f041055192f5313c&amp;chksm=bd49a0418a3e2957e453a28c918988fcb27ccf998ce57fc733dcc8a282d6626e6db08bcc4e22&amp;mpshare=1&amp;scene=1&amp;srcid=1212zJeB8tKpRMpNNo0BkSZa#rd" target="_blank" rel="external">JavaScript 中 console 的用法</a></h3><p>用了这么久的console，你一定还有很多技巧不知道，来看看这篇文章，一定不会让你失望的。</p>
<h3 id="ES-5-新增特性汇总"><a href="#ES-5-新增特性汇总" class="headerlink" title="ES 5 新增特性汇总"></a><a href="https://zhuanlan.zhihu.com/p/24336831" target="_blank" rel="external">ES 5 新增特性汇总</a></h3><p>最近面试了不少人，发现大家的基础都不太好，快来补习补习基础吧。</p>
<h3 id="你可能不需要Redux"><a href="#你可能不需要Redux" class="headerlink" title="你可能不需要Redux"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650963909&amp;idx=1&amp;sn=e70000f256e6f53eedf077cd3c8cc19e&amp;chksm=843a13a3b34d9ab51b3231385a8c28f6fb2e7b45181c30ddd6fd0c525dfdbf8f97e7d7f83e66&amp;mpshare=1&amp;scene=1&amp;srcid=1212gEm4QOfQ9G7SfY1rTSjM#rd" target="_blank" rel="external">你可能不需要Redux</a></h3><p>在你犹豫要不要使用redux是，那就选择不用。</p>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="浅析渲染引擎与前端优化"><a href="#浅析渲染引擎与前端优化" class="headerlink" title="浅析渲染引擎与前端优化"></a><a href="http://jdc.jd.com/archives/2806" target="_blank" rel="external">浅析渲染引擎与前端优化</a></h3><h3 id="雅虎这35条前端优化规则，你值得拥有！"><a href="#雅虎这35条前端优化规则，你值得拥有！" class="headerlink" title="雅虎这35条前端优化规则，你值得拥有！"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655808361&amp;idx=1&amp;sn=93826ac350683dbdc42e35b94d546be9&amp;chksm=bd7426be8a03afa80e13f5dcaa5e66337196453ae540fc829d983d9e0a04ad1a0f96fa3c8a9a&amp;mpshare=1&amp;scene=1&amp;srcid=1213FExvfbWRj2D2zRqjEovI#rd" target="_blank" rel="external">雅虎这35条前端优化规则，你值得拥有！</a></h3><p>曾几何时还是雅虎14条原则，现在都35条了，快来看看你掌握几条。</p>
<h3 id="FIS-与-FIS-PLUS-的渊源"><a href="#FIS-与-FIS-PLUS-的渊源" class="headerlink" title="FIS 与 FIS-PLUS 的渊源"></a><a href="http://fex.baidu.com/blog/2014/03/fis-plus/" target="_blank" rel="external">FIS 与 FIS-PLUS 的渊源</a></h3><p>对于刚刚入门的同学，傻傻的分不清楚fis和fisp的关系</p>
<h3 id="在-2017-年将会更加流行的-6-个-Web-开发趋势"><a href="#在-2017-年将会更加流行的-6-个-Web-开发趋势" class="headerlink" title="在 2017 年将会更加流行的 6 个 Web 开发趋势"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650963966&amp;idx=1&amp;sn=0295680af559dc286ec5fa9c9b0a4d7e&amp;chksm=843a1398b34d9a8e63b8b8f3b5af14f85dfc52977ace0c6069c4d0aac5ea7abaef47f76319fc&amp;mpshare=1&amp;scene=1&amp;srcid=1216yXoFXdS5jg9DDEwq8HnG#rd" target="_blank" rel="external">在 2017 年将会更加流行的 6 个 Web 开发趋势</a></h3><p>值此辞旧迎新之际，如果你是一个弄潮儿，可以看看这篇文章，内容很超前。</p>
<h3 id="魔法哥-2013-前端笔试题曝光（附完整解答）"><a href="#魔法哥-2013-前端笔试题曝光（附完整解答）" class="headerlink" title="魔法哥 2013 前端笔试题曝光（附完整解答）"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIyMjE0ODQ0OQ==&amp;mid=2651552755&amp;idx=1&amp;sn=d89fd543a549d53678ae984a93e759ba&amp;chksm=f3ce39fdc4b9b0eb379b050925721e1add3ac4223cd5294cbac591440320e17fedd0203382a5&amp;mpshare=1&amp;scene=1&amp;srcid=1216S8oDe9CPuyaRIHLuvKLb#rd" target="_blank" rel="external">魔法哥 2013 前端笔试题曝光（附完整解答）</a></h3><p>这是魔法哥在 2013 年整理的一套笔试题，显然，其中有些内容已经过时了。尽管如此，我相信这套题还是有一定的参考价值，每道题后面都有出题意图、解题思路、参考答案或评分标准</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;12.11-12.17，合抱之木生于毫末，九层之台起于垒土。&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;资深Web技术专家曹刘阳：2016年前端技术观察&quot;&gt;&lt;a href=&quot;#资深Web技术专家曹刘阳：2016年前端技术观察&quot; class=&quot;headerlink&quot; title=&quot;资深Web技术专家曹刘阳：2016年前端技术观察&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://geek.csdn.net/news/detail/128912&quot;&gt;资深Web技术专家曹刘阳：2016年前端技术观察&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;合抱之木生于毫末，九层之台起于垒土，万丈高楼平地起。万里长城非一日而成，冰冻三尺非一日之寒。旧雨三年精化碧，孤灯午夜眼常青。不积跬步无以至千里，不积小流无以成江河。决定你速度的是智商，决定你高度的是基础。偷的懒迟早要补上，切记赶早不赶晚。&lt;/p&gt;
&lt;h3 id=&quot;开源大神-James-Kyle-写给-JavaScript-的一封信&quot;&gt;&lt;a href=&quot;#开源大神-James-Kyle-写给-JavaScript-的一封信&quot; class=&quot;headerlink&quot; title=&quot;开源大神 James Kyle 写给 JavaScript 的一封信&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;amp;mid=2650963957&amp;amp;idx=1&amp;amp;sn=d39eda3548256310ddcc249ce29af42a&amp;amp;chksm=843a1393b34d9a85d08139aa53d6d885efbf117a3e6320a52433f5784d606bd20d14101f6928&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1213wlqwX0Q6DkZD9Wqn8Wb4#rd&quot;&gt;开源大神 James Kyle 写给 JavaScript 的一封信&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;请尊重开源的人，他们是最无私的，向开源致敬。&lt;/p&gt;
&lt;h3 id=&quot;五个典型的-JavaScript-面试题&quot;&gt;&lt;a href=&quot;#五个典型的-JavaScript-面试题&quot; class=&quot;headerlink&quot; title=&quot;五个典型的 JavaScript 面试题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;amp;mid=2650963939&amp;amp;idx=1&amp;amp;sn=ffa0ce59fc3a5691ee5be7520d1692d2&amp;amp;chksm=843a1385b34d9a932f11138f3332231b26c71067b2ebc59e31f27faedb7a40c9b960bb4330a2&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1212E8wJvLX84dWuLLgI0PLy#rd&quot;&gt;五个典型的 JavaScript 面试题&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;你一定知道我们最近在招人吧，如果你对这五个题都能看懂，那么快快发你的简历发给我吧。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第1111期</title>
    <link href="https://exp-team.github.io/blog/2016/12/10/weekly/weekly-1111/"/>
    <id>https://exp-team.github.io/blog/2016/12/10/weekly/weekly-1111/</id>
    <published>2016-12-09T16:00:00.000Z</published>
    <updated>2017-01-13T08:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>12.4-12.10，这一期的数字听应景，水满则溢，月盈则亏，或升华，或迷失，进步永无止境。</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="Firebug-宣布停止开发更新"><a href="#Firebug-宣布停止开发更新" class="headerlink" title="Firebug 宣布停止开发更新"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651551544&amp;idx=1&amp;sn=5df9d76d2aab4bf82cc685f17af6aec9&amp;chksm=8025a0f9b75229ef349dd3507f16e7faf74cca0639af7a2b67bd894611f45abd28fd57810be2&amp;mpshare=1&amp;scene=1&amp;srcid=1207aEhoIUyh4RiyNQACrmj3#rd" target="_blank" rel="external">Firebug 宣布停止开发更新</a></h3><p>一石激起千层浪，这真是一个重磅消息，曾几何时，是你挽救了无数页面仔宝贵的青春，是你让前端调试工具迈进了一个新时代，急流勇退，智者也，缅怀，致敬。</p>
<h3 id="阅读-NodeJS-文档，我学到了这-19-件事情"><a href="#阅读-NodeJS-文档，我学到了这-19-件事情" class="headerlink" title="阅读 NodeJS 文档，我学到了这 19 件事情"></a><a href="https://zhuanlan.zhihu.com/p/24210807" target="_blank" rel="external">阅读 NodeJS 文档，我学到了这 19 件事情</a></h3><p>最近学了点node的东西，用node做了几个小工具，突然发现，一下子打开了一扇新大门，原来有了权力确实感觉不一样，有权限的人想要更大的权限，向着未来出发，即便你写了很久的nodejs，也未必知道这19件事。</p>
<h3 id="前端-MVC-已死吗？"><a href="#前端-MVC-已死吗？" class="headerlink" title="前端 MVC 已死吗？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650963905&amp;idx=1&amp;sn=70019642c4cbaaca657706ad20585934&amp;chksm=843a13a7b34d9ab1abb85b611daae44af0d0616bde0e686029c04c25840df62bd2d18c134937&amp;mpshare=1&amp;scene=1&amp;srcid=1209dJSy76l94Ea4lMrGzJk4#rd" target="_blank" rel="external">前端 MVC 已死吗？</a></h3><p>还未学过，就以死去吗？我并不这么认为，无数陈旧项目还在使用者mvc，无数历史项目都是mvc撑起来的，即便技术已不在流行，但还是值得学习的，道理不会变的，我们的目的只有一个，提升效率，有些东西死了，他还活着，永远。</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="理解-Babel-插件"><a href="#理解-Babel-插件" class="headerlink" title="理解 Babel 插件"></a><a href="http://taobaofed.org/blog/2016/09/29/babel-plugins/" target="_blank" rel="external">理解 Babel 插件</a></h3><h3 id="React-实践心得：key-属性的原理和用法"><a href="#React-实践心得：key-属性的原理和用法" class="headerlink" title="React 实践心得：key 属性的原理和用法"></a><a href="http://taobaofed.org/blog/2016/08/24/react-key/" target="_blank" rel="external">React 实践心得：key 属性的原理和用法</a></h3><h3 id="深入了解-JavaScript-中的-for-循环"><a href="#深入了解-JavaScript-中的-for-循环" class="headerlink" title="深入了解 JavaScript 中的 for 循环"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651224371&amp;idx=1&amp;sn=54771d5420daf8f5554605c16023dc64&amp;chksm=bd49a0b78a3e29a10b45dae92a5668c5895bdb35d03b78f491cdbc68b8ba87ea511c8dc33cb5&amp;mpshare=1&amp;scene=1&amp;srcid=1207VugbcGhtGVIUNRVLR0FM#rd" target="_blank" rel="external">深入了解 JavaScript 中的 for 循环</a></h3><p>很久没有一篇文章能够打动我的心了，而这就是难得的一篇，即便你是个geek，也未必知道的如此透彻。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="使用CSS3-REM-和-VW-打造等比例响应式页面的便捷工作流"><a href="#使用CSS3-REM-和-VW-打造等比例响应式页面的便捷工作流" class="headerlink" title="使用CSS3 REM 和 VW 打造等比例响应式页面的便捷工作流"></a><a href="https://zhuanlan.zhihu.com/p/23968868" target="_blank" rel="external">使用CSS3 REM 和 VW 打造等比例响应式页面的便捷工作流</a></h3><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="淘宝首页性能优化实践"><a href="#淘宝首页性能优化实践" class="headerlink" title="淘宝首页性能优化实践"></a><a href="http://taobaofed.org/blog/2016/04/05/optimize-in-tbhome/" target="_blank" rel="external">淘宝首页性能优化实践</a></h3><h3 id="“一天精通-Chrome-开发”"><a href="#“一天精通-Chrome-开发”" class="headerlink" title="“一天精通 Chrome 开发”"></a><a href="https://zhuanlan.zhihu.com/p/24225644" target="_blank" rel="external">“一天精通 Chrome 开发”</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="技术的成长曲线"><a href="#技术的成长曲线" class="headerlink" title="技术的成长曲线"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261460&amp;idx=1&amp;sn=9c4decdffe54e0705ee0b468bebd59f8&amp;chksm=84479e4db330175b0f9ed87040768ed20e929fad6097b8a16b5fb431ea33c9cf5b51e9cf8234&amp;mpshare=1&amp;scene=1&amp;srcid=1129s7MEHAkjL0S5hg8KAlG6#rd" target="_blank" rel="external">技术的成长曲线</a></h3><p>技术成长，永无止境，你我共勉，加油。</p>
<h3 id="程序员练级指北"><a href="#程序员练级指北" class="headerlink" title="程序员练级指北"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651224332&amp;idx=1&amp;sn=99bcc28e0e4d65e62d9aa86bdae55f4d&amp;chksm=bd49a0888a3e299ea4b6b4f0fe4370ea3cd54e8db46b56448b282d5e405fa2f50f0c595199e3&amp;mpshare=1&amp;scene=1&amp;srcid=1206a2tYXT8PHyyGHy1FE3We#rd" target="_blank" rel="external">程序员练级指北</a></h3><p>欲穷千里目，更上一层楼，这也是我创建expfe周刊的目的，1+1&gt;2，进步我们要一起。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;12.4-12.10，这一期的数字听应景，水满则溢，月盈则亏，或升华，或迷失，进步永无止境。&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;Firebug-宣布停止开发更新&quot;&gt;&lt;a href=&quot;#Firebug-宣布停止开发更新&quot; class=&quot;headerlink&quot; title=&quot;Firebug 宣布停止开发更新&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;amp;mid=2651551544&amp;amp;idx=1&amp;amp;sn=5df9d76d2aab4bf82cc685f17af6aec9&amp;amp;chksm=8025a0f9b75229ef349dd3507f16e7faf74cca0639af7a2b67bd894611f45abd28fd57810be2&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1207aEhoIUyh4RiyNQACrmj3#rd&quot;&gt;Firebug 宣布停止开发更新&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;一石激起千层浪，这真是一个重磅消息，曾几何时，是你挽救了无数页面仔宝贵的青春，是你让前端调试工具迈进了一个新时代，急流勇退，智者也，缅怀，致敬。&lt;/p&gt;
&lt;h3 id=&quot;阅读-NodeJS-文档，我学到了这-19-件事情&quot;&gt;&lt;a href=&quot;#阅读-NodeJS-文档，我学到了这-19-件事情&quot; class=&quot;headerlink&quot; title=&quot;阅读 NodeJS 文档，我学到了这 19 件事情&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24210807&quot;&gt;阅读 NodeJS 文档，我学到了这 19 件事情&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;最近学了点node的东西，用node做了几个小工具，突然发现，一下子打开了一扇新大门，原来有了权力确实感觉不一样，有权限的人想要更大的权限，向着未来出发，即便你写了很久的nodejs，也未必知道这19件事。&lt;/p&gt;
&lt;h3 id=&quot;前端-MVC-已死吗？&quot;&gt;&lt;a href=&quot;#前端-MVC-已死吗？&quot; class=&quot;headerlink&quot; title=&quot;前端 MVC 已死吗？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;amp;mid=2650963905&amp;amp;idx=1&amp;amp;sn=70019642c4cbaaca657706ad20585934&amp;amp;chksm=843a13a7b34d9ab1abb85b611daae44af0d0616bde0e686029c04c25840df62bd2d18c134937&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1209dJSy76l94Ea4lMrGzJk4#rd&quot;&gt;前端 MVC 已死吗？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;还未学过，就以死去吗？我并不这么认为，无数陈旧项目还在使用者mvc，无数历史项目都是mvc撑起来的，即便技术已不在流行，但还是值得学习的，道理不会变的，我们的目的只有一个，提升效率，有些东西死了，他还活着，永远。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第1110期</title>
    <link href="https://exp-team.github.io/blog/2016/12/04/weekly/weekly-1110/"/>
    <id>https://exp-team.github.io/blog/2016/12/04/weekly/weekly-1110/</id>
    <published>2016-12-03T16:00:00.000Z</published>
    <updated>2017-01-13T08:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>11.28-12.04，“时光飞逝，来不及说再见”。</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="ES6-的模块系统"><a href="#ES6-的模块系统" class="headerlink" title="ES6 的模块系统"></a><a href="https://segmentfault.com/a/1190000003410285" target="_blank" rel="external">ES6 的模块系统</a></h3><p>在任何发型项目中，模块化都是非常常见，也是非常有必要的，es6为JavaScript带来了模块特性，对比JavaScript模块系统的现状，es的模块系统在规范上与其他的模块系统衔接得非常好，以至于大家对他的学习成本很低，这篇文章不但在语法上讲得非常详细透彻，在原理上也分析得浅显易懂，没有很多晦涩的语法个名词，对于理解ES6模块化非常有帮助。</p>
<h3 id="CSS-方法论的选择"><a href="#CSS-方法论的选择" class="headerlink" title="CSS 方法论的选择"></a><a href="http://zcfy.cc/article/when-to-use-which-css-methodology-1828.html" target="_blank" rel="external">CSS 方法论的选择</a></h3><p>相信各路前端大神对css方法论的选择都有自己的想法，对于我个人而言，没有最好的，只有最适合自己的，去争论其中的好坏并没有什么意义，还不如脚踏实地的做好自己技术选型。</p>
<h3 id="美团点评酒旅前端的技术体系"><a href="#美团点评酒旅前端的技术体系" class="headerlink" title="美团点评酒旅前端的技术体系"></a><a href="https://zhuanlan.zhihu.com/p/23976121" target="_blank" rel="external">美团点评酒旅前端的技术体系</a></h3><p>当我们沉浸在自己所在团队的技术体系下的同时也要多看看外面的世界，对比自己所在的技术体系，或许有相似之处，也有很多值得我们学习和思考的point~<br><a id="more"></a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="天猫即将不支持IE8"><a href="#天猫即将不支持IE8" class="headerlink" title="天猫即将不支持IE8"></a><a href="https://zhuanlan.zhihu.com/p/24091492" target="_blank" rel="external">天猫即将不支持IE8</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;11.28-12.04，“时光飞逝，来不及说再见”。&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;ES6-的模块系统&quot;&gt;&lt;a href=&quot;#ES6-的模块系统&quot; class=&quot;headerlink&quot; title=&quot;ES6 的模块系统&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003410285&quot;&gt;ES6 的模块系统&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在任何发型项目中，模块化都是非常常见，也是非常有必要的，es6为JavaScript带来了模块特性，对比JavaScript模块系统的现状，es的模块系统在规范上与其他的模块系统衔接得非常好，以至于大家对他的学习成本很低，这篇文章不但在语法上讲得非常详细透彻，在原理上也分析得浅显易懂，没有很多晦涩的语法个名词，对于理解ES6模块化非常有帮助。&lt;/p&gt;
&lt;h3 id=&quot;CSS-方法论的选择&quot;&gt;&lt;a href=&quot;#CSS-方法论的选择&quot; class=&quot;headerlink&quot; title=&quot;CSS 方法论的选择&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://zcfy.cc/article/when-to-use-which-css-methodology-1828.html&quot;&gt;CSS 方法论的选择&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;相信各路前端大神对css方法论的选择都有自己的想法，对于我个人而言，没有最好的，只有最适合自己的，去争论其中的好坏并没有什么意义，还不如脚踏实地的做好自己技术选型。&lt;/p&gt;
&lt;h3 id=&quot;美团点评酒旅前端的技术体系&quot;&gt;&lt;a href=&quot;#美团点评酒旅前端的技术体系&quot; class=&quot;headerlink&quot; title=&quot;美团点评酒旅前端的技术体系&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23976121&quot;&gt;美团点评酒旅前端的技术体系&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;当我们沉浸在自己所在团队的技术体系下的同时也要多看看外面的世界，对比自己所在的技术体系，或许有相似之处，也有很多值得我们学习和思考的point~&lt;br&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的react+redux工程实例</title>
    <link href="https://exp-team.github.io/blog/2016/11/26/program/react-redux-1/"/>
    <id>https://exp-team.github.io/blog/2016/11/26/program/react-redux-1/</id>
    <published>2016-11-25T16:00:00.000Z</published>
    <updated>2017-01-17T05:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在学习研究react.js。前前后后做了几次分享。并在我参与的私信项目也使用了这套技术栈 ，目前也已经上线。</p>
<p>学习过程期间，感觉react+redux初级DEMO不多，社区上多是用烂了的todolist教程，未免乏味。<br>这篇文章主要实现一个简单的例子，难度不大，但是贯穿了react+redux基本思想。</p>
<p>他将会是一个连续教程，这只是第一篇，不涉及redux中间件，redux处理异步等内容，也不涉及react性能优化，不可变数据immutable.js等内容。读者可以根据自己的层次来选读。但这些不涉及到的内容，都会随着这个demo复杂度一步一步提升，在后续章节有分析和使用。<br>另外，他并不适合初学者阅读，如果你还不太清楚react.js、ES6、redux相关知识，建议先做了解。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>百度经验个人中心（WAP端）是经验流量较多的页面群，其中的个人定制页面是重要的页面之一，请用手机<a href="http://jingyan.baidu.com/user/nuc/feed" target="_blank" rel="external">点击这里</a>查看效果，页面的截图如下：</p>
<p><img src="/bimg/c1.png" alt=""></p>
<p>页面功能一目了然。主要分为两大块：<br>1）可以在『选择分类』区块中选择自己喜欢的经验分类条目来订阅。在该区块中，我们可以点击『换一换』按钮来切换分类条目。<br>2）已选结果会再『已选分类』区块里面展示。在『已选分类』区块里，我们可以点击相关经验分类条目来取消订阅。</p>
<p><img src="/bimg/c5.png" alt=""></p>
<p>在现在线上版本中，我们采用了传统的操作DOM方式（zepto类库）来实现这一系列交互。使用react，又是一种全新的思想。孰优孰劣，可以在结尾处大家自己总结。<br>好了，废话不多说，我们马上进入正题。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>整体目录如截图，为了和我们线上代码保持一致，我采用了fisp来做工程化组织。现在社区上大多都是采用webpack，其实这些工具用哪个都一样，解决的问题也都类似，这里不再展开。即使你不懂FIS，也不妨碍继续阅读。</p>
<p><img src="/bimg/c2.png" alt=""></p>
<h3 id="app-app文件夹下"><a href="#app-app文件夹下" class="headerlink" title="app/ app文件夹下"></a>app/ app文件夹下</h3><p>action.es定义了页面交互中dispatch的所有actions；</p>
<p><img src="/bimg/c6.png" alt=""></p>
<p>app.jsx是页面入口脚本；</p>
<p><img src="/bimg/c8.png" alt=""></p>
<p>component.jsx定义了页面的组件；</p>
<p><img src="/bimg/c7.png" alt=""></p>
<p>reducer.jsx接收action，该文件定义了所有用到的reducer。</p>
<h3 id="lib-lib-nomod-文件夹下"><a href="#lib-lib-nomod-文件夹下" class="headerlink" title="lib + lib-nomod 文件夹下"></a>lib + lib-nomod 文件夹下</h3><p>这两个文件夹是我们要用的框架源码，比如react.js+redux.js等等；<br>该项目用到的是react15.3.1版本未压缩版，这个版本比较稳定。<br>采用未压缩版的原因是想使用react addons 的perf，因为在后续章节中，会有性能优化部分的分析；<br>我们知道，react和redux其实独立存在，我们使用流行的react-redux.js库来实现两者的连接。</p>
<h3 id="其他相关文件"><a href="#其他相关文件" class="headerlink" title="其他相关文件"></a>其他相关文件</h3><p>其他还有 fis-conf.js文件：这是用来做fis配置的，比如打包规则，发布规则，编译配置等；<br>同时，我们配置了babel来编译es6和jsx等，还配置了autoprefixer；<br>server.conf是fis的附属文件，用来做数据mock；<br>build.sh和BCLOUD是上线脚本相关，这里我们并不上线，只是学习react的用法。</p>
<h2 id="页面数据"><a href="#页面数据" class="headerlink" title="页面数据"></a>页面数据</h2><p>我们部门后端是PHP，采用Smarty模板。这个页面会在请求时同步给出一些数据，比如用户信息等。项目里，我们的同步数据如截图：</p>
<p><img src="/bimg/c3.png" alt=""></p>
<p>我们关心selectList和likedList：<br>1）likedList给出当前用户已经选则的订阅分类条目；<br>2）selectList给出所有可选的分类条目，一共从1-127，127个可选条目，数据格式如上。<br>我们的脚本里使用F.context(‘likedList’)，和F.context(‘selectList’)取出相应同步数据，用于页面初始化展示。<br>F.context()没有什么可神奇的，其实就是一个全局的数据中心，实现就是在window.F下存取数据。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>说了这么多，终于可以进入具体代码层面了。如果上边的内容你似懂非懂，也没有关系。因为涉及了一些项目组织上的内容。下边的内容，就是具体的代码分析。</p>
<h3 id="数据设计"><a href="#数据设计" class="headerlink" title="数据设计"></a>数据设计</h3><p>react+redux开发前端的思想是页面由数据驱动。<br>上边已经分析到我们的页面主要由两种数据：<br>1）一个是F.context(‘selectList’)，我们姑且叫做选择池数据；<br>2）另一个是F.context(‘likedList’)，我们叫做已选数据。<br>这两处数据初始由reducer拿到，设置为容器组件的初始状态，并由容器组件传递给相应展示组件。</p>
<h3 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h3><p>组件设计如下截图：</p>
<p><img src="/bimg/c4.jpg" alt=""></p>
<p>按照react-redux思想，组件分为<br>1）容器组件，负责接收数据；<br>2）展示（木偶）组件负责向上接收数据，根据数据展现组件UI。</p>
<p>其实很明显，我们主要就是两个展示组件，叫做：<br>1）SelectedBlock，负责展示用户已选已订阅内容<br>2）SelectListBlock，展示页面选择池可供选择的内容<br>他们一起被套在叫做DemoApp的父组件里面。</p>
<p>有了以上划分，我们可以想到：<br>SelectedBlock组件需要关心已选数据F.context(‘likedList’)；<br>SelectListBlock则选择池数据和已选数据都需要关心。<br>你可能会问『SelectListBlock关心选择池数据不就够了吗？』<br>但是，产品经理要求在选择池里，当渲染用户已选条目时，需要样式置灰，并且在点击已选分类条目时不在触发action。所以选择池SelectListBlock组件也要依赖已选数据，进而做出相应的变化。</p>
<p>这两项数据由react-redux派分给容器组件，并由容器组件按需分给展示组件；</p>
<p>有了以上基础，我们看最外层的DemoApp组件全部代码：</p>
<pre><code>class DemoApp extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
        const { dispatch } = this.props;
        return (
            &lt;div&gt;
                &lt;SelectedBlock 
                    likedList={this.props.likedList} 
                    onDeleteLikeItem={(item)=&gt;{dispatch(action.deleteLikeItem(item))}}&gt;
                &lt;/SelectedBlock&gt;

                &lt;SelectListBlock 
                    selectList={this.props.selectList} 
                    likedList={this.props.likedList} 
                    onAddLikeItem={(index, item) =&gt;{dispatch(action.addLikeItem(index, item))}}&gt;
                &lt;/SelectListBlock&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>我们看他的render()部分，很明显，他平行嵌套了<br>1）SelectedBlock组件，并把likedList数据作为属性向其传递；<br>2）同时，包含了SelectListBlock，并把selectList，likedList数据作为属性向其传递。</p>
<p>那么SelectedBlock设计如下：</p>
<pre><code>class SelectedBlock extends React.Component {
    constructor(props) {
        super(props);
    }
    deleteItem(event, index) {
        this.props.onDeleteLikeItem(index);
    }
    render() {
        let likedList = this.props.likedList;
        let likedListArray = [];
        let likedListKey = Object.keys(likedList);
        likedListKey.forEach(function(index){
            likedListArray.push(likedList[index]);
        })
        return (
            &lt;div&gt;
                &lt;h2&gt;已选分类(&lt;em id=&quot;f-num&quot;&gt;{likedListArray.length}&lt;/em&gt;)&lt;/h2&gt;
                &lt;div className=&quot;selected-list&quot; style={{overflow: 'auto'}}&gt;
                    &lt;ul className=&quot;feed-list&quot;&gt;
                        {
                            likedListArray.length &gt; 0 ?
                            likedListArray.map((item, index) =&gt; {
                                return (
                                    &lt;li style={{position: 'relative'}}&gt;
                                        &lt;span&gt;{item}&lt;/span&gt;
                                        &lt;a style={deleteIconStyle} 
                                            onClick={event=&gt;{this.deleteItem(event, likedListKey[index])}}&gt;
                                        &lt;/a&gt;
                                    &lt;/li&gt;
                                )
                            })
                            :
                            &lt;li className=&quot;empty-list&quot;&gt;还没有任何订阅&lt;br /&gt;请从下方选择订阅&lt;/li&gt;
                        }
                    &lt;/ul&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>我们把likedList转换成likedListArray数组，在render()里面，直接使用map循环输出；<br>当用户删除某一条目时，触发deleteItem(event, index)方法，该方法向上传递。并在DemoApp父组件中，触发相应action。这个删除过程并不是一个组件内行为，因为这个action会使得已选数据发生变化，进而影响SelectListBlock组件。所以一系列逻辑需要在组件外，即reducer中处理，处理完后重置已选数据，进而页面更新。</p>
<p>SelectListBlock组件也很好理解：</p>
<pre><code>class SelectListBlock extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            flag: 0
        }
    }
    onChangeGroup(event) {
        event.stopPropagation();
        let flagNow = this.state.flag;
        if (flagNow == 117) {
            this.setState({
                flag: 0
            });
        }
        else {
            this.setState({
                flag: flagNow + 9
            });
        }
    }
    onSelectItem(index, item) {
        var likedList = this.props.likedList;
        var likedListKey = Object.keys(likedList);
        if ( likedListKey.indexOf(index.toString()) &gt;= 0 ) {
            return;
        }
        this.props.onAddLikeItem(index, item);
    }
    render() {
        let selectListArray = [];
        for (var i in this.props.selectList) {
            selectListArray.push(this.props.selectList[i])
        }
        let likedList = this.props.likedList;
        let likedListKey = Object.keys(likedList);
        return (
            &lt;div&gt;
                &lt;h2 className=&quot;clr&quot;&gt;
                    &lt;span onClick={event=&gt;{this.onChangeGroup(event)}}&gt;换一换&lt;/span&gt;
                选择分类&lt;/h2&gt;
                &lt;ul className=&quot;feed-list clr&quot;&gt;
                    {
                        selectListArray.slice(this.state.flag, this.state.flag+9).map((item, index)=&gt;{
                            return (
                                &lt;li onClick={event=&gt;{this.onSelectItem((index + this.state.flag), item)}} 
                                    key={index + this.state.flag}&gt;
                                    {(likedListKey.indexOf((index + this.state.flag).toString()) &gt;= 0 ?
                                        &lt;span className=&apos;disable&apos;&gt;{item}&lt;/span&gt;
                                        :
                                        &lt;span&gt;{item}&lt;/span&gt;
                                    )}
                                &lt;/li&gt;
                            )
                        })
                    }
                &lt;/ul&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre><p>我们首先把后端打过来的127条可供选择的数据转换为selectListArray数组。这127个分类内容都对应一个index（1-127）。之后我们获得用户已经选择喜欢条目的index，将这些index组成likedListKey数组，用于存储当前用户已选条目。在render()时候，因为页面一次只展示9项待选项，所以我们把selectListArray用slice方法按顺序切割出来9项输出。<br>点击『换一换』按钮时，触发onChangeGroup（）方法，这个方法是个组件内方法，他负责将slice参数+9，当到127（一共127项分类）时，还原回0。</p>
<p>我们知道，点击『换一换』触发的onChangeGroup方法改变flag时，因为flag为该组件内部state，他的变化，将会引起该组件重新render()，所以数据池就会毫无压力的切换了。</p>
<p>同时，我们给数据池里每一项分类都绑定onSelectItem方法，该方法会向上传递给父组件，由父组件发出相应action。因为这个动作将会改变已选数据，从而影响平行的SelectedBlock组件。因此需要在reducer中处理。</p>
<h3 id="action设计"><a href="#action设计" class="headerlink" title="action设计"></a>action设计</h3><p>有了以上组件的设计，很明显我们需要定义两个action：<br>1）第一个是添加某一条目到已选分类</p>
<pre><code>export const ADD_LIKE_ITEM = &apos;ADD_LIKE_ITEM&apos;;
</code></pre><p>对应action creator:</p>
<pre><code>export function addLikeItem (index, item) {
    return {
        type: ADD_LIKE_ITEM,
        obj: {
            index: index,
            item: item
        }
    }
}
</code></pre><p>返回action对象，包括type命名为ADD_LIKE_ITEM和负载数据：条目名item及其index。</p>
<p>2）另一个是在已选分类删除某一条目：</p>
<pre><code>export const DELETE_LIKE_ITEM = &apos;DELETE_LIKE_ITEM&apos;;
</code></pre><p>对应action creator:</p>
<pre><code>export function deleteLikeItem (index) {
    return {
        type: DELETE_LIKE_ITEM,
        index
    }
}
</code></pre><p>返回action对象，包括type和负载数据。<br>到此为止，action脚本只需要定义action，不需要进一步处理，对所有action的处理都会由reducer接受。</p>
<h3 id="reducer设计"><a href="#reducer设计" class="headerlink" title="reducer设计"></a>reducer设计</h3><p>再次强调reducer是一个纯函数，他接受两个参数，一个是state，一个是action；并对相应的action，返回一个新的state，从而促使页面里订阅相关state的组件再次render（）；<br>我们把同步模板数据initialLikeBlockState设为初始state：</p>
<pre><code>var initialLikeBlockState = F.context(&apos;likedList&apos;);
function likeBlockReducer (state = initialLikeBlockState, action) {
    switch (action.type) {
        case actionType.ADD_LIKE_ITEM: {
            var addIndex = action.obj.index;
            var newLikedList = Object.assign({}, state, {
                [addIndex]: action.obj.item
            })
            return newLikedList;
        }
        case actionType.DELETE_LIKE_ITEM: {
            var newLikedList =  {};
            for (var key in state) {  
                var val = state[key];  
                newLikedList[key] = val;  
            }  
            var index = action.index;
            delete newLikedList[index];
            return newLikedList;
        }
        default: {
            return state;
        }
    }
}
</code></pre><p>当匹配ADD_LIKE_ITEM action时，我们把当前的state和action带来的数据（item，index）进行merge，从而return 一个新的已选数据状态，即添加了新分类item的state；<br>当匹配DELETE_LIKE_ITEM action时，我们把action负载带来要删除item的index删除掉。返回删除该条目之后的新state。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>截至目前，我们介绍了基本设计和开发思路。教程里面已经基本包含了全部代码。</p>
<h3 id="对比线上已有代码"><a href="#对比线上已有代码" class="headerlink" title="对比线上已有代码"></a>对比线上已有代码</h3><p>1）和线上的zepto实现对比完全是两种思路，经过比较，用react设计的代码代码量上有明显的优势。<br>2）开发思路上，是个萝卜青菜各有所爱的问题。但是对于写惯了$()的我来说，这种全新的开发方式还是带来了很大的惊喜。<br>3）线上实现这一套逻辑，可能对于一个简单的UI交互，我们都需要选取很多dom元素，进行处理。整体上看，比较复杂且凌乱，不是很容易进行维护。</p>
<h3 id="接下来…"><a href="#接下来…" class="headerlink" title="接下来…"></a>接下来…</h3><p>当然，这只是第一步。后边还有更多的路要走。比如：<br>1）我们在选择或删除一个条目时，如何给后端发异步请求并没有涉及。因此，redux异步流程并没有展现。后续章节会进一步讲解。<br>2）我们的数据都是后端模板通过同步的方式传递过来的，数据量也不大，结构也不复杂，因此这一章为了简单并未使用immutable.js。当然，后续章节会进一步讲解。<br>3）这里我并没有介绍使用redux dev tool，这真的是一个很漂亮的利器。<br>尤其在数据复杂时候，对于调试能帮上很大作用。后面我会单独介绍一下关于这个工具的使用。<br>4）最后，这么简单的交互还并不会涉及页面性能的问题。在后续章节，我会构造出极端CASE进行一些边缘测试，并使用一些方法结合chrome dev tool进行性能优化，请进一步关注。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在学习研究react.js。前前后后做了几次分享。并在我参与的私信项目也使用了这套技术栈 ，目前也已经上线。&lt;/p&gt;
&lt;p&gt;学习过程期间，感觉react+redux初级DEMO不多，社区上多是用烂了的todolist教程，未免乏味。&lt;br&gt;这篇文章主要实现一个简单的
    
    </summary>
    
      <category term="program" scheme="https://exp-team.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://exp-team.github.io/tags/program/"/>
    
  </entry>
  
</feed>
