<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>exp team</title>
  <subtitle>together, stronger</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://exp-team.github.io/"/>
  <updated>2017-03-18T06:37:37.000Z</updated>
  <id>https://exp-team.github.io/</id>
  
  <author>
    <name>exp developer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>探索nodeJS事件机制源码 打造属于自己的事件发布订阅系统</title>
    <link href="https://exp-team.github.io/blog/2017/03/22/js/node_event/"/>
    <id>https://exp-team.github.io/blog/2017/03/22/js/node_event/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-18T06:37:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，nodeJS改变了整个前端开发生态。本文通过分析nodeJS当中events模块源码，由浅入深实现了属于自己的ES6事件观察者系统。千万不要被nodeJS的外表吓到，不管你是写nodeJS已经轻车熟路的老司机，还是初入前端的小菜鸟，都不妨碍对这篇文章的阅读和理解。</p>
<p>##内有乾坤<br>nodeJS<a href="https://github.com/nodejs/node" target="_blank" rel="external">官方介绍</a>中，第二句话便是：”Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient”。由此，“事件驱动（event-driven）”对nodeJS设计理念的重要性可见一斑。比如，我们对于文件的读取，任务队列的执行情况都需要这样一个观察者模式来保障。</p>
<p>##那个最熟悉的陌生人<br>同时，作为前端开发人员，我们对于所谓的“事件驱动”理念——即事件发布订阅模式（Pub/Sub模式）一定再熟悉不过了。这种模式在js里面有与生俱来的基因。我们可以认为JS本身就是事件驱动型语言：比如，页面上有一个button, 点击一下就会触发上面的click事件。这是因为此时有特定程序正在监听这个事件，随之触发了相关的处理程序。</p>
<p>这个模式最大的一个好处在于能够解耦，实现“高内聚、低耦合”的理念。那么这样的一个“熟悉的”模式应该怎么实现呢？</p>
<p>其实社区上已经有不少前辈的实现方式了，但是都不能算特别完美，或者不能完全符合特定的场景需求。</p>
<p>本文通过解析nodeJS源码中的events模块，提取其精华，一步步打造了一个基于ES6的eventEmitter系统。</p>
<p>读者有任何想法，欢迎与我交流。同时希望各路大神给予斧正。</p>
<h2 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h2><p>为了方便大家理解，我从一个很简单的页面实例说起。</p>
<p>该页面中，存在两处不同的收藏组件。一处在页面顶部，一处在页面详情侧栏。第一次点击一个收藏组件按钮，发送异步请求，进行收藏，同时请求成功的回调函数里将页面中所有“收藏”按钮转换状态为“已收藏”。以达到“当前文章”收藏状态的全局同步。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-a04e1b0f57f8a63d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="页面实例"></p>
<p>完成这样的设计很简单，我们大可在业务代码中进行混乱的操作处理，比如初学者常见的做法是：点击第一处收藏，回调逻辑修改页面当中所有收藏按钮。<br>这样做的问题在于耦合混乱，不仅仅是一个收藏组件，试想当代码中全都是这样的“随意”操作，后期维护成本便一发不可收。</p>
<p>我的Github仓库中，也有对于这么一个页面实例的分析，读者若想自己玩一下，可以访问<a href="https://github.com/HOUCe/eventEmitter" target="_blank" rel="external">这里。</a></p>
<p>当然，更优雅的做法就是使用事件订阅发布系统。<br>如何设计一个事件订阅发布系统？我们先来看看nodeJS是怎么做的吧？</p>
<h2 id="nodeJS方案"><a href="#nodeJS方案" class="headerlink" title="nodeJS方案"></a>nodeJS方案</h2><p>读者可以自己去nodeJS仓库查找源码，不过更推荐参考我的<a href="https://github.com/HOUCe/eventEmitter" target="_blank" rel="external">Github-事件发布订阅研究项目</a>，里面不仅有自己实现的多套基于ES6的事件发布订阅系统，也附赠了nodeJS实现源码。同时我对源码加上了汉语注释，方便大家理解。</p>
<p>在nodeJS中，引入eventEmitter的方式和使用方法如下：</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
</code></pre><p>我们要研究的，当然就是这个eventEmitter实例。先不急于深入源码，我们需要在使用层面先有一个清晰的理解和认知。不然盲目阅读源码，便极易成为一只“无头苍蝇”。</p>
<p>一个eventEmitter实例，自身包含有四个属性：<br>1）_events：<br>这是一个object，其实相当于一个哈希map。他用来保存一个eventEmitter实例中所有的注册事件和事件所对应的处理函数。以键值对方式存储，key为事件名；value分为两种情况，当当前注册事件只有一个注册的监听函数时，value为这个监听函数；如果此事件有多个注册的监听函数时，value值为一个数组，数组每一项顺序存储了对应此事件的注册函数。<br>需要说明的是，理解value值的这两种情况，对于后面的源码分析非常重要。我认为nodeJS之所以有这样的设计，是出于性能上的考虑。因为很多情况（单一监听函数情况）并不需要在内存上新建一个额外数组。</p>
<p>2）_eventsCount：整型，表示此eventEmitter实例中注册的事件个数。</p>
<p>3）_maxListeners：整型，表示此eventEmitter实例中，一个事件最多所能承载的监听函数个数。</p>
<p>4）domain：在node v0.8+版本的时候，发布了一个模块domain。这个模块做的是捕捉异步回调中出现的异常。这里与主题无关，不做展开。</p>
<p>同样，eventEmitter实例的构造函数原型上，包含了一些更为重要的属性和方法，包括但不限于：<br>1）addListener(event, listener)：<br>为指定事件添加一个注册函数（以下称监听器）到监听器数组的尾部。他存在一个别名：on。<br>2）once(event, listener)：<br>为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。<br>3）removeListener(event, listener)：<br>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。<br>4）removeAllListeners([event])：<br>移除所有事件的所有监听器。如果指定事件，则移除指定事件的所有监听器。<br>5）setMaxListeners(n)：<br>默认情况下，如果你添加的监听器超过10个就会输出警告信息。setMaxListeners 函数用于提高监听器的默认限制的数量。<br>6）listeners(event)：返回指定事件的监听器数组。<br>7）emit(event, [arg1], [arg2], […])：<br>按参数的顺序执行每个监听器，如果事件有注册监听器返回true，否则返回false。</p>
<h2 id="nodeJS设计之美"><a href="#nodeJS设计之美" class="headerlink" title="nodeJS设计之美"></a>nodeJS设计之美</h2><p>上一段其实简要介绍了nodeJS中eventEmitter的使用方法。下面，我们要做的就是深入nodeJS events模块源码，了解并学习他的设计之美。</p>
<h3 id="如何创建空对象？"><a href="#如何创建空对象？" class="headerlink" title="如何创建空对象？"></a>如何创建空对象？</h3><p>我们已经了解到，_events是要来储存监听事件(key)、监听器数组(value)的map。那么，他的初始值一定是一个空对象。直观上，我们可以这样创建一个空对象：</p>
<pre><code>this._events = {};
</code></pre><p>但是nodeJS源码中的实现方式却是这样：</p>
<pre><code>function EventHandlers() {};
EventHandlers.prototype = Object.create(null);
this._events = new EventHandlers();
</code></pre><p>这么做的原因是出于性能上的考虑，经过jsperf比较，在v8 v4.9版本中，后者性能有超出2倍的表现。<br>对此，作为一个“吹毛求疵”有态度的程序员，我写了一个benchmark，对一个对象进行一千次取值操作，求平均时间进行验证：</p>
<pre><code>_events = {};
_events.test=&apos;test&apos;
for (let i = 0; i &lt; 1000; i++) {
    window.performance.mark(&apos;test empty object start&apos;);
    console.log(_events.test);
    window.performance.mark(&apos;test empty object end&apos;);
    window.performance.measure(&apos;test empty object&apos;,&apos;test empty object start&apos;,&apos;test empty object end&apos;);
} 
let sum1 = 0
for (let k = 0; k &lt; 1000; k++) {
    sum1 +=window.performance.getEntriesByName(&apos;test empty object&apos;)[k].duration
}
let averge1 = sum1/1000;
console.log(averge1*1000);

function EventHandlers() {};
EventHandlers.prototype = Object.create(null);
_events = new EventHandlers();
for (let i = 0; i &lt; 1000; i++) {
    window.performance.mark(&apos;test empty object start&apos;);
    console.log(_events.test);
    window.performance.mark(&apos;test empty object end&apos;);
    window.performance.measure(&apos;test empty object&apos;,&apos;test empty object start&apos;,&apos;test empty object end&apos;);
} 
let sum1 = 0
for (let k = 0; k &lt; 1000; k++) {
    sum1 +=window.performance.getEntriesByName(&apos;test empty object&apos;)[k].duration
}
let averge1 = sum1/1000;
console.log(averge1*1000);
</code></pre><p>我自己的想法是，使用nodeJS源码中这样创建空对象的方式，在对对象属性的读取上能够节省原型链查找的时间。但是，如果一个属性直接在该对象上，即hasOwnProperty()为true，是否还有节省查找时间，性能优化的空间呢？</p>
<p>另外，不同浏览器引擎的处理可能也存在差别，即使是流行的V8引擎，处理机制也“深不可测”。同时，benchmark中都是对同一属性的读取，一般来讲浏览器引擎对同样的操作行为应该会有一个“cache”机制，据我了解JIT(just-in-time)实时汇编，会将重复执行的”hot code”编译为本地机器码，极大增加效率。所以benchmark实现的purity也有被一定程度的干扰。不过好在测试实例都是在相同环境下执行。</p>
<p>所以源码中，此处性能优化上的2倍数值，我持一定的保留态度。</p>
<h3 id="addListener实现"><a href="#addListener实现" class="headerlink" title="addListener实现"></a>addListener实现</h3><p><a href="https://github.com/HOUCe/eventEmitter/blob/master/src/common/event/node-eventEmitter.js" target="_blank" rel="external">经过整理，适当删减后的源码点击这里查看</a>，保留了我的注释。我们来一步一步解读下源码。</p>
<p>判断添加的监听器是否为函数类型，使用了typeof进行验证：</p>
<pre><code>if (typeof listener !== &apos;function&apos;) {
    throw new TypeError(&apos;&quot;listener&quot; argument must be a function&apos;);
}
</code></pre><p>接下来，要分为几种情况。<br>case1:<br>判断_events表是否已经存在，如果不存在，则说明是第一次为eventEmitter实例添加事件和监听器，需要新创建_events：</p>
<pre><code>if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
} 
</code></pre><p>还记得EventHandlers是什么吗？忘记了把屏幕往上滚动再看一下吧。</p>
<p>同时，添加指定的事件和此事件对应的监听器：</p>
<pre><code>existing = events[type] = listener;
++target._eventsCount;
</code></pre><p>注意第一次创建时，为了节省内存，提高性能，events[type]值是一个监听器函数。如果再次为相同的events[type]添加监听器时（下面case2），events[type]对应的值需要变成一个数组来存储。</p>
<p>case2:<br>又啰嗦一遍：如果_events已存在，在为相关事件添加监听器时，需要判断events[type]是函数类型（只存在一个监听函数）还是已经成为了一个数组类型（已经存在一个以上监听函数）。<br>并且根据相关参数prepend，分为监听器数组头部插入和尾部插入两种情况，以保证监听器的顺序执行：</p>
<pre><code>if (typeof existing === &apos;function&apos;) {
    existing = events[type] = prepend ? [listener, existing] :
                                      [existing, listener];
} 
else {
    if (prepend) {
        existing.unshift(listener);
    } 
    else {
        existing.push(listener);
    }
}
</code></pre><p>case3:<br>在阅读源码时，我还发现了一个很“诡异”的逻辑：</p>
<pre><code> if (events.newListener) {
    target.emit(&apos;newListener&apos;, type,
              listener.listener ? listener.listener : listener);
    events = target._events;
}
existing = events[type];
</code></pre><p>仔细分析，他的目的是因为nodeJS默认：当所有的eventEmitter对象在添加新的监听函数时，都会发出newListener事件。这其实也并不奇怪，我个人认为这么设计还是非常合理的。</p>
<p>cae4:<br>之前介绍了我们可以设置一个事件对应的最大监听器个数，nodeJS源码中通过这样的代码来实现：</p>
<pre><code>EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== &apos;number&apos; || n &lt; 0 || isNaN(n)) {
        throw new TypeError(&apos;&quot;n&quot; argument must be a positive number&apos;);
    }
    this._maxListeners = n;
    return this;
};
</code></pre><p>当对这个值进行了设置之后，如果超过此阈值，将会进行报警：</p>
<pre><code>if (!existing.warned) {
    m = $getMaxListeners(target);
    if (m &amp;&amp; m &gt; 0 &amp;&amp; existing.length &gt; m) {
        existing.warned = true;
        const w = new Error(&apos;Possible EventEmitter memory leak detected. &apos; +
                            `${existing.length} ${String(type)} listeners ` +
                            &apos;added. Use emitter.setMaxListeners() to &apos; +
                            &apos;increase limit&apos;);
        w.name = &apos;MaxListenersExceededWarning&apos;;
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        process.emitWarning(w);
    }
}
</code></pre><h3 id="emit发射器实现"><a href="#emit发射器实现" class="headerlink" title="emit发射器实现"></a>emit发射器实现</h3><p>有了之前的注册监听器过程，那么我们再来看看监听器是如何被触发的。其实触发过程直观上并不难理解，核心思想就是将监听器数组中的每一项，即监听函数逐个执行就好了。</p>
<p><a href="https://github.com/HOUCe/eventEmitter/blob/master/src/common/event/node-eventEmitter.js" target="_blank" rel="external">经过整理，适当删减后的源码</a>同样可以这里找到。源码中，包含了较多的错误信息处理内容，忽略不表。下面我挑出一些“出神入化”的细节来分析。</p>
<p>首先，有了上面的分析，我们现在可以清晰的意识到某个事件的监听处理可能是一个函数类型，表示该事件只有一个事件处理程序；也可能是个数组，表示该事件有多个事件处理程序，存储在监听器数组中。（我又啰嗦了一遍，因为理解这个太重要了，不然你会看晕的）</p>
<p>同时，emit方法可以接受多个参数。第一个参数为事件类型：type，下面两行代码用于获取某个事件的监听处理类型。用isFn布尔值来表示。</p>
<pre><code>handler = events[type];
var isFn = typeof handler === &apos;function&apos;;
</code></pre><p>isFn为true，表示该事件只有一个监听函数。否则，存在多个，储存在数组中。</p>
<p>源码中对于emit参数个数有判断，并进行了switch分支处理：</p>
<pre><code>switch (len) {
    case 1:
        emitNone(handler, isFn, this);
        break;
    case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
    case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
    case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
    // slower
    default:
        args = new Array(len - 1);
        for (i = 1; i &lt; len; i++) {
            args[i - 1] = arguments[i];
        }
        emitMany(handler, isFn, this, args);
}
</code></pre><p>我们挑一个相对最复杂的看一下——默认模式调用的emitMany：</p>
<pre><code>function emitMany(handler, isFn, self, args) {
    if (isFn) {
        handler.apply(self, args);
    }
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i &lt; len; ++i) {
            listeners[i].apply(self, args);
        }
    }
}
</code></pre><p>对于只有一个事件处理程序的情况（isFn为true），直接执行：</p>
<pre><code>handler.apply(self, args);
</code></pre><p>否则，便使用for循环，逐个调用：</p>
<pre><code>listeners[i].apply(self, args);
</code></pre><p>非常有意思的一个细节在于：</p>
<pre><code>var listeners = arrayClone(handler, len);
</code></pre><p>这里需要读者细心体会。<br>源码读到这里，我不禁要感叹设计的严谨精妙之处。上面代码处理的意义在于：防止在一个事件监听器中监听同一个事件，从而导致死循环的出现。<br>如果您不理解，且看我这个例子：</p>
<pre><code>let emitter = new eventEmitter;
emitter.on(&apos;message1&apos;, function test () {
    // some codes here
    // ...
    emitter.on(&apos;message1&apos;, test}
});
emit(&apos;message1&apos;);
</code></pre><p>讲道理，正常来讲，不经过任何处理，上述代码在事件处理程序内部又添加了对于同一个事件的监听，这必然会带来死循环问题。<br>因为在emit执行处理程序的时候，我们又向监听器队列添加了一项。这一项执行时，又会“子子孙孙无穷匮也”的向后添加。</p>
<p>源码中对于这个问题的解决方案是：在执行emit方法时，使用arrayClone方法拷贝出另一个一模一样的数组，进而执行它。这样一来，当我们在监听器内监听同一个事件时，的确给原监听器数组添加了新的函数，但并没有影响到当前这个被拷贝出来的副本数组。在循环中，我们执行的也是这个副本函数。</p>
<h3 id="单次监听器once实现"><a href="#单次监听器once实现" class="headerlink" title="单次监听器once实现"></a>单次监听器once实现</h3><p>once(event, listener)是为指定事件注册一个单次事件处理程序，即监听器最多只会触发一次，触发后立刻解除该监听器。</p>
<p>实现方式主要是在进行监听器绑定时，对于监听函数进行一层包装。该包装方式在原有函数上添加一个flag标识位，并在触发监听函数前就调用removeListener()方法，除掉此监听函数。</p>
<p>代码里，我们可以抽丝剥茧（已进行删减）学习一下：</p>
<pre><code> EventEmitter.prototype.once = function once(type, listener) {
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
</code></pre><p>once方法调用on方法（即addListener方法，on为别名），第二个参数即监听程序进行_onceWrap化包装，包装过程为：</p>
<pre><code>this.target.removeListener(this.type, this.wrapFn);
if (!this.fired) {
    this.fired = true;
    this.listener.apply(this.target, arguments);
}
</code></pre><p>_onceWrap化的主要思想是将once第二个参数listener的执行：</p>
<pre><code>this.listener.apply(this.target, arguments);
</code></pre><p>包上了一次判断，并在执行前进行removeListener删除该监听程序。</p>
<h3 id="removeListener的惊鸿一瞥"><a href="#removeListener的惊鸿一瞥" class="headerlink" title="removeListener的惊鸿一瞥"></a>removeListener的惊鸿一瞥</h3><p>removeListener(type, listener)移除指定事件的某个监听器。其实这个实现思路也比较容易理解，我们已经知道events[type]可能是函数类型，也可能是数组类型。如果是数组类型，只需要进行遍历，找到相关的监听器进行删除就可以了。</p>
<p>不过关键问题就在于对数组项的删除。</p>
<p>平时开发，我们常用splice进行数组中某一项的删除，99％的case都会想到这个方法。可是nodeJS相关源码中，对于删除进行了优化。自己封装了一个spliceOne方法，用于删除数组中指定角标。并且号称这个方法比使用splice要快1.5倍。我们就来看一下他是如何实现的：</p>
<pre><code>function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k &lt; n; i += 1, k += 1) {
        list[i] = list[k];
        list.pop();
    }
}
</code></pre><p>传统删除方法：</p>
<pre><code>list.splice(index, 1);
</code></pre><p>究竟是否计算更快，我也实现了一个benchmark，产生长度为1000的数组，删除其第52项。反复执行1000次求平均耗时:</p>
<pre><code>let arr = Array.from(Array(100).keys());
for (let i = 0; i &lt; 1000; i++) {
    window.performance.mark(&apos;test splice start&apos;);
    arr.splice(52, 1);
    window.performance.mark(&apos;test splice end&apos;);
    window.performance.measure(&apos;test splice&apos;,&apos;test splice start&apos;,&apos;test splice end&apos;);
}
let sum1 = 0
for (let k = 0; k &lt; 1000; k++) {
    sum1 +=window.performance.getEntriesByName(&apos;test splice&apos;)[k].duration
}
let averge1 = sum1/1000;
console.log(averge1*1000); // 1.7749999999869034


let arr = Array.from(Array(100).keys());
for (let i = 0; i &lt; 1000; i++) {
    window.performance.mark(&apos;test splice start&apos;);
    spliceOne(arr, 52);
    window.performance.mark(&apos;test splice end&apos;);
    window.performance.measure(&apos;test splice&apos;,&apos;test splice start&apos;,&apos;test splice end&apos;);
}
let sum1 = 0
for (let k = 0; k &lt; 1000; k++) {
    sum1 +=window.performance.getEntriesByName(&apos;test splice&apos;)[k].duration
}
let averge1 = sum1/1000;
console.log(averge1*1000); // 1.5350000000089494
</code></pre><p>明显使用spliceOne方法更快，时间上缩短了13.5%，不过依然没有达到官方的1.5，需要说明的是我采用最新版本的Chrome进行测试，和官方环境存在偏差。</p>
<h2 id="自己造轮子"><a href="#自己造轮子" class="headerlink" title="自己造轮子"></a>自己造轮子</h2><p>前文我们感受了nodeJS中的eventEmitter实现方式。我也对于其中的核心方法，在源码层面进行了剖析。学习到了“精华”之后，更重要的要学以致用，自己实现一个基于ES6的事件发布订阅系统。</p>
<p>我的实现版本中充分利用了ES6语法特性，并且相对于nodeJS实现减少了一些“不必要的”优化和判断。</p>
<p>因为nodeJS的实现其实里，很多api在前端浏览器环境开发中并用不到。所以我对对外暴露的方法进行了精简。最终实现上，除去注释部分，只用了不到40行代码。如果您有兴趣，可以去<a href="">代码仓库</a>访问，整个逻辑还是很简单的。</p>
<p>里面同时附赠了我同事@颜海镜大神基于zepto实现版本，以及nodeJS events模块源码，方便读者进行对比。<br>整个过程编写时间仓促，其中必然不乏疏漏之处，还请您斧正并与我讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于nodeJS源码events模块的阅读，令我受益匪浅。设计层面上，优秀的包装和抽象对我一定的启发；实现层面上，很多“意想不到”的case处理，让我“叹为观止”。<br>虽然业务上暂时使用不到nodeJS，但是对于每一个前端开发人员来说，这样的学习我认为是有必要的。今后，我会整理出文章，总结对nodeJS源码更多模块的分析，希望读者能够保持交流和探讨。<br>整篇文章里面出的benchmark，我认为并不完美。同时，对于浏览器引擎处理上，我存在知识盲点和漏斗，希望有大神给与斧正。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，nodeJS改变了整个前端开发生态。本文通过分析nodeJS当中events模块源码，由浅入深实现了属于自己的ES6事件观察者系统。千万不要被nodeJS的外表吓到，不管你是写nodeJS已经轻车熟路的老司机，还是初入前端的小菜鸟，都不妨碍对这篇文章的阅读和理解。
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第11001期</title>
    <link href="https://exp-team.github.io/blog/2017/03/17/weekly/weekly-11001/"/>
    <id>https://exp-team.github.io/blog/2017/03/17/weekly/weekly-11001/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-18T06:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>3.13-3.17，程序员不该互相鄙视</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="程序员不该互相鄙视"><a href="#程序员不该互相鄙视" class="headerlink" title="程序员不该互相鄙视"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713089&amp;idx=1&amp;sn=d9f72a559f82518c86995e70ac66e109&amp;chksm=bec0625289b7eb44461d6bcd42d27dad0c7bbfd1cbc6afab6543018a93683ab20d490210b2d6&amp;mpshare=1&amp;scene=1&amp;srcid=0316Raw0IUByU6Hhwd4P0xmw#rd" target="_blank" rel="external">程序员不该互相鄙视</a></h3><p>虽然前端处于鄙视链的末端，但是我们提议程序员不应该互相鄙视</p>
<h3 id="2017前端工具趋势"><a href="#2017前端工具趋势" class="headerlink" title="2017前端工具趋势"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226220&amp;idx=1&amp;sn=91a135e3b6ce38753fae9bd60a14203f&amp;chksm=bd4959e88a3ed0fe4ad3388af8887506619f35b7fd83fa36d8b9b9ee02bc69182b2f05a1e2c8&amp;mpshare=1&amp;scene=1&amp;srcid=0317pJQS7a64bbUl9eoEzzFW#rd" target="_blank" rel="external">2017前端工具趋势</a></h3><p>工欲善其事必先利其器，2017年了你在使用什么工具？</p>
<h3 id="2016-年崛起的-JS-项目"><a href="#2016-年崛起的-JS-项目" class="headerlink" title="2016 年崛起的 JS 项目"></a><a href="https://zhuanlan.zhihu.com/p/25709238" target="_blank" rel="external">2016 年崛起的 JS 项目</a></h3><p>2016是前端飞速发展的一年，这一年诞生了一大批前端项目，错过的同学看这一篇文章就足够了</p>
<a id="more"></a>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="Source-Map入门教程"><a href="#Source-Map入门教程" class="headerlink" title="Source Map入门教程"></a><a href="https://blog.fundebug.com/2017/03/13/sourcemap-tutorial/" target="_blank" rel="external">Source Map入门教程</a></h3><h3 id="理解关键渲染路径"><a href="#理解关键渲染路径" class="headerlink" title="理解关键渲染路径"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226203&amp;idx=1&amp;sn=c9a13663431d49b408af023766b6456f&amp;chksm=bd4959df8a3ed0c9c2173d58ea35252d72e10c30f1bf2944a969e7c6ebccae8b0340878eb611&amp;mpshare=1&amp;scene=1&amp;srcid=0316zVMVLQ2vDP4XgzOoXIfa#rd" target="_blank" rel="external">理解关键渲染路径</a></h3><h3 id="LsLoader-移动WEB工程化缓存方案"><a href="#LsLoader-移动WEB工程化缓存方案" class="headerlink" title="LsLoader 移动WEB工程化缓存方案"></a><a href="https://zhuanlan.zhihu.com/p/21357211?utm_source=wechat_session&amp;utm_medium=social" target="_blank" rel="external">LsLoader 移动WEB工程化缓存方案</a></h3><h3 id="Effective前端7：加快页面打开速度"><a href="#Effective前端7：加快页面打开速度" class="headerlink" title="Effective前端7：加快页面打开速度"></a><a href="https://zhuanlan.zhihu.com/p/25718817" target="_blank" rel="external">Effective前端7：加快页面打开速度</a></h3><p>这个系列特别好，强烈建议大家读一读</p>
<h3 id="面试中要注意的-3-个-JavaScript-问题"><a href="#面试中要注意的-3-个-JavaScript-问题" class="headerlink" title="面试中要注意的 3 个 JavaScript 问题"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964369&amp;idx=1&amp;sn=167ca080a10c5cab77432f8d8ee4ccb9&amp;chksm=843aedf7b34d64e1c325bab612cdf174b86ca587d4114fd4c2120640ecc1fa62d8b50bd847ec&amp;mpshare=1&amp;scene=1&amp;srcid=0315uSE7TjEwyIv6f8ZaJ4mj#rd" target="_blank" rel="external">面试中要注意的 3 个 JavaScript 问题</a></h3><p>最近面试中我都会问这三个问题</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="如何落地和管理一个“大前端”团队-饿了么大前端团队解密"><a href="#如何落地和管理一个“大前端”团队-饿了么大前端团队解密" class="headerlink" title="如何落地和管理一个“大前端”团队?饿了么大前端团队解密"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650995610&amp;idx=1&amp;sn=d44ad482dc30a3eae727571f2630a348&amp;chksm=bdbf03c98ac88adf41c06ed5cde7378adc4796d4426b7e61bd3c17aaa675f2dc5eaaf0c14a2e&amp;mpshare=1&amp;scene=1&amp;srcid=03154V3qyLs6nGka4qfTTTMX#rd" target="_blank" rel="external">如何落地和管理一个“大前端”团队?饿了么大前端团队解密</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3.13-3.17，程序员不该互相鄙视&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;程序员不该互相鄙视&quot;&gt;&lt;a href=&quot;#程序员不该互相鄙视&quot; class=&quot;headerlink&quot; title=&quot;程序员不该互相鄙视&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650713089&amp;amp;idx=1&amp;amp;sn=d9f72a559f82518c86995e70ac66e109&amp;amp;chksm=bec0625289b7eb44461d6bcd42d27dad0c7bbfd1cbc6afab6543018a93683ab20d490210b2d6&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0316Raw0IUByU6Hhwd4P0xmw#rd&quot;&gt;程序员不该互相鄙视&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;虽然前端处于鄙视链的末端，但是我们提议程序员不应该互相鄙视&lt;/p&gt;
&lt;h3 id=&quot;2017前端工具趋势&quot;&gt;&lt;a href=&quot;#2017前端工具趋势&quot; class=&quot;headerlink&quot; title=&quot;2017前端工具趋势&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651226220&amp;amp;idx=1&amp;amp;sn=91a135e3b6ce38753fae9bd60a14203f&amp;amp;chksm=bd4959e88a3ed0fe4ad3388af8887506619f35b7fd83fa36d8b9b9ee02bc69182b2f05a1e2c8&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0317pJQS7a64bbUl9eoEzzFW#rd&quot;&gt;2017前端工具趋势&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;工欲善其事必先利其器，2017年了你在使用什么工具？&lt;/p&gt;
&lt;h3 id=&quot;2016-年崛起的-JS-项目&quot;&gt;&lt;a href=&quot;#2016-年崛起的-JS-项目&quot; class=&quot;headerlink&quot; title=&quot;2016 年崛起的 JS 项目&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25709238&quot;&gt;2016 年崛起的 JS 项目&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;2016是前端飞速发展的一年，这一年诞生了一大批前端项目，错过的同学看这一篇文章就足够了&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你撸一个跑男动画 顺便抽丝剥茧CSS3动画奥秘</title>
    <link href="https://exp-team.github.io/blog/2017/03/14/web/animation-runningman/"/>
    <id>https://exp-team.github.io/blog/2017/03/14/web/animation-runningman/</id>
    <published>2017-03-13T16:00:00.000Z</published>
    <updated>2017-03-14T06:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名真正的前端开发者，我们不能只关注前端逻辑部分。毕竟“水银泄地”般的页面设计和“炫酷逼真”的动画效果，是我们区别于其他程序员所特有的优势之一。尽量百分之百的还原视觉稿，为UE设计灵感和用户视觉享受架起一座桥梁：正所谓“晋帝时祭北郊，更祝版，工人削之，笔入木三分。”<br>借古书法形容我们的代码，当真是恰当准确又自恋无比。</p>
<p>之前的一些文章大多都是分享JS相关内容。今天轻松一下，我来谈谈前端页面的动画部分。通过剖析一个上线的“跑男”动画实例，来把CSS3中动画相关的知识点抽丝剥茧，一网打尽。如果读者有自己的感想或者不一样的见解，欢迎一起讨论。</p>
<p>整个项目的<a href="https://github.com/HOUCe/runningman-animation" target="_blank" rel="external">Github地址</a>可以参考<a href="https://github.com/HOUCe/runningman-animation" target="_blank" rel="external">这里</a>。对比线上效果，这个仓库进行了90%的删减，但是更加适合练手和理解。感兴趣的读者欢迎拉下来自己玩一玩。里面只有一关动画，您可以比葫芦画瓢进行调试练习。</p>
<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>这是一个运营活动页面——“春季马拉松大比拼”：用户以闯关形式参加，并进行角色扮演。在满足一定条件下，自己扮演的马拉松选手会绕着跑道（非正规跑道形状）前进，向终点发起冲击。</p>
<p>部分页面动画效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-cabc0a036d80d926.gif?imageMogr2/auto-orient/strip" alt="部分动画效果截图"></p>
<p>当然，这个动画并不完美。考虑到时间性价比，我只用了两帧重复循环模拟摆腿动作。但也达到了运营和产品小妹的需求。如果在没有上线压力的情况下，我们完全可以拆分更多帧，把他打磨的更流畅顺滑。</p>
<p>首先，我们来看一下它的具体实现方式吧。如果您觉得很简单，也可以往下读，相信你也会有不一样的收获。</p>
<h2 id="动画方案"><a href="#动画方案" class="headerlink" title="动画方案"></a>动画方案</h2><p>这一系列的动画设计，出于性能和简单的考虑，我采用了纯CSS3来实现。CSS3实现动画，主要有两种方式：transition属性和animation属性。前者是用来“平滑的改变CSS的值”。一般对于需要特定帧处理的动画，这显然是苍白无力的。我就不过多介绍了。这里重点介绍一下animation属性。</p>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation属性其实是一个简写属性，就像我们更加熟悉的“background”属性一样。它用于设置六个动画属性：</p>
<p>1）animation-name<br>2）animation-duration<br>3）animation-timing-function<br>4）animation-delay<br>5）animation-iteration-count<br>6）animation-direction</p>
<p>最重要的就是animation-name，它规定需要绑定的keyframes名称。keyframes，我们用来定义几个关键节点帧。</p>
<p>具体我不会进行科普。如果初学者不了解，社区上关于这些的资料可是一大把。</p>
<h3 id="跑男开跑"><a href="#跑男开跑" class="headerlink" title="跑男开跑"></a>跑男开跑</h3><p>回到我们具体的业务场景，我们进行分析。跑男的动画其实可以拆分为两种：<br>1）一个是交替摆腿；<br>2）另一个是位置移动。<br>这两个动作要严丝合缝的结合。能把这个想清楚，那就基本思路理解了。</p>
<p>接着，如何让这两种动画一起施加在“静止的”跑男身上呢？</p>
<p>我采用了增加一个div标签包裹的方式：</p>
<pre><code>&lt;div class=&quot;man-wrapper&quot; id=&quot;man-wrapper&quot;&gt;
    &lt;div class=&quot;man&quot; id=&quot;man&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>‘man-wrapper’这个div与’man’这个div尺寸大小完全一致，视觉上绝对重合。父节点处理位移，子节点负责交替摆腿：</p>
<pre><code>.man-wrapper {
    display: inline-block;
    width: 46px;
    height: 75px;
    position: absolute;
}
.man {
    display: inline-block;
    width: 46px;
    height: 75px;
    background: url(img/sprite.png);
    position: absolute;
    top: 0;
    left: 0;
}
</code></pre><p>当需要触发位移，开启跑步状态时，父节点添”start-run”类：</p>
<pre><code>$(&apos;.man-wrapper&apos;).addClass(&apos;start-run&apos;);
</code></pre><p>子节点添加：</p>
<pre><code>$(&apos;#man&apos;).addClass(&apos;running&apos;);
</code></pre><h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><p>关于“start-run”位移的动画设计，在跑道上直道部分相对简单，我们思路是使用transform：translate3d。但是视觉稿上存在不少于5处不规则弯道，在不改变原图的基础上，在不增加多余图片的原则下，我们可以使用transform：rotate3d，使跑男进行侧身。具体设计看下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-22e1cfcd31e6b7e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画部分分解"></p>
<p>1）1-2和4-5，只需要改变transform：translate3d；<br>2）2-4部分，即2，3，4这三个阶段是为了弯道准备的。当然，如果时间充足，我们完全可以拆分的更加细致，更加细分。<br>3）其中3是弯道中心的45度转身：rotate3d(0,0,1,45deg);<br>4）其中4是已经完全转身：rotate3d(0,0,1,90deg);</p>
<p>具体代码：</p>
<pre><code>.start-run {
    animation: start-run 5000ms; 
    animation-fill-mode: forwards;
    animation-timing-function: linear;
}
@keyframes start-run {
    0% {
        transform: translate3d(0, 0, 0);
    }
    35% {
        transform: translate3d(0, 155px, 0) rotate3d(0, 0, 1, 0deg);
    }
    50% {
        transform: translate3d(20px, 224px, 0) rotate3d(0, 0, 1, -45deg);
    }
    70% {
        transform: translate3d(80px, 242px, 0) rotate3d(0, 0, 1, -90deg);
    }
    100% {
        transform: translate3d(200px, 243px, 0) rotate3d(0, 0, 1, -90deg);
    }
}
</code></pre><p>为什么是35%，50%，70%呢？这个是我调试出来，相对能达到顺畅效果。如果追求更严谨的话，完全可以列一个极坐标计算一下位移和时间。当然这样子成本会比较大。</p>
<p>还有一点值得一提的是animation-timing-function: linear; 一般马拉松中段，都近似于匀速跑吧～</p>
<p>解决完了位移的问题，我们来看摆腿动作。这个其实就是两张图片在交替播放。其实就是gif图原理。我使用了background-position来切换精灵图片的方式处理：</p>
<pre><code>.running {
    animation: running-man 1200ms steps(2) infinite;
}
@keyframes running-man {
    0% {
        background-position: 0 0;
    }
    50% {
        background-position: 92px 0;
    }
}
</code></pre><p>千万不要扫一眼代码完事儿，这里还有一些最重要的细节要注意。首先是“infinite”的使用，这个应该没什么意外吧。另外，你可曾注意了steps这个函数?</p>
<h3 id="steps-函数实现阶跃动画"><a href="#steps-函数实现阶跃动画" class="headerlink" title="steps()函数实现阶跃动画"></a>steps()函数实现阶跃动画</h3><p>我们知道animation定义的关键帧之间是“平滑过渡”的。这个平滑过渡怎么理解呢？我精心做了一个“反例”示图来说明：<br>在使用keyframes改变雪碧图background-position时，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-de26aeaa8879fa44.gif?imageMogr2/auto-orient/strip" alt="动画部分分解反面示例"></p>
<p>这样的”平滑过度”显然不是我们想要的。</p>
<p>所以，在切换雪碧图背景的方案下，steps()就要派上用场了。顺便说一句，最近面试一些人，提到熟悉CSS3动画，但是大部分都还不知道这个steps阶跃函数。如果你还不清楚，可以参考<a href="http://www.cnblogs.com/BATAKK/p/5301819.html" target="_blank" rel="external">这里。</a></p>
<p>借助steps()函数，我们实现了交替跑动的分解动画：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-4cd1498e2f1c9504.gif?imageMogr2/auto-orient/strip" alt="动画部分分解"></p>
<h2 id="还不完美"><a href="#还不完美" class="headerlink" title="还不完美"></a>还不完美</h2><p>做到这里，其实还没有完全结束。有一些值得我们思考的问题。</p>
<p>1）真的有必要多一个标签，来相互结合生成动画吗？<br>其实不是的，animation很神奇很强大的一点在于：它可以接受多个动画属性序列。比如上边那种情况我们完全可以这样实现：</p>
<pre><code>.running {
    animation: start-run 5000ms forwards linear, running-man 1200ms steps(2) infinite
}
</code></pre><p>2) 如果刻意追求更佳完美的动画，我们还需要哪些储备？<br>不得不要说知识储备上，就是数学和物理知识了。比如，二次方曲线、三次方曲线、一直到五次方曲线，正弦余弦、圆弧、抛物线、反弹曲线、弹簧曲线等等。如果你对研究这些有兴趣，这里安利一些：<a href="https://greensock.com/" target="_blank" rel="external">高性能动画实现</a>以及<a href="https://greensock.com/ease-visualizer" target="_blank" rel="external">可视化1</a>，<a href="http://jeremyckahn.github.io/stylie/" target="_blank" rel="external">可视化2。</a></p>
<p>除了数学公式以外，也需要我们掌握样式预处理器函数使用。毕竟，那么多帧我们不可能自己手动实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>流畅高效的动画，绝非一朝一夕就能完成，需要各方面甚至跨领域的积累。如果你对此很感兴趣，欢迎讨论。我也在工作过程中，积累了很多动画实现效果，愿意同大家一起分享，互通资源。</p>
<p>最后，这篇文章中截图部分采用了我厂（狼厂）UE：许冬设计师的视觉稿，和PM：田小甜大小姐的交互设计。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名真正的前端开发者，我们不能只关注前端逻辑部分。毕竟“水银泄地”般的页面设计和“炫酷逼真”的动画效果，是我们区别于其他程序员所特有的优势之一。尽量百分之百的还原视觉稿，为UE设计灵感和用户视觉享受架起一座桥梁：正所谓“晋帝时祭北郊，更祝版，工人削之，笔入木三分。”&lt;b
    
    </summary>
    
      <category term="web" scheme="https://exp-team.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://exp-team.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第11000期</title>
    <link href="https://exp-team.github.io/blog/2017/03/10/weekly/weekly-11000/"/>
    <id>https://exp-team.github.io/blog/2017/03/10/weekly/weekly-11000/</id>
    <published>2017-03-09T16:00:00.000Z</published>
    <updated>2017-03-11T16:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>3.6-3.10，你的前端工作经验值钱吗？</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="为什么你的前端工作经验不值钱？"><a href="#为什么你的前端工作经验不值钱？" class="headerlink" title="为什么你的前端工作经验不值钱？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzI3NzIzMDY0NA==&amp;mid=2247484101&amp;idx=1&amp;sn=6b095010810a9dfa0c134fa9d116c1ce&amp;chksm=eb68279edc1fae8847b479592461a9f62136ac2c5b5047baaf82d0f2c63a3f67bbb643a3a887&amp;mpshare=1&amp;scene=1&amp;srcid=030683oKsqW95apeyMRaqppM" target="_blank" rel="external">为什么你的前端工作经验不值钱？</a></h3><p>之前看过一本书叫做《技巧》，里面提到有些人不是有10年工作经验，而是把1年的工作经验用了10年，永远不要停止学习，永远不要待在舒适区</p>
<h3 id="前端开发者应知必会：浏览器是如何渲染网页的"><a href="#前端开发者应知必会：浏览器是如何渲染网页的" class="headerlink" title="前端开发者应知必会：浏览器是如何渲染网页的"></a><a href="https://zhuanlan.zhihu.com/p/25554352" target="_blank" rel="external">前端开发者应知必会：浏览器是如何渲染网页的</a></h3><p>每次看都会有收获，温故而知新</p>
<h3 id="如何用-fis3-来开发-React"><a href="#如何用-fis3-来开发-React" class="headerlink" title="如何用 fis3 来开发 React?"></a><a href="http://fex.baidu.com/blog/2016/04/develop-react-with-fis3/" target="_blank" rel="external">如何用 fis3 来开发 React?</a></h3><p>最近的一个项目中用上了react，觉得这个有点意思，那么fis3下开发react也是蛮爽的</p>
<a id="more"></a>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="HTML不能这么写、你造吗？"><a href="#HTML不能这么写、你造吗？" class="headerlink" title="HTML不能这么写、你造吗？"></a><a href="https://zhuanlan.zhihu.com/p/25410484?utm_source=wechat_session&amp;utm_medium=social" target="_blank" rel="external">HTML不能这么写、你造吗？</a></h3><p>html5中元素不再只有块级和行内，嵌套规则也变得需要表格来维护了</p>
<h3 id="五分钟-get-你也许不知道的前端新特性"><a href="#五分钟-get-你也许不知道的前端新特性" class="headerlink" title="五分钟 get 你也许不知道的前端新特性"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964364&amp;idx=1&amp;sn=6ac57a2111cbc3bc042d85650278c83c&amp;chksm=843aedeab34d64fc93d629315b02995a3aabb891f83116afa26b9a6e5d85630ed3aed6072309&amp;mpshare=1&amp;scene=1&amp;srcid=0309RHflqTapJLuCvi9PTOiE" target="_blank" rel="external">五分钟 get 你也许不知道的前端新特性</a></h3><h3 id="不止-React-Native、Ionic、Weex，连-Objective-C-的开发者都收到警告邮件了"><a href="#不止-React-Native、Ionic、Weex，连-Objective-C-的开发者都收到警告邮件了" class="headerlink" title="不止 React Native、Ionic、Weex，连 Objective-C 的开发者都收到警告邮件了"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&amp;mid=2652974732&amp;idx=1&amp;sn=3462a3ca8a2f10e645be76f922c7e8c2&amp;chksm=bd4afdaf8a3d74b96bb748af53ad721e826251228efc45b23fabc14f5dfe20f3d1e252f633bf&amp;mpshare=1&amp;scene=1&amp;srcid=0308Shw8MOXxeRrjzdcV4G3o" target="_blank" rel="external">不止 React Native、Ionic、Weex，连 Objective-C 的开发者都收到警告邮件了</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="作为一个面试官，我是怎么来面试测试人员的"><a href="#作为一个面试官，我是怎么来面试测试人员的" class="headerlink" title="作为一个面试官，我是怎么来面试测试人员的"></a><a href="https://zhuanlan.zhihu.com/p/25516083?utm_medium=social&amp;utm_source=wechat_session&amp;from=singlemessage" target="_blank" rel="external">作为一个面试官，我是怎么来面试测试人员的</a></h3><p>最近也面试了不少人，一直都在</p>
<h3 id="人到中年，我就问你怕不怕？"><a href="#人到中年，我就问你怕不怕？" class="headerlink" title="人到中年，我就问你怕不怕？"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713067&amp;idx=1&amp;sn=81459616b22059bc743a3be5911156f4&amp;chksm=bec065b889b7ecae7cf84110f5f03935e59dd4cd815cb4918489bfd3092367e444b70a9b4fd5&amp;mpshare=1&amp;scene=1&amp;srcid=0307rNX7bl8qGHZbRBF9kKby" target="_blank" rel="external">人到中年，我就问你怕不怕？</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3.6-3.10，你的前端工作经验值钱吗？&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;为什么你的前端工作经验不值钱？&quot;&gt;&lt;a href=&quot;#为什么你的前端工作经验不值钱？&quot; class=&quot;headerlink&quot; title=&quot;为什么你的前端工作经验不值钱？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3NzIzMDY0NA==&amp;amp;mid=2247484101&amp;amp;idx=1&amp;amp;sn=6b095010810a9dfa0c134fa9d116c1ce&amp;amp;chksm=eb68279edc1fae8847b479592461a9f62136ac2c5b5047baaf82d0f2c63a3f67bbb643a3a887&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=030683oKsqW95apeyMRaqppM&quot;&gt;为什么你的前端工作经验不值钱？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;之前看过一本书叫做《技巧》，里面提到有些人不是有10年工作经验，而是把1年的工作经验用了10年，永远不要停止学习，永远不要待在舒适区&lt;/p&gt;
&lt;h3 id=&quot;前端开发者应知必会：浏览器是如何渲染网页的&quot;&gt;&lt;a href=&quot;#前端开发者应知必会：浏览器是如何渲染网页的&quot; class=&quot;headerlink&quot; title=&quot;前端开发者应知必会：浏览器是如何渲染网页的&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25554352&quot;&gt;前端开发者应知必会：浏览器是如何渲染网页的&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;每次看都会有收获，温故而知新&lt;/p&gt;
&lt;h3 id=&quot;如何用-fis3-来开发-React&quot;&gt;&lt;a href=&quot;#如何用-fis3-来开发-React&quot; class=&quot;headerlink&quot; title=&quot;如何用 fis3 来开发 React?&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://fex.baidu.com/blog/2016/04/develop-react-with-fis3/&quot;&gt;如何用 fis3 来开发 React?&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;最近的一个项目中用上了react，觉得这个有点意思，那么fis3下开发react也是蛮爽的&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>面试题目别有洞天 -&gt; 从es6优雅解法，到降级polyfill，再到redux reducer迷之命名</title>
    <link href="https://exp-team.github.io/blog/2017/03/09/js/reduce/"/>
    <id>https://exp-team.github.io/blog/2017/03/09/js/reduce/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2017-03-09T12:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前的<a href="http://www.jianshu.com/p/6958f99db769" target="_blank" rel="external">一篇文章：从一道面试题，到“我可能看了假源码”</a>讨论了bind方法的各种进阶Pollyfill，今天再分享一个有意思的题目。</p>
<p>从解这道题目出发，我会谈到数组的Reduce方法，ES6特性和Redux数据流框架中Reducer的命名等等。一道典型的题目，却如唐代诗人章碣《对月》诗中所云：“别有洞天三十六，水晶台殿冷层层。”</p>
<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>完成一个’flatten’的函数，实现“拍平”一个多维数组为一维。示例如下：</p>
<pre><code>var testArr1 = [[0, 1], [2, 3], [4, 5]];
var testArr2 = [0, [1, [2, [3, [4, [5]]]]]];
flatten(testArr1) // [0, 1, 2, 3, 4, 5]
flatten(testArr2) // [0, 1, 2, 3, 4, 5]
</code></pre><h2 id="解法先睹为快"><a href="#解法先睹为快" class="headerlink" title="解法先睹为快"></a>解法先睹为快</h2><p>先看一眼比较优雅的ES6解法：</p>
<pre><code>const flatten = arr =&gt; arr.reduce((pre, val) =&gt; pre.concat(Array.isArray(val) ? flatten(val) : val), []);
</code></pre><p>如果你看不明白，不要放弃。我会用ES5的思路“翻译”一下，相信你很快就能看懂。</p>
<p>如果你一眼能看明白，也建议继续往下读。因为会有“不一样”的知识点。</p>
<h2 id="深入解读"><a href="#深入解读" class="headerlink" title="深入解读"></a>深入解读</h2><p>第一个想到的念头肯定是递归，递归自然就想到递归的“尽头”，那就要判断数组某项元素是否还是数组类型。<br>好吧，我们开始动手实现一个方案，其实是上面解法的ES5版本：</p>
<pre><code>var flatten = function(array) {
    return array.reduce(function(previous, val) {
        if (Object.prototype.toString.call(val) !== &apos;[object Array]&apos;) {
            return (previous.push(val), previous);
        }
        return (Array.prototype.push.apply(previous, flatten(val)), previous);
    }, []);
};
</code></pre><p>可能这样写，对于很多人来说，并不能完全理解。因为我们使用了较多JS高级用法。关键核心还用到了类似“函数式”思想的reduce方法。<br>千万不要灰心，继续往下看。</p>
<h3 id="return的到底是什么？"><a href="#return的到底是什么？" class="headerlink" title="return的到底是什么？"></a>return的到底是什么？</h3><p>我们注意到上面的写法return使用了（）表达式。括号内容前半句是为了执行。这样写也许稍微晦涩难懂一些。请看下面的代码示例，你就会明白：</p>
<pre><code>function t() {
    var a = 1;
    return (a++, a);
}
t(); // 2
</code></pre><h3 id="Object-prototype-toString-call是什么？"><a href="#Object-prototype-toString-call是什么？" class="headerlink" title="Object.prototype.toString.call是什么？"></a>Object.prototype.toString.call是什么？</h3><p>Object.prototype.toString.call可以暂且认为是“功能最强大”的类型判断语句。在对数组类型进行判断时，需要格外小心，比如这样几个“陷阱”：</p>
<pre><code>var a = [];
typeof a; // &quot;object&quot;
a instanceof Array; // true;
Object.prototype.toString.call(a); // &quot;[object Array]&quot;
</code></pre><h3 id="reduce方法到底做了什么？"><a href="#reduce方法到底做了什么？" class="headerlink" title="reduce方法到底做了什么？"></a>reduce方法到底做了什么？</h3><p>现在到了最关键的地方。reduce方法是ES5引入，很多人使用它的场景并不多。但是了解他的特性却是必须的。遗憾的是，社区上对于它的内容似乎都不是“太重视”。“函数式“思想也让一些初学者望而却步。这里我简要进行“科普”，因为下面我要围绕它进行延伸：</p>
<p>reduce在英文中译为“减少; 缩小; 使还原; 使变弱”，MDN对方法直述为：“The reduce method applies a function against an accumulator and each value of the array (from left-to-right) to reduce it to a single value.”<br>我并不打算对他直接翻译，因为这样会变的更加晦涩难懂。</p>
<p>我们看他的使用语法：</p>
<pre><code>array1.reduce(callbackfn[, initialValue])
</code></pre><p>参数分析：</p>
<p>1）array1：必需。<br>一个数组对象。即调用reduce方法的必须是一个数组类型。</p>
<p>2）callbackfn：必需。<br>一个接受最多四个参数的函数。对于数组中的每个元素，reduce方法都会调用 callbackfn 函数一次。<br>这个callback的4个参数为：</p>
<pre><code>accumulator // 上一次调用回调返回的值，或者是提供的初始值（initialValue）
currentValue // 数组中正在处理的元素
currentIndex // 数据中正在处理的元素索引，如果提供了initialValue ，从0开始；否则从1开始
array // 调用reduce的数组
</code></pre><p>3)initialValue可选项。<br>其值用于第一次调用callback的第一个参数。如果此参数为空，则拿数组第一项来作为第一次调用callback的第一个参数。</p>
<p>比如，我们分析一个常用用法：</p>
<pre><code>[0,1,2,3,4].reduce(function(previous, item, currentIndex, array){
  return previous + item;
});
// 10
</code></pre><p>这里并未提供reduce的第二个参数initialValue，所以从数组第一项开始进行回调函数的执行。并且每次回调函数执行完之后的结果，作为下一次的previous执行回调。</p>
<p>所以，上述代码便是一个累加器的实现。</p>
<h2 id="ES6写法"><a href="#ES6写法" class="headerlink" title="ES6写法"></a>ES6写法</h2><p>现在理解了Reduce函数，再结合ES6特性，使解法更加优雅：</p>
<pre><code>const flatten = arr =&gt; arr.reduce((pre, val) =&gt; pre.concat(Array.isArray(val) ? flatten(val) : val), []);
</code></pre><p>这样写是不是太“函数式”了，但是思路跟之前解法完全一样。我只不过充分使用了箭头函数带来的便利。并且使用了更便捷的isArray对数组类型进行判断。这是开篇提到的解法，也是MDN最新版的实现。</p>
<h2 id="如何实现一个reduce的pollyfill"><a href="#如何实现一个reduce的pollyfill" class="headerlink" title="如何实现一个reduce的pollyfill"></a>如何实现一个reduce的pollyfill</h2><p>现在明白了reduce的秘密，接下来我们需要充分发挥对JS的理解，来手动实现一个reduce函数。毕竟，reduce是ES5带来的数组新特性，在不使用ES5-shim的情况下，需要手动兼容。另外，其实reduce方法可以实现的逻辑，大多都能够使用循环来实现。但是了解这样一个优雅的方法，不管是在程序的可读性上，还是在设计理解层面上，还是很有必要的。</p>
<p>同样，在MDN上也有实现，但是我觉得下面的代码实现更加优雅和清晰：</p>
<pre><code>var reduce = function(arr, func, initialValue) {
    var base = typeof initialValue === &apos;undefined&apos; ? arr[0] : initialValue;
    var startPoint = typeof initialValue === &apos;undefined&apos; ? 1 : 0;
    arr.slice(startPoint)
        .forEach(function(val, index) {
            base = func(base, val, index + startPoint, arr);
        });
    return base;
};
</code></pre><p>如果读者有不同实现思路，也欢迎与我讨论。</p>
<h2 id="ES5-shim的pollyfill"><a href="#ES5-shim的pollyfill" class="headerlink" title="ES5-shim的pollyfill"></a>ES5-shim的pollyfill</h2><p>我也同样看了下ES5-shim里的pollyfill，跟我的思路基本完全一致。唯一有一点区别的地方在于我用了forEach迭代而ES5-shim使用的是简单for循环。</p>
<p>当然，数组的forEach方法也是ES5新增的。但我这里是为了用简单明了的思路，实现reduce方法，根本目的还是希望对reduce有一个全面透彻的了解。</p>
<p>如果您还不明白，我认为还是对于reduce方法没有掌握透彻。建议再梳理一遍。</p>
<h2 id="Redux中的reducer"><a href="#Redux中的reducer" class="headerlink" title="Redux中的reducer"></a>Redux中的reducer</h2><p>明白了reduce函数，我们再来看一下Redux中的reducer和这个reduce有什么命名上的关联。</p>
<p>熟悉Redux数据流架构的同学理解reducer做了什么，关于这个纯函数的命名，在redux源码github仓库上也有一个<a href="https://github.com/reactjs/redux/blob/master/docs/basics/Reducers.md" target="_blank" rel="external">官方解释</a>：“It’s called a reducer because it’s the type of function you would pass to Array.prototype.reduce(reducer, ?initialValue)”，虽然是一笔带过，但是总结的恰到好处。</p>
<p>我详细说一下：Redux数据流里，reducers其实是根据之前的状态（previous state）和现有的action（current action）更新state（这个state可以理解为上文累加器的结果（accumulation））。每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是“自身消减”（reduce，英文原意），进而返回最新的state。这符合一个典型reduce函数的用法：state -&gt; action -&gt; state.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章对于如何优雅地“扁平化”一个多维数组进行了解法分析。并且对于秉承函数式编程思想的reduce方法进行了深入讨论，我们还实现了reduce的pollyfill。在充分理解的基础上，又简要延伸到redux数据架构里面reducer的命名。熟悉Redux的同学一定会有所感触。</p>
<p>最后希望对读者有所启发，也欢迎同我讨论。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，高级工程师、实习生职位均有，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的&lt;a href=&quot;http://www.jianshu.com/p/6958f99db769&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇文章：从一道面试题，到“我可能看了假源码”&lt;/a&gt;讨论了bind方法的各种进阶Pollyfill，今天再分
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>由浅入深的前端面试题 和矫情的“浪漫主义”诗句</title>
    <link href="https://exp-team.github.io/blog/2017/03/06/js/inNetwork/"/>
    <id>https://exp-team.github.io/blog/2017/03/06/js/inNetwork/</id>
    <published>2017-03-05T16:00:00.000Z</published>
    <updated>2017-03-06T11:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>好吧，我承认太标题党了，这篇文章是通过一道前端面试题引出的纯技术讨论。我先要矫情无比的从中外诗歌说起。</p>
<p>传统的佛学经典里，被世人熟知的有这样一句话：“一花一世界，一叶一菩提，一木一浮生，一草一天堂，一砂一极乐，一方一净土，一笑一尘缘，一念一清静。”。</p>
<p>昔时佛祖拈花，惟迦叶微笑，既而步往极乐。从一朵花中便能悟出整个世界，得升天堂，佛祖就是佛祖，谁人能有这样的境界。</p>
<p>同时，早在18世纪，英国伟大的浪漫主义诗人Black名为《天真的暗示》的诗中，也类似写道：”To see a world in a grain of sand, and a heaven in a wild flower”，一颗沙里一个世界，一朵野花一座天堂。</p>
<p>转念，虽卑为码农，我们写出的代码，却彰显了功力：菜鸟和大神之间的差距，往往工程线上卑微的几行代码，便有天壤之差。</p>
<p>一道系列面试题，在JS知识体系中虽沧海一粟，但考察点充分评判面试者的能力。<br>管中窥豹，期待读者有不同想法与我讨论。</p>
<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>题目是我在《effective javascript》一书中提取的。这一星期陆陆续续面试了不少于10个人，其中不乏工作履历突出的候选者。<br>但是很遗憾没有能完全在较短时间内有较高质量的回答。</p>
<h2 id="题目前身"><a href="#题目前身" class="headerlink" title="题目前身"></a>题目前身</h2><p>这道题可以分为前后两个部分，第一部分很简单，一般有一定JS OOP基础的候选者应该都可以答好：</p>
<p>一个社交网络有一组成员（member），每个成员有一个自己的名字，和存储其朋友信息的列表。请实现这样一个Member构造器。</p>
<p>正确答案不难理解：</p>
<pre><code>function Member (name) {
    this.name = name;
    this.friends = [];
}
</code></pre><p>是不是非常简单。它的典型错误包括但是不限于：</p>
<pre><code>function Member (name) {
    this.name = name;
}
Member.prototype.friends = [];
</code></pre><p>关于方法和属性是应该放在原型上，还是构造函数中，如果您不明白的话，是时候补一补原型原型链的知识了。推荐给大家看一下我的同事颜海镜早在3年前的<a href="http://yanhaijing.com/javascript/2014/05/15/a-code-explain-javascript-oop/" target="_blank" rel="external">一篇文章</a></p>
<p>同样，这道题上我会顺便考察一下面试者对JS中变量的存储方式，包括堆栈存储的不同情况和引用赋值的掌握情况。</p>
<h2 id="题目变身"><a href="#题目变身" class="headerlink" title="题目变身"></a>题目变身</h2><p>以上是对JS基础的考察，但是在这道题目的基础上，我进行了更深一步提问。希望对候选者的临场思维、JS基础甚至一些设计能力，又更进一步认识。</p>
<p>我要实现一个带环社交网络（社交圈）：</p>
<pre><code>var a = new Member(&apos;Alice&apos;);
var b = new Member(&apos;Bob&apos;);
var c = new Member(&apos;Carol&apos;);
var d = new Member(&apos;Dieter&apos;);
var e = new Member(&apos;Eli&apos;);
var f = new Member(&apos;Fatima&apos;);

a.friends.push(b);
b.friends.push(c);
c.friends.push(e);
d.friends.push(b);
e.friends.push(d, f);
</code></pre><p>这种情况下，需要实现一个inNetwork方法，判断某目标成员是否在另一个对象成员的社交圈中。规定：顺着社交链能找到目标成员，就认为在社交圈中。否则，不在其社交圈。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果刚接触到这样的题目，尤其是在面试现场，作为面试者很可能会慌乱一下。这时候，需要做的就是先准确分析题目。<br>根据题目，画出符合上述题目代码的实例化网络：</p>
<p><img src="/bimg/network.png" alt="实例社交圈图示"></p>
<p>接下来思考，搜索意味着需要遍历整个社交网络。我们应该：</p>
<p>1）以单个根节点开始，</p>
<p>2）然后添加发现的节点，</p>
<p>3）移除访问过的节点，防止死环</p>
<p>最终实现：</p>
<pre><code>Member.prototype.inNetwork = function (target) {
    var visited = {};
    var worklist = [this]; // 用于存放社交链上的个体信息，初始时以“自己”作为根节点

    while (worklist.length &gt; 0) {
        // 将worklist里的最后一项成员删除并取出
        var member = worklist.pop();
        // 如果存在环的情况，需要避免重复访问
        if (member.name in visited) {
             continue;
        }
        visited[member.name] = member;
        if (member === target) {
            return true;
        }
        // 将当前成员的朋友列表加入worklist当中，他们都在根节点的社交链上
        member.friends.forEach(function(friend) {
            worklist.push(friend);
        })
    }
    return false;
}
</code></pre><p>我在代码中加上了注释，如果您还不明白也没有关系。建议去跑一下程序，进行debugger和console，尝试去理解。</p>
<p>测试：</p>
<pre><code>a.inNetwork(f) // true
f.inNetwork(a) //false
</code></pre><p>哈哈，果然Alice能通过朋友圈查找到Fatima，而Fatima却不能反向找到Alice!当然，这样我认为是违反人类社会常识的。但是，谁让他是题目呢？</p>
<p>一道简单的题却覆盖了很多知识点，比如：while循环中的流程控制（continue），数组的基本方法（pop,forEach,push），for…in等等。</p>
<p>它的典型错误包括但是不限于：使用对象承载worklist，然后用for…in循环遍历worklist。</p>
<p>这样做的问题在于：for…in循环并没有要求枚举对象的修改与当前循环保持一致。事实上，标准规范规定了：</p>
<p>“如果被枚举对象在枚举期间添加了新的属性，那么枚举期间并不能保证新添加的属性能够访问”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题考察了面试者包括JS OOP在内的多项基础，尤其是后半道考察了候选者的思维能力、反应能力。</p>
<p>扯回原诗句，谈一下感悟，在天体的转动和岁月的轮回中，我们分明的感受到每一个个体所拥有生命周期的单薄无力，在宏大的宇宙观中恐怕渺小不及沧海一粟。诗句的后半句拿出来共勉：“Hold infinity in the palm of your hand, and eternity in an hour 把无限放在你的手上，永恒在一刹那里收藏”。</p>
<p>在前端快速迭代发展的学习中，作为初学者，往往面对浩瀚的知识海洋望洋兴叹，此时基础便是那能够收藏“永恒和无限”的潘多拉魔盒。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好吧，我承认太标题党了，这篇文章是通过一道前端面试题引出的纯技术讨论。我先要矫情无比的从中外诗歌说起。&lt;/p&gt;
&lt;p&gt;传统的佛学经典里，被世人熟知的有这样一句话：“一花一世界，一叶一菩提，一木一浮生，一草一天堂，一砂一极乐，一方一净土，一笑一尘缘，一念一清静。”。&lt;/p&gt;

    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10111期</title>
    <link href="https://exp-team.github.io/blog/2017/03/04/weekly/weekly-10111/"/>
    <id>https://exp-team.github.io/blog/2017/03/04/weekly/weekly-10111/</id>
    <published>2017-03-03T16:00:00.000Z</published>
    <updated>2017-03-06T10:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>2.27-3.3，买了书也不读，还要不要买</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="买了书也不读，还要不要买？"><a href="#买了书也不读，还要不要买？" class="headerlink" title="买了书也不读，还要不要买？"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713060&amp;idx=1&amp;sn=f6cfb8bac38591a6df87b3ebe290166c&amp;chksm=bec065b789b7eca1290b229ad77e1ceca7b3f6de389e8dee5a10ef8b47c2b0a8edf495f9c57a&amp;mpshare=1&amp;scene=1&amp;srcid=0301cCLRYnLwWQBj5dqpl8ej#rd" target="_blank" rel="external">买了书也不读，还要不要买？</a></h3><p>这个问题困扰了我很久，答案是继续买，读书也不要停</p>
<h3 id="30-分钟学会-Flex-布局"><a href="#30-分钟学会-Flex-布局" class="headerlink" title="30 分钟学会 Flex 布局"></a><a href="https://zhuanlan.zhihu.com/p/25303493" target="_blank" rel="external">30 分钟学会 Flex 布局</a></h3><p>温故而知新可以为师矣，10分钟温习一下</p>
<h3 id="有了它，就能轻松管理你的多个-Node-版本"><a href="#有了它，就能轻松管理你的多个-Node-版本" class="headerlink" title="有了它，就能轻松管理你的多个 Node 版本"></a><a href="https://www.h5jun.com/post/manage_node_with_n.html" target="_blank" rel="external">有了它，就能轻松管理你的多个 Node 版本</a></h3><p>爱折腾的小伙伴，试试这个吧，node的版本真是让人头疼</p>
<a id="more"></a>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="小公司的前端应该怎么做？"><a href="#小公司的前端应该怎么做？" class="headerlink" title="小公司的前端应该怎么做？"></a><a href="http://www.cnblogs.com/yexiaochai/p/5311712.html" target="_blank" rel="external">小公司的前端应该怎么做？</a></h3><h3 id="没有循环的JavaScript"><a href="#没有循环的JavaScript" class="headerlink" title="没有循环的JavaScript"></a><a href="https://github.com/Findow-team/Blog/issues/16" target="_blank" rel="external">没有循环的JavaScript</a></h3><h3 id="延迟加载-Lazyload-三种实现方式"><a href="#延迟加载-Lazyload-三种实现方式" class="headerlink" title="延迟加载(Lazyload)三种实现方式"></a><a href="https://zhuanlan.zhihu.com/p/25455672" target="_blank" rel="external">延迟加载(Lazyload)三种实现方式</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2.27-3.3，买了书也不读，还要不要买&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;买了书也不读，还要不要买？&quot;&gt;&lt;a href=&quot;#买了书也不读，还要不要买？&quot; class=&quot;headerlink&quot; title=&quot;买了书也不读，还要不要买？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650713060&amp;amp;idx=1&amp;amp;sn=f6cfb8bac38591a6df87b3ebe290166c&amp;amp;chksm=bec065b789b7eca1290b229ad77e1ceca7b3f6de389e8dee5a10ef8b47c2b0a8edf495f9c57a&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0301cCLRYnLwWQBj5dqpl8ej#rd&quot;&gt;买了书也不读，还要不要买？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;这个问题困扰了我很久，答案是继续买，读书也不要停&lt;/p&gt;
&lt;h3 id=&quot;30-分钟学会-Flex-布局&quot;&gt;&lt;a href=&quot;#30-分钟学会-Flex-布局&quot; class=&quot;headerlink&quot; title=&quot;30 分钟学会 Flex 布局&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25303493&quot;&gt;30 分钟学会 Flex 布局&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;温故而知新可以为师矣，10分钟温习一下&lt;/p&gt;
&lt;h3 id=&quot;有了它，就能轻松管理你的多个-Node-版本&quot;&gt;&lt;a href=&quot;#有了它，就能轻松管理你的多个-Node-版本&quot; class=&quot;headerlink&quot; title=&quot;有了它，就能轻松管理你的多个 Node 版本&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.h5jun.com/post/manage_node_with_n.html&quot;&gt;有了它，就能轻松管理你的多个 Node 版本&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;爱折腾的小伙伴，试试这个吧，node的版本真是让人头疼&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>设计高性能无限滚动加载，了解高效页面秘密</title>
    <link href="https://exp-team.github.io/blog/2017/02/25/js/infinite-scroll/"/>
    <id>https://exp-team.github.io/blog/2017/02/25/js/infinite-scroll/</id>
    <published>2017-02-24T16:00:00.000Z</published>
    <updated>2017-03-06T10:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>UX Planet论坛上有过这么一篇<a href="https://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11" target="_blank" rel="external">热门文章: Infinite Scrolling Best Practices</a>，它从UX角度分析了无限滚动加载的设计实践。</p>
<p>无限滚动加载在互联网上到处都有应用：<br>豆瓣首页是一个，Facebook的Timeline是一个，Tweeter的话题列表也是一个。当你向下滚动，新的内容就神奇的“无中生有”了。这是一个得到广泛赞扬的用户体验。</p>
<p>无限滚动加载背后的技术挑战其实比想象中要多不少。尤其是要考虑页面性能，需要做到极致。<br>本文通过代码实例，来实现一个无限滚动加载效果。更重要的是，在实现过程中，对于页面性能的分析和处理力图做到最大化，希望对读者有所启发，同时也欢迎与我讨论。</p>
<h2 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h2><p>在开启我们的代码之前，有必要先了解一下常用的性能测量手段：</p>
<p>1）使用window.performance </p>
<p>HTML5带来的performance API功能强大。我们可以使用其performance.now()精确计算程序执行时间。performance.now()与Date.now()不同的是，返回了以微秒（百万分之一秒）为单位的时间，更加精准。并且与 Date.now() 会受系统程序执行阻塞的影响不同，performance.now() 的时间是以恒定速率递增的，不受系统时间的影响（系统时间可被人为或软件调整）。<br>同时，也可以使用performance.mark()标记各种时间戳（就像在地图上打点），保存为各种测量值（测量地图上的点之间的距离），便可以批量地分析这些数据了。</p>
<p>2）使用console.time方法与console.timeEnd方法</p>
<p>其中console.time方法用于标记开始时间，console.timeEnd方法用于标记结束时间，并且将结束时间与开始时间之间经过的毫秒数在控制台中输出。</p>
<p>3）使用专业的测量工具／平台：jsPerf</p>
<p>这次实现中，我们使用第二种方法，因为它已经完全可以满足我们的需求，且兼容性更加全面。</p>
<h2 id="整体思路和方案设计"><a href="#整体思路和方案设计" class="headerlink" title="整体思路和方案设计"></a>整体思路和方案设计</h2><p>我们要实现的页面样例如图，</p>
<p><img src="/bimg/s1.png" alt=""></p>
<p>它能够做到无限下拉加载内容。我把红线标出的部分叫做一个block-item，后续也都用这种命名。</p>
<p>1）关于设计方案，肯定第一个最基本、最朴素的思想是下拉到底部之后发送ajax异步请求，成功之后的回调里进行页面拼接。</p>
<p>2）但是观察页面布局，很明显图片较多，每一个block-item区块都有一张配图。当加载后的内容插入到页面中时，浏览器就开始获取图片。这意味着所有的图像同时下载，浏览器中的下载通道将被占满。同时，由于内容优先于用户浏览而加载，所以可能被迫下载底部那些永远也不会被用户浏览到的图像。<br>所以，我们需要设计一个懒加载效果，使得页面速度更快，并且节省用户的流量费用和延长电池寿命。</p>
<p>3）上一条提到的懒加载实现上，为了避免到真正的页面底部时才进行加载和渲染，而造成用户较长时间等待。我们可以设置一个合理阈值，在用户滚动到页面底部之前，先进行提前加载。</p>
<p>4）另外，页面滚动的事件肯定是需要监听的。同时，页面滚动问题也比较棘手，后面将专为滚动进行分析。</p>
<p>5）DOM操作我们知道是及其缓慢而低效的，有兴趣的同学可以研究一下jsPerf上一些经典的benchmark，比如<a href="http://jsperf.com/jquery-cache-vs-dom-querying" target="_blank" rel="external">这篇</a>。关于造成这种缓慢的原因，社区上同样有很多文章有过分析，这里就不再深入。但我想总结并补充的是：DOM操作，光是为了找一个节点，就从本质上比简单的检索内存中的值要慢。一些DOM操作还需要重新计算样式来读取或检索一个值。更突出的问题在于：DOM操作是阻塞的，所以当有一个DOM操作在进行时，其他的什么都不能做，包括用户与页面的交互（除了滚动）。这是一个极度伤害用户体验的事实。</p>
<p>所以，在下面的效果实现中，我采用了大量“不可思议”的DOM缓存，甚至极端的缓存everything。当然，这样做的收益也在最后部分有所展现。</p>
<h3 id="滚动问题"><a href="#滚动问题" class="headerlink" title="滚动问题"></a>滚动问题</h3><p>滚动问题不难想象在于高频率的触发滚动事件处理上。具我亲测，在极端case下，滚动及其卡顿。即使滚动不卡顿，你可以打开Chrome控制台发现，帧速率也非常慢。关于帧速率的问题，我们有著名的16.7毫秒理论。关于这个时间分析，社区上也有不少文章阐述，这里不再展开。</p>
<p>针对于此，有很多读者会立刻想到“截流和防抖动函数”（Throttle和Debounce）。<br>简单总结一下：</p>
<p>1）Throttle允许我们限制激活响应的数量。我们可以限制每秒回调的数量。反过来，也就是说在激活下一个回调之前要等待多少时间;</p>
<p>2）Debounce意味着当事件发生时，我们不会立即激活回调。相反，我们等待一定的时间并检查相同的事件是否再次触发。如果是，我们重置定时器，并再次等待。如果在等待期间没有发生相同的事件，我们就立即激活回调。</p>
<p>具体这里就不代码实现了。原理明白之后，应该不难写出。</p>
<p>但是我这里想从移动端主要浏览器处理滚动的方式入手，来思考这个问题：</p>
<p>1）在Android机器上，用户滚动屏幕时，滚动事件高频率发生——在Galaxy－SIII手机上，大约频率是一秒一百次。这意味着，滚动处理函数也被调用了数百次，而这些又都是成本较大的函数。</p>
<p>2）在Safari浏览器上，我们遇到的问题恰恰是相反的：用户每次滚动屏幕时，滚动事件只在滚动动画停止时才触发。当用户在iPhone上滚动屏幕时，不会运行更新界面的代码（滚动停止时才会运行一次）。</p>
<p>另外，我想也许会有读者想到rAf（requestAnimationFrame），但是据我观察，很多前端其实并不明白requestAnimationFrame技术的原理和解决的问题。只是机械地把动画性能、掉帧问题甩到这么一个名词上。在真实项目中，也没有亲自实现过，更不要说考虑requestAnimationFrame的兼容性情况了。这里场景我并不会使用rAf，因为。setTimeout的定时器值推荐最小使用16.7ms（原因请去社区上找答案，不再细讲），我们这里并不会超过这个限制，并且考虑兼容性。关于这项技术的使用，如果有问题，欢迎留言讨论。</p>
<p>基于以上，我的解决方案是既不同于Throttle，也不同于Debounce，但是和这两个思想，尤其是Throttle又比较类似：把滚动事件替换为一个带有计时器的滚动处理程序，每100毫秒进行简单检查，看这段时间内用户是否滚动过。如果没有，则什么都不做；如果有，就进行处理。</p>
<h3 id="用户体验优化小窍门"><a href="#用户体验优化小窍门" class="headerlink" title="用户体验优化小窍门"></a>用户体验优化小窍门</h3><p>在图像加载完成时，使用淡入（fade in）效果出现。这在实际情况上会稍微慢一下，应该慢一个过渡执行时间。但用户体验上感觉会更快。这是已经被证实且普遍应用的小“trick”。但是据我感觉，它确实有效。我们的代码实现也采用了这个小窍门。不过类似这种“社会心理学”范畴的东西，显然不是本文研究的重点。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>代码上将会采用：超前阈值的懒加载＋DOM Cache和图片Cache＋滚动throttle模拟＋CSS fadeIn动画。<br>具体功能封装上和一些实现层面的东西，请您继续阅读。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h3><p>整体结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"exp-list-box"</span> <span class="attr">id</span>=<span class="string">"expListBox"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"exp-list"</span> <span class="attr">id</span>=<span class="string">"expList"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui-refresh-down"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>主体内容放在id为“expListBox”的container里面，id为“expList”的ul是页面加载内容的容器。<br>因为每次加载并append进入HTML的内容相对较多。我使用了模版来取代传统的字符串拼接。前端模版这次选用了我的同事<a href="https://github.com/yanhaijing/template.js" target="_blank" rel="external">颜海镜大神的开源作品</a>，模版结构为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">#dataList.forEach(function</span> (<span class="attr">v</span>) &#123;#&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="attr">class</span>=<span class="string">"slide"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;#=v.href#&gt;"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"img"</span> <span class="attr">src</span>=<span class="string">"data:image/gif;base64,R0lGODdhAQABAPAAAP%2F%2F%2FwAAACwAAAAAAQABAEACAkQBADs%3D"</span> </span></div><div class="line">                <span class="attr">data-src</span>=<span class="string">"&lt;#=v.src#&gt;"</span>&gt;</div><div class="line">                <span class="tag">&lt;/<span class="name">img</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.title#</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"writer"</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.writer#</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"good-num"</span>&gt;</span><span class="tag">&lt;<span class="name">#=v.succNum#</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">#&#125;)#</span>&gt;</span></div></pre></td></tr></table></figure>
<p>以上模版内容由每次ajax请求到的数据填充，并添加进入页面，构成每个block-item。<br>这里需要注意观察，有助于对后面逻辑的理解。页面中一个block-item下div属性存有该block-item的eid值，对应class叫做”slide”，子孙节点包含有一个image标签，src初始赋值为1px的空白图进行占位。真实图片资源位置存储在”data-src”中。<br>另外，请求返回的数据dataList可以理解为由9个对象构成的数组，也就是说，每次请求加载9个block-item。</p>
<h3 id="样式亮点"><a href="#样式亮点" class="headerlink" title="样式亮点"></a>样式亮点</h3><p>样式方面不是这篇文章的重点，挑选最核心的一行来说明一下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.slide</span> <span class="selector-class">.img</span>&#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">90px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">-webkit-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">-moz-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">-o-transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">    <span class="attribute">transition</span>: opacity <span class="number">0.25s</span> ease-in-out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唯一需要注意的是image的opacity设置为0，图片将会在成功请求并渲染后调整为1，辅助transition属性实现一个fade in效果。<br>对应我们上面所提到的那个“trick”</p>
<h3 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h3><p>我是完全按照业务需求来设计，并没有做抽象。其实这样的一个下拉加载功能完全可以抽象出来。有兴趣的读者可以下去自己进行封装和抽象。<br>我们先把精力集中在逻辑处理上。<br>下面进入我们最核心的逻辑部分，为了防止全局污染，我把它放入了一个立即执行函数中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> fetching = <span class="literal">false</span>; </div><div class="line">    <span class="keyword">var</span> page = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> slideCache = [];</div><div class="line">    <span class="keyword">var</span> itemMap = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> lastScrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line">    <span class="keyword">var</span> scrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line">    <span class="keyword">var</span> innerHeight;</div><div class="line">    <span class="keyword">var</span> topViewPort;</div><div class="line">    <span class="keyword">var</span> bottomViewPort;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isVisible</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...判断元素是否在可见区域</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateItemCache</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">        <span class="comment">// ....更新DOM缓存</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fetchContent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...ajax请求数据</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleDefer</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// ...懒加载实现</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleScroll</span> (<span class="params">e, force</span>) </span>&#123;</div><div class="line">        <span class="comment">// ...滚动处理程序</span></div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">    fetchContent();</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>我认为好的编程习惯是在程序开头部分便声明所有的变量，防止“变量提升”带来的潜在困扰，并且也有利于程序的整体把控。<br>我们来看一下变量设置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加载中状态锁</span></div><div class="line"><span class="number">1</span>）<span class="keyword">var</span> fetching = <span class="literal">false</span>;</div><div class="line"><span class="comment">// 用于加载时发送请求参数，表示第几屏内容，初始为1，以后每请求一次，递增1</span></div><div class="line"><span class="number">2</span>）<span class="keyword">var</span> page = <span class="number">1</span>; </div><div class="line"><span class="comment">// 只缓存最新一次下拉数据生成的DOM节点，即需要插入的dom缓存数组</span></div><div class="line"><span class="number">3</span>）<span class="keyword">var</span> slideCache = []; </div><div class="line"><span class="comment">// 用于已经生成的DOM节点储存，存有item的offsetTop，offsetHeight</span></div><div class="line"><span class="number">4</span>) <span class="keyword">var</span> slideMap = &#123;&#125;; </div><div class="line"><span class="comment">// pageYOffset设置或返回当前页面相对于窗口显示区左上角的Y位置。</span></div><div class="line"><span class="number">5</span>）<span class="keyword">var</span> lastScrollY = <span class="built_in">window</span>.pageYOffset; <span class="keyword">var</span> scrollY = <span class="built_in">window</span>.pageYOffset;</div><div class="line"><span class="comment">// 浏览器窗口的视口（viewport）高度</span></div><div class="line"><span class="number">6</span>）<span class="keyword">var</span> innerHeight;</div><div class="line"><span class="comment">// isVisible的上下阈值边界</span></div><div class="line"><span class="number">7</span>) <span class="keyword">var</span> topViewPort; </div><div class="line"><span class="number">8</span>) <span class="keyword">var</span> bottomViewPort;</div></pre></td></tr></table></figure>
<p>关于DOM cache的变量详细说明，在后文有提供。</p>
<p>同样，我们有5个函数。在上面的代码中，注释已经写明白了每个方法的具体作用。接下来，我们逐个分析。</p>
<h4 id="滚动处理程序handleScroll"><a href="#滚动处理程序handleScroll" class="headerlink" title="滚动处理程序handleScroll"></a>滚动处理程序handleScroll</h4><p>它接受两个变量，第二个是一个布尔值force，表示是否强制触发滚动程序执行。</p>
<p>核心思路是：如果时间间隔100毫秒内，没有发生滚动，且并未强制触发，则do nothing，间隔100毫秒之后再次查询，然后直接return。<br>其中，是否发生滚动由lastScrollY === window.scrollY来判断。<br>在100毫秒之内发生滚动或者强制触发时，需要判断是否滚动已接近页面底部。如果是，则拉取数据，调用fetchContent方法，并调用懒加载方法handleDefer。<br>并且在这个处理程序中，我们计算出来了isVisible区域的上下阈值。我们使用600作为浮动区间，这么做的目的是在一定范围内提前加载图片，节省用户等待时间。当然，如果我们进行抽象时，可以把这个值进行参数化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleScroll</span> (<span class="params">e, force</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果时间间隔内，没有发生滚动，且并未强制触发加载，则do nothing，再次间隔100毫秒之后查询</span></div><div class="line">    <span class="keyword">if</span> (!force &amp;&amp; lastScrollY === <span class="built_in">window</span>.scrollY) &#123;</div><div class="line">        <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 更新文档滚动位置</span></div><div class="line">        lastScrollY = <span class="built_in">window</span>.scrollY;</div><div class="line">    &#125;</div><div class="line">    scrollY = <span class="built_in">window</span>.scrollY;</div><div class="line">    <span class="comment">// 浏览器窗口的视口（viewport）高度赋值</span></div><div class="line">    innerHeight = <span class="built_in">window</span>.innerHeight;</div><div class="line">    <span class="comment">// 计算isVisible上下阈值</span></div><div class="line">    topViewPort = scrollY - <span class="number">1000</span>;</div><div class="line">    bottomViewPort = scrollY + innerHeight + <span class="number">600</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否需要加载</span></div><div class="line">    <span class="comment">// document.body.offsetHeight;返回当前网页高度 </span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY + innerHeight + <span class="number">200</span> &gt; <span class="built_in">document</span>.body.offsetHeight) &#123;</div><div class="line">        fetchContent();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 实现懒加载</span></div><div class="line">    handleDefer();</div><div class="line">    <span class="built_in">window</span>.setTimeout(handleScroll, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="拉取数据"><a href="#拉取数据" class="headerlink" title="拉取数据"></a>拉取数据</h4><p>这里我用到了自己封装的ajax接口方法，它基于zepto的ajax方法，只不过又手动采用了promise包装一层。实现比较简单，当然有兴趣可以找我要一下代码，这里不再详细说了。<br>我们使用前端模版进行HTML渲染，同时调用updateItemCache，将此次数据拉取生成的DOM节点缓存。之后手动触发handleScroll，更新文档滚动位置和懒加载处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchContent</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 设置加载状态锁</span></div><div class="line">    <span class="keyword">if</span> (fetching) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        fetching = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    ajax(&#123;</div><div class="line">        <span class="attr">url</span>: (!location.pathname.indexOf(<span class="string">'/m/'</span>) ? <span class="string">'/m'</span> : <span class="string">''</span>)</div><div class="line">            + <span class="string">'/list/asyn?page='</span> + page + (+<span class="keyword">new</span> <span class="built_in">Date</span>),</div><div class="line">        <span class="attr">timeout</span>: <span class="number">300000</span>,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'json'</span></div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (data.errno) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.time(<span class="string">'render'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> dataList = data.data.list;</div><div class="line">        <span class="keyword">var</span> len = dataList.length;</div><div class="line">        <span class="keyword">var</span> ulContainer = <span class="built_in">document</span>.getElementById(<span class="string">'expList'</span>);</div><div class="line">        <span class="keyword">var</span> str = <span class="string">''</span>;</div><div class="line">        <span class="keyword">var</span> frag = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> tpl = __inline(<span class="string">'content.tmpl'</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            str = tpl(&#123;<span class="attr">dataList</span>: dataList&#125;);</div><div class="line">        &#125;</div><div class="line">        frag.innerHTML = str;</div><div class="line">        ulContainer.appendChild(frag);</div><div class="line">        <span class="comment">// 更新缓存</span></div><div class="line">        updateItemCache(frag);</div><div class="line">        <span class="comment">// 已经拉去完毕，设置标识为true</span></div><div class="line">        fetching = <span class="literal">false</span>;</div><div class="line">        <span class="comment">// 强制触发</span></div><div class="line">        handleScroll(<span class="literal">null</span>, <span class="literal">true</span>);</div><div class="line">        page++;</div><div class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">'render'</span>);</div><div class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">xhr, type</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Refresh:Ajax Error!'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h4><p>之前参数里提到过，一共有两个用于缓存的对象／数组：</p>
<p>1）slideCache：缓存最近一次加载过的数据生成的DOM内容，缓存方式为数组储存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">slideCache = [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">id</span>: <span class="string">"s-97r45"</span>,</div><div class="line">        <span class="attr">img</span>: img DOM节点,</div><div class="line">        <span class="attr">node</span>: 父容器DOM node,类似&lt;div id=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"slide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</div><div class="line">        <span class="attr">src</span>: 图片资源地址</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">]</div></pre></td></tr></table></figure>
<p>slideCache由updateItemCache函数更新，主要用于懒加载时的赋值src。这样我们做到“只写入DOM”原则，不需要再从DOM读取。</p>
<p>2）slideMap：缓存DOM节点的高度和offsetTop，以DOM节点的id为索引。存储方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">slideMap = &#123;</div><div class="line">    s<span class="number">-97</span>r45: &#123;</div><div class="line">        <span class="attr">node</span>: DOM node,类似&lt;div id=<span class="string">"s-&lt;#=v.eid#&gt;"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"slide"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</div><div class="line">        <span class="attr">offTop</span>: <span class="number">300</span>,</div><div class="line">        <span class="attr">offsetHeight</span>: <span class="number">90</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>slideMap根据isVisible方法的参数进行更新和读取。使得我们在判断是否isVisible时，大量减少读取DOM的操作。   </p>
<h4 id="懒加载程序"><a href="#懒加载程序" class="headerlink" title="懒加载程序"></a>懒加载程序</h4><p>在上面的滚动处理程序中，我们调用了handleDefer函数。我们看一下这个函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDefer</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 时间记录</span></div><div class="line">    <span class="built_in">console</span>.time(<span class="string">'defer'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 获取dom缓存</span></div><div class="line">    <span class="keyword">var</span> list = slideCache;</div><div class="line">    <span class="comment">// 对于遍历list里的每一项，都使用一个变量，而不是在循环内部声明。节省内存，把性能高效，做到极致。</span></div><div class="line">    <span class="keyword">var</span> thisImg;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</div><div class="line">        thisImg = list[i].img; <span class="comment">// 这里我们都是从内存中读取，而不用读取DOM节点</span></div><div class="line">        <span class="keyword">var</span> deferSrc = list[i].src; <span class="comment">// 这里我们都是从内存中读取，而不用读取DOM节点</span></div><div class="line">        <span class="comment">// 判断元素是否可见</span></div><div class="line">        <span class="keyword">if</span> (isVisible(list[i].id)) &#123;</div><div class="line">            <span class="comment">// 这个函数是图片onload逻辑</span></div><div class="line">            <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> node = thisImg;</div><div class="line">                <span class="keyword">var</span> src = deferSrc;</div><div class="line">                <span class="comment">// 创建一个闭包</span></div><div class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    node.src = src;</div><div class="line">                    node.style.opacity = <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">            img.onload = handler();</div><div class="line">            img.src = list[i].src;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'defer'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要思路就是对DOM缓存中的每一项进行循环遍历。在循环中，判断每一项是否已经进入isVisible区域。如果进入isVisible区域，则对当前项进行真实src赋值，并设置opacity为1。</p>
<h4 id="更新拉取数据生成的DOM缓存"><a href="#更新拉取数据生成的DOM缓存" class="headerlink" title="更新拉取数据生成的DOM缓存"></a>更新拉取数据生成的DOM缓存</h4><p>针对每一个slide类，我们缓存对应DOM节、id、子元素img DOM节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateItemCache</span> (<span class="params">node</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> list = node.querySelectorAll(<span class="string">'.slide'</span>);</div><div class="line">    <span class="keyword">var</span> len = list.length;</div><div class="line">    slideCache = [];</div><div class="line">    <span class="keyword">var</span> obj;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        obj = &#123;</div><div class="line">            <span class="attr">node</span>: list[i],</div><div class="line">            <span class="attr">id</span>: list[i].getAttribute(<span class="string">'id'</span>),</div><div class="line">            <span class="attr">img</span>: list[i].querySelector(<span class="string">'.img'</span>)</div><div class="line">        &#125;</div><div class="line">        obj.src = obj.img.getAttribute(<span class="string">'data-src'</span>);</div><div class="line">        slideCache.push(obj);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="是否在isVisible区域判断"><a href="#是否在isVisible区域判断" class="headerlink" title="是否在isVisible区域判断"></a>是否在isVisible区域判断</h4><p>该函数接受相应DOM id，并进行判断。<br>如果判断条件晦涩难懂的话，你一定要手动画画图理解一下。如果你就是懒得画图，那么也没关系，我帮你画好了，只是丑一些。。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isVisible</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> offTop;</div><div class="line">    <span class="keyword">var</span> offsetHeight;</div><div class="line">    <span class="keyword">var</span> data;</div><div class="line">    <span class="keyword">var</span> node;</div><div class="line"></div><div class="line">    <span class="comment">// 判断此元素是否已经懒加载正确渲染，分为在屏幕之上（已经懒加载完毕）和屏幕外，已经添加到dom中，但是还未请求图片（懒加载之前）</span></div><div class="line">    <span class="keyword">if</span> (itemMap[id]) &#123;</div><div class="line">        <span class="comment">// 直接获取offTop，offsetHeight值</span></div><div class="line">        offTop = itemMap[id].offTop;</div><div class="line">        offsetHeight = itemMap[id].offsetHeight;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 设置该节点，并且设置节点属性：node，offTop，offsetHeight</span></div><div class="line">        node = <span class="built_in">document</span>.getElementById(id);</div><div class="line">        <span class="comment">// offsetHeight是自身元素的高度</span></div><div class="line">        offsetHeight = <span class="built_in">parseInt</span>(node.offsetHeight);</div><div class="line">        <span class="comment">// 元素的上外缘距离最近采用定位父元素内壁的距离</span></div><div class="line">        offTop = <span class="built_in">parseInt</span>(node.offsetTop);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (offTop + offsetHeight &gt; topViewPort &amp;&amp; offTop &lt; bottomViewPort) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/bimg/s2.jpg" alt=""></p>
<h3 id="性能收益"><a href="#性能收益" class="headerlink" title="性能收益"></a>性能收益</h3><p>如上代码，我们主要进行了两方面的性能考量：</p>
<p>1）延迟加载时间</p>
<p>2）渲染DOM时间</p>
<p>整体收益如下：</p>
<p>优化前延迟平均值：49.2ms     中间值：43ms；</p>
<p>优化后延迟平均值：17.1ms     中间值：11ms；</p>
<p>优化前渲染平均值：2129.6ms   中间值：2153.5ms；</p>
<p>优化后渲染平均值：120.5ms    中间值：86ms；</p>
<h2 id="继续思考"><a href="#继续思考" class="headerlink" title="继续思考"></a>继续思考</h2><p>做完这些，其实也远远没有达到所谓的“极致化”性能体验。我们无非就做了各种DOM缓存、映射、懒加载。如果继续分析edge case，我们还能做的更多，比如：DOM回收、墓碑和滚动锚定。这些其实很多都是借鉴客户端开发理念，但是超前的谷歌开发者团队也都有了自己的实现。比如在去年7月份的<br><a href="https://developers.google.com/web/updates/2016/07/infinite-scroller" target="_blank" rel="external">一篇文章：Complexities of an Infinite Scroller</a>就都有所提及。这里从原理（非代码）层面，也给大家做个介绍。</p>
<h3 id="DOM回收"><a href="#DOM回收" class="headerlink" title="DOM回收"></a>DOM回收</h3><p>它的原理是，对于需要产生的大量DOM节点（比如我们下拉加载的信息内容）不是主动用createElement的方式创建，而是回收利用那些已经移出视窗，暂时不会被需要的DOM节点。如图：</p>
<p><img src="/bimg/s3.gif" alt=""></p>
<p>虽然DOM节点本身并非耗能大户，但是也不是一点都不消耗性能，每一个节点都会增加一些额外的内存、布局、样式和绘制。同样需要注意的一点是，在一个较大的DOM中每一次重新布局或重新应用样式（在节点上增加或删除样式所触发的过程）的系统开销都会比较昂贵。所以进行DOM回收意味着我们会保持DOM节点在一个比较低的数量上，进而加快上面提到的这些处理过程。</p>
<p>据我观察，在真正产品线上使用这项技术的还比较少。可能是因为实现复杂度和收益比并不很高。但是，淘宝移动端检索页面实现了类似的思想。如下图，</p>
<p><img src="/bimg/s4.png" alt=""></p>
<p>每加载一次数据，就生成“.page-container  .J-PageContainer_页数”的div，在滚动多屏之后，早已移除视窗的div的子节点进行了remove()，并且为了保证滚动条的正确比例和防止高度塌陷，显示声明了2956px的高度。</p>
<h3 id="墓碑（Tombstones）"><a href="#墓碑（Tombstones）" class="headerlink" title="墓碑（Tombstones）"></a>墓碑（Tombstones）</h3><p>如之前所说，如果网络延迟较大，用户又飞快地滚动，很容易就把我们渲染的DOM节点都甩在千里之外。这样就会出现极差的用户体验。针对这种情况，我们就需要一个墓碑条目占位在对应位置。等到数据取到之后，再代替墓碑。墓碑也可以有一个独立的DOM元素池。并且也可以设计出一些漂亮的过渡。这种技术在国外的一些“引领技术潮流”的网站上，早已经有了应有。比如下图取自Facebook：</p>
<p><img src="/bimg/s5.png" alt=""></p>
<p>我在“简书”APP客户端上，也见过类似的方案。当然，人家是native…</p>
<p><img src="/bimg/s6.jpg" alt=""></p>
<h3 id="滚动锚定"><a href="#滚动锚定" class="headerlink" title="滚动锚定"></a>滚动锚定</h3><p>滚动锚定的触发时机有两个：一个是墓碑被替换时，另一个是窗口大小发生改变时（在设备发生翻转时也会发生）。这两种情况，都需要调整对应的滚动位置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你想提供一个高性能的有良好用户体验的功能时，可能技术上一个简单的问题，就会演变成复杂问题的。这篇文章便是一个例证。<br>随着 “Progressive Web Apps” 逐渐成为移动设备的一等公民（会吗？），高性能的良好体验会变得越来越重要。<br>开发者也必须持续的研究使用一些模式来应对性能约束。这些设计的基础当然都是成熟的技术为根本。</p>
<p>这篇文章参考了Flicker工程师，前YAHOO工程师Stephen Woods的《Building Touch Interfaces with HTML5》一书。以及王芃前辈对于《Complexities of an Infinite Scroller》一文的部分翻译。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UX Planet论坛上有过这么一篇&lt;a href=&quot;https://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10110期</title>
    <link href="https://exp-team.github.io/blog/2017/02/24/weekly/weekly-10110/"/>
    <id>https://exp-team.github.io/blog/2017/02/24/weekly/weekly-10110/</id>
    <published>2017-02-23T16:00:00.000Z</published>
    <updated>2017-03-06T10:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>2.20-2.24，我预见了所有悲伤，但依然愿意前往</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="假如未来已经设定"><a href="#假如未来已经设定" class="headerlink" title="假如未来已经设定"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713029&amp;idx=1&amp;sn=2a8fa3a0f0980e08f85884ddf4c69cb8&amp;chksm=bec0659689b7ec805b636d54cbb0d041283c004941a025bb69ed6d56606af734124da58e67ae&amp;mpshare=1&amp;scene=1&amp;srcid=0214ZjRyXl5OqRZgInG4xTkI#rd" target="_blank" rel="external">假如未来已经设定</a></h3><p>我预见了所有悲伤，但依然愿意前往，脑洞很大的文章，你有没有想过如果未来是已经确定，就像手心的纹路确定了我们的命运一样</p>
<h3 id="JavaScript-简史：JavaScript-的过去、现在和未来"><a href="#JavaScript-简史：JavaScript-的过去、现在和未来" class="headerlink" title="JavaScript 简史：JavaScript 的过去、现在和未来"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964302&amp;idx=1&amp;sn=58cedeefd6390b642cb9b3d36645bc43&amp;chksm=843aed28b34d643eacb32c9005a1bcf816b0b11e965df5408045efa677b7fe9c04c00d8d7f70&amp;mpshare=1&amp;scene=1&amp;srcid=0218Ka8Y2Dt48RKcIueksYsr#rd" target="_blank" rel="external">JavaScript 简史：JavaScript 的过去、现在和未来</a></h3><p>我看到最全的js历史，从诞生到现在，每一次成长在这里都有记录，js发展到今天历史上有一些关键点和关键的人和公司</p>
<h3 id="职场中脱颖而出的成长秘诀"><a href="#职场中脱颖而出的成长秘诀" class="headerlink" title="职场中脱颖而出的成长秘诀"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651225540&amp;idx=1&amp;sn=0e18e698880f426ddca78bf7fa3640ee&amp;chksm=bd49a4408a3e2d56c4797aa49d7f3f0380ab58ad06b2d92a7d9df86b32eee82f6decd5ab660f&amp;mpshare=1&amp;scene=1&amp;srcid=0208fCIyROm3JSq69KeCtWdL#rd" target="_blank" rel="external">职场中脱颖而出的成长秘诀</a></h3><p>跳槽季了，结尾推荐了一些跳槽的指导文章，但我认为更重要的是如何让自己脱颖而出</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="2016－JavaScript之星"><a href="#2016－JavaScript之星" class="headerlink" title="2016－JavaScript之星"></a><a href="https://github.com/fezaoduke/TranslationInstitute/blob/master/JavaScript%E4%B9%8B%E6%98%9F-2016.md" target="_blank" rel="external">2016－JavaScript之星</a></h3><h3 id="JavaScript-启动性能瓶颈分析与解决方案"><a href="#JavaScript-启动性能瓶颈分析与解决方案" class="headerlink" title="JavaScript 启动性能瓶颈分析与解决方案"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247484987&amp;idx=1&amp;sn=7f20da20bc6baed62ca8ff115209942b&amp;chksm=972364f9a054edefccebc89bb4b39150328f84fc6a3da53dafa9563df7375fef00b3a1a4c483&amp;mpshare=1&amp;scene=1&amp;srcid=0213dAmdg84IPINoZZxbZPTH#rd" target="_blank" rel="external">JavaScript 启动性能瓶颈分析与解决方案</a></h3><h3 id="JavaScript-数组方法对比"><a href="#JavaScript-数组方法对比" class="headerlink" title="JavaScript 数组方法对比"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651225575&amp;idx=1&amp;sn=b25f4e9aaf7ba48f97f7ee0e266edd39&amp;chksm=bd49a4638a3e2d75e9df776fc6a2fc7cfc7c182867f92771367935e2cafce7cc18a078eb0f3c&amp;mpshare=1&amp;scene=1&amp;srcid=0209qfeI7mg9ILGs7hpiJhZ7#rd" target="_blank" rel="external">JavaScript 数组方法对比</a></h3><h3 id="javascript实现排序算法"><a href="#javascript实现排序算法" class="headerlink" title="javascript实现排序算法"></a><a href="https://segmentfault.com/a/1190000006899632" target="_blank" rel="external">javascript实现排序算法</a></h3><h3 id="扩展运算符的6个重要用途"><a href="#扩展运算符的6个重要用途" class="headerlink" title="扩展运算符的6个重要用途"></a><a href="https://rockjins.js.org/2017/02/09/spread-operator/" target="_blank" rel="external">扩展运算符的6个重要用途</a></h3><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="为什么学前端"><a href="#为什么学前端" class="headerlink" title="为什么学前端"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjAzMDA1MQ==&amp;mid=2648945771&amp;idx=1&amp;sn=846eccef058fa7789cfd831f5740f631&amp;scene=0#wechat_redirect" target="_blank" rel="external">为什么学前端</a></h3><h3 id="你真的了解setTimeout和setInterval吗？"><a href="#你真的了解setTimeout和setInterval吗？" class="headerlink" title="你真的了解setTimeout和setInterval吗？"></a><a href="http://qingbob.com/difference-between-settimeout-setinterval/" target="_blank" rel="external">你真的了解setTimeout和setInterval吗？</a></h3><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a><a href="http://mp.weixin.qq.com/s/Hcp60sfDOyXcP9TM0CX2Bw" target="_blank" rel="external">前端性能优化</a></h3><h3 id="界面组件化设计"><a href="#界面组件化设计" class="headerlink" title="界面组件化设计"></a><a href="https://github.com/fezaoduke/TranslationInstitute/blob/master/%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6%E5%8C%96%E8%AE%BE%E8%AE%A1.md" target="_blank" rel="external">界面组件化设计</a></h3><h3 id="CSS4-Selectors"><a href="#CSS4-Selectors" class="headerlink" title="CSS4 Selectors"></a><a href="https://gokulkrishh.github.io/css/2017/02/16/CSS4-selectors.html" target="_blank" rel="external">CSS4 Selectors</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="你是不是该跳槽了？"><a href="#你是不是该跳槽了？" class="headerlink" title="你是不是该跳槽了？"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713033&amp;idx=1&amp;sn=3b4add19dda1ae277868528edabc31b4&amp;chksm=bec0659a89b7ec8cc0213bf055c5b727b2660b7c33f358810c292520539baec8dc0943e6cae3&amp;mpshare=1&amp;scene=1&amp;srcid=0217aS0DFFlvnQJp0WZyfAH9#rd" target="_blank" rel="external">你是不是该跳槽了？</a></h3><p>公司是不是在成长？你自己是不是在成长？公司的成长和自己有没有关系？干的开不开心？如果这几个问题都是肯定的回答，那么就该留下共同成长。反之就该毫不犹豫的离开</p>
<h3 id="不学会这个，跳槽，永远解决不了问题！！！"><a href="#不学会这个，跳槽，永远解决不了问题！！！" class="headerlink" title="不学会这个，跳槽，永远解决不了问题！！！"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAwMTQ4MjUxOQ==&amp;mid=2455353498&amp;idx=1&amp;sn=b7378bb0b6fe838be758b11da1bc46f7&amp;chksm=8d7412e2ba039bf43dc230abf4c0ca6dd00fd5056df69fc91ebbb751e6ee50778ec854dcc08d&amp;mpshare=1&amp;scene=1&amp;srcid=02099iM3bNl94v33mVPMZNWp#rd" target="_blank" rel="external">不学会这个，跳槽，永远解决不了问题！！！</a></h3><p>跳槽是规划未来，而不是逃避现在；自己内在的问题，跳槽解决不了的；跳槽，是为了更好的外部环境</p>
<h3 id="程序员职业生涯巡礼"><a href="#程序员职业生涯巡礼" class="headerlink" title="程序员职业生涯巡礼"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713017&amp;idx=1&amp;sn=e85b005041cd76e4ae5bbbc1623095c4&amp;chksm=bec065ea89b7ecfcde5771d6f4032a6eb962052a6daa6db30630747a0e1633fee067ed8202e0&amp;mpshare=1&amp;scene=1&amp;srcid=0206Ja6WbmRXBs8yb0GVAgEj#rd" target="_blank" rel="external">程序员职业生涯巡礼</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2.20-2.24，我预见了所有悲伤，但依然愿意前往&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;假如未来已经设定&quot;&gt;&lt;a href=&quot;#假如未来已经设定&quot; class=&quot;headerlink&quot; title=&quot;假如未来已经设定&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650713029&amp;amp;idx=1&amp;amp;sn=2a8fa3a0f0980e08f85884ddf4c69cb8&amp;amp;chksm=bec0659689b7ec805b636d54cbb0d041283c004941a025bb69ed6d56606af734124da58e67ae&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0214ZjRyXl5OqRZgInG4xTkI#rd&quot;&gt;假如未来已经设定&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我预见了所有悲伤，但依然愿意前往，脑洞很大的文章，你有没有想过如果未来是已经确定，就像手心的纹路确定了我们的命运一样&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-简史：JavaScript-的过去、现在和未来&quot;&gt;&lt;a href=&quot;#JavaScript-简史：JavaScript-的过去、现在和未来&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 简史：JavaScript 的过去、现在和未来&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;amp;mid=2650964302&amp;amp;idx=1&amp;amp;sn=58cedeefd6390b642cb9b3d36645bc43&amp;amp;chksm=843aed28b34d643eacb32c9005a1bcf816b0b11e965df5408045efa677b7fe9c04c00d8d7f70&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0218Ka8Y2Dt48RKcIueksYsr#rd&quot;&gt;JavaScript 简史：JavaScript 的过去、现在和未来&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;我看到最全的js历史，从诞生到现在，每一次成长在这里都有记录，js发展到今天历史上有一些关键点和关键的人和公司&lt;/p&gt;
&lt;h3 id=&quot;职场中脱颖而出的成长秘诀&quot;&gt;&lt;a href=&quot;#职场中脱颖而出的成长秘诀&quot; class=&quot;headerlink&quot; title=&quot;职场中脱颖而出的成长秘诀&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651225540&amp;amp;idx=1&amp;amp;sn=0e18e698880f426ddca78bf7fa3640ee&amp;amp;chksm=bd49a4408a3e2d56c4797aa49d7f3f0380ab58ad06b2d92a7d9df86b32eee82f6decd5ab660f&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0208fCIyROm3JSq69KeCtWdL#rd&quot;&gt;职场中脱颖而出的成长秘诀&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;跳槽季了，结尾推荐了一些跳槽的指导文章，但我认为更重要的是如何让自己脱颖而出&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>从一道面试题的进阶，到“我可能看了假源码”（2）</title>
    <link href="https://exp-team.github.io/blog/2017/02/20/js/es5-shim-bind/"/>
    <id>https://exp-team.github.io/blog/2017/02/20/js/es5-shim-bind/</id>
    <published>2017-02-19T16:00:00.000Z</published>
    <updated>2017-02-20T00:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://exp-team.github.io/blog/2017/01/20/js/bind/">从一道面试题的进阶，到“我可能看了假源码”</a>中，由浅入深介绍了关于一篇经典面试题的解法。<br>最后在皆大欢喜的结尾中，突生变化，悬念又起。这一篇，就是为了解开这个悬念。</p>
<p>如果你还没有看过<a href="https://exp-team.github.io/blog/2017/01/20/js/bind/">前传</a>，可以参看前情回顾：</p>
<p>回顾1. 题目是模拟实现ES5中原生bind函数；<br>回顾2. 我们通过4种递进实现达到了完美状态；<br>回顾3. 可是ES5-shim中的实现，又让我们大跌眼镜…</p>
<h2 id="ES5-shim的悬念"><a href="#ES5-shim的悬念" class="headerlink" title="ES5-shim的悬念"></a>ES5-shim的悬念</h2><p>ES5-shim实现方式源码贴在了最后，我们看看他做了什么奇怪的事情：<br>1）从结果上看，返回了bound函数。<br>2）bound函数是这样子声明的：</p>
<pre><code>bound = Function(&apos;binder&apos;, &apos;return function (&apos; + boundArgs.join(&apos;,&apos;) + &apos;){ return binder.apply(this, arguments); }&apos;)(binder);
</code></pre><p>3）bound使用了系统自己的构造函数Function来声明，第一个参数是binder，函数体内又binder.apply(this, arguments)。<br>我们知道这种动态创建函数的方式，类似eval。最好不要使用它，因为用它定义函数比用传统方式要慢得多。<br>4）那么ES5-shim抽风了吗？</p>
<h2 id="追根问底"><a href="#追根问底" class="headerlink" title="追根问底"></a>追根问底</h2><p>答案肯定是没抽风，他这样做是有理由的。</p>
<h3 id="神秘的函数的length属性"><a href="#神秘的函数的length属性" class="headerlink" title="神秘的函数的length属性"></a>神秘的函数的length属性</h3><p>你可能不知道，每个函数都有length属性。对，就像数组和字符串那样。函数的length属性，用于表示函数的形参个数。更重要的是函数的length属性值是不可重写的。我写了个测试代码来证明：</p>
<pre><code>function test (){}
test.length  // 输出0
test.hasOwnProperty(&apos;length&apos;)  // 输出true
Object.getOwnPropertyDescriptor(&apos;test&apos;, &apos;length&apos;) 
// 输出：
// configurable: false, 
// enumerable: false,
// value: 4, 
// writable: false 
</code></pre><h3 id="拨云见日"><a href="#拨云见日" class="headerlink" title="拨云见日"></a>拨云见日</h3><p>说到这里，那就好解释了。<br>ES5-shim是为了最大限度的进行兼容，包括对返回函数length属性的还原。如果按照我们之前实现的那种方式，length值始终为零。<br>所以：既然不能修改length的属性值，那么在初始化时赋值总可以吧！<br>于是我们可通过eval和new Function的方式动态定义函数来。<br>同时，很有意思的是，源码里有这样的注释：</p>
<pre><code>// XXX Build a dynamic function with desired amount of arguments is the only
// way to set the length property of a function.
// In environments where Content Security Policies enabled (Chrome extensions,
// for ex.) all use of eval or Function costructor throws an exception.
// However in all of these environments Function.prototype.bind exists
// and so this code will never be executed.
</code></pre><p>他解释了为什么要使用动态函数，就如同我们上边所讲的那样，是为了保证length属性的合理值。但是在一些浏览器中出于安全考虑，使用eval或者Function构造器都会被抛出异常。但是，巧合也就是这些浏览器基本上都实现了bind函数，这些异常又不会被触发。</p>
<p>So, What a coincidence!</p>
<h3 id="叹为观止"><a href="#叹为观止" class="headerlink" title="叹为观止"></a>叹为观止</h3><p>我们明白了这些，再看他的进一步实现：</p>
<pre><code>if (!isCallable(target)) {
    throw new TypeError(&apos;Function.prototype.bind called on incompatible &apos; + target);
}
</code></pre><p>这是为了保证调用的正确性，他使用了isCallable做判断，isCallable很好实现：</p>
<pre><code>isCallable = function isCallable(value) { 
    if (typeof value !== &apos;function&apos;) { 
        return false; 
    }
}
</code></pre><p>重设绑定函数的length属性：</p>
<pre><code>var boundLength = max(0, target.length - args.length);
</code></pre><p>构造函数调用情况，在binder中也有效兼容。如果你不明白什么是构造函数调用情况，可以参考<a href="https://exp-team.github.io/blog/2017/01/20/js/bind/">上一篇</a>。</p>
<pre><code>if (this instanceof bound) { 
    ... // 构造函数调用情况
} else {
    ... // 正常方式调用
}

if (target.prototype) {
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    // Clean up dangling references.
    Empty.prototype = null;
}
</code></pre><h2 id="无穷无尽"><a href="#无穷无尽" class="headerlink" title="无穷无尽"></a>无穷无尽</h2><p>当然，ES5-shim里还归纳了几项todo…</p>
<pre><code>// TODO
// 18. Set the [[Extensible]] internal property of F to true.
// 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
// 20. Call the [[DefineOwnProperty]] internal method of F with
//   arguments &quot;caller&quot;, PropertyDescriptor {[[Get]]: thrower, [[Set]]:
//   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
//   false.
// 21. Call the [[DefineOwnProperty]] internal method of F with
//   arguments &quot;arguments&quot;, PropertyDescriptor {[[Get]]: thrower,
//   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
//   and false.
// 22. Return F.
</code></pre><p>比较简单，我就不再翻译了。</p>
<h2 id="源码回放"><a href="#源码回放" class="headerlink" title="源码回放"></a>源码回放</h2><pre><code>bind: function bind(that) {
    var target = this;
    if (!isCallable(target)) {
        throw new TypeError(&apos;Function.prototype.bind called on incompatible &apos; + target);
    }
    var args = array_slice.call(arguments, 1);
    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                array_concat.call(args, array_slice.call(arguments))
            );
            if ($Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                array_concat.call(args, array_slice.call(arguments))
            );
        }
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i &lt; boundLength; i++) {
        array_push.call(boundArgs, &apos;$&apos; + i);
    }
    bound = Function(&apos;binder&apos;, &apos;return function (&apos; + boundArgs.join(&apos;,&apos;) + &apos;){ return binder.apply(this, arguments); }&apos;)(binder);

    if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过学习ES5-shim的源码实现bind方法，结合前一篇，希望读者能对bind和JS包括闭包，原型原型链，this等一系列知识点能有更深刻的理解。<br>同时在程序设计上，尤其是逻辑的严密性上，有所积累。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇&lt;a href=&quot;https://exp-team.github.io/blog/2017/01/20/js/bind/&quot;&gt;从一道面试题的进阶，到“我可能看了假源码”&lt;/a&gt;中，由浅入深介绍了关于一篇经典面试题的解法。&lt;br&gt;最后在皆大欢喜的结尾中，突生变化，悬念又起
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从一道面试题的进阶，到“我可能看了假源码”</title>
    <link href="https://exp-team.github.io/blog/2017/02/20/js/bind/"/>
    <id>https://exp-team.github.io/blog/2017/02/20/js/bind/</id>
    <published>2017-02-19T16:00:00.000Z</published>
    <updated>2017-02-22T13:52:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天想谈谈一道前端面试题，我做面试官的时候经常喜欢用它来考察面试者的基础是否扎实，以及逻辑、思维能力和临场表现，题目是：“模拟实现ES5中原生bind函数”。<br>也许这道题目已经不再新鲜，部分读者也会有思路来解答。社区上关于原生bind的研究也很多，比如用它来实现函数“颗粒化（currying）”，<br>或者“反颗粒化（uncurrying）”。<br>但是，我确信有很多细节是您注意不到的，也是社区上关于这个话题普遍缺失的。<br>这篇文章面向有较牢固JS基础的读者，会从最基本的理解入手，一直到分析ES5-shim实现bind源码，相信不同程度的读者都能有所收获。<br>也欢迎大家与我讨论。</p>
<h2 id="bind函数究竟是什么"><a href="#bind函数究竟是什么" class="headerlink" title="bind函数究竟是什么?"></a>bind函数究竟是什么?</h2><p>在开启我们的探索之前，有必要先明确一下bind到底实现了什么：<br>1）简单粗暴地来说，bind是用于绑定this指向的。（如果你还不了解JS中this的指向问题，以及执行环境上下文的奥秘，这篇文章暂时就不太适合阅读）。</p>
<p>2）bind使用语法：</p>
<pre><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])
</code></pre><p>bind方法会创建一个新函数。当这个新函数被调用时，bind的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。本文不打算科普基础，如果您还不清楚，请<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">参考MDN内容</a>。</p>
<p>3)bind返回的绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给模拟函数。</p>
<h2 id="初级实现"><a href="#初级实现" class="headerlink" title="初级实现"></a>初级实现</h2><p>了解了以上内容，我们来实现一个初级的bind函数Polyfill:</p>
<pre><code>Function.prototype.bind = function (context) {
    var me = this;
    var argsArray = Array.prototype.slice.call(arguments);
    return function () {
        return me.apply(context, argsArray.slice(1))
    }
}
</code></pre><p>这是一般“表现良好”的面试者所能给我提供的答案，如果面试者能写到这里，我会给他60分。<br>我们先简要解读一下：<br>基本原理是使用apply进行模拟。函数体内的this，就是需要绑定this的实例函数，或者说是原函数。最后我们使用apply来进行参数（context）绑定，并返回。<br>同时，将第一个参数（context）以外的其他参数，作为提供给原函数的预设参数，这也是基本的“颗粒化（curring）”基础。</p>
<h2 id="初级实现的加分项"><a href="#初级实现的加分项" class="headerlink" title="初级实现的加分项"></a>初级实现的加分项</h2><p>上面的实现（包括后面的实现），其实是一个典型的<a href="https://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="external">“Monkey patching(猴子补丁)”</a>，即“给内置对象扩展方法”。所以，如果面试者能进行一下“嗅探”，进行兼容处理，就是锦上添花了，我会给10分的附加分。</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) {
    ...
}
</code></pre><h2 id="颗粒化（curring）实现"><a href="#颗粒化（curring）实现" class="headerlink" title="颗粒化（curring）实现"></a>颗粒化（curring）实现</h2><p>上述的实现方式中，我们返回的参数列表里包含：atgsArray.slice(1)，他的问题在于存在预置参数功能丢失的现象。<br>想象我们返回的绑定函数中，如果想实现预设传参（就像bind所实现的那样），就面临尴尬的局面。真正实现颗粒化的“完美方式”是：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(context, finalArgs);
    }
}
</code></pre><p>如果面试者能够给出这样的答案，我内心独白会是“不错啊，貌似你就是我要找的那个TA～”。但是，我们注意在上边bind方法介绍的第三条提到：bind返回的函数如果作为构造函数，搭配new关键字出现的话，我们的绑定this就需要“被忽略”。</p>
<h2 id="构造函数场景下的兼容"><a href="#构造函数场景下的兼容" class="headerlink" title="构造函数场景下的兼容"></a>构造函数场景下的兼容</h2><p>有了上边的讲解，不难理解需要兼容构造函数场景的实现：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var F = function () {};
    F.prototype = this.prototype;
    var bound = function () {
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(this instanceof F ? this : context || this, finalArgs);
    }
    bound.prototype = new F();
    return bound;
}
</code></pre><p>如果面试者能够写成这样，我几乎要给满分，会帮忙联系HR谈薪酬了。当然，还可以做的更加严谨。</p>
<h2 id="更严谨的做法"><a href="#更严谨的做法" class="headerlink" title="更严谨的做法"></a>更严谨的做法</h2><p>我们需要调用bind方法的一定要是一个函数，所以可以在函数体内做一个判断：</p>
<pre><code>if (typeof this !== &quot;function&quot;) {
  throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}
</code></pre><p>做到所有这一切，我会很开心的给满分。其实MDN上有个自己实现的polyfill，就是如此实现的。<br>另外，《JavaScript Web Application》一书中对bind()的实现，也是如此。</p>
<p>故事貌似要画上休止符了——</p>
<h2 id="一切还没完，高潮即将上演"><a href="#一切还没完，高潮即将上演" class="headerlink" title="一切还没完，高潮即将上演"></a>一切还没完，高潮即将上演</h2><p>如果你认为这样就完了，其实我会告诉你说，高潮才刚要上演。曾经的我也认为上述方法已经比较完美了，直到我看了es5-shim源码（已适当删减）：</p>
<pre><code>bind: function bind(that) {
    var target = this;
    if (!isCallable(target)) {
        throw new TypeError(&apos;Function.prototype.bind called on incompatible &apos; + target);
    }
    var args = array_slice.call(arguments, 1);
    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                array_concat.call(args, array_slice.call(arguments))
            );
            if ($Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                array_concat.call(args, array_slice.call(arguments))
            );
        }
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i &lt; boundLength; i++) {
        array_push.call(boundArgs, &apos;$&apos; + i);
    }
    bound = Function(&apos;binder&apos;, &apos;return function (&apos; + boundArgs.join(&apos;,&apos;) + &apos;){ return binder.apply(this, arguments); }&apos;)(binder);

    if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
}
</code></pre><p>看到了这样的实现，心中的困惑太多，不禁觉得我看了“假源码”。但是仔细分析一下，剩下就是一个大写的 。。。服！<br>这里先留一个悬念，不进行源码分析。读者可以自己先研究一下。如果想看源码分析，点击<a href="https://exp-team.github.io/blog/2017/02/20/js/es5-shim-bind/">这篇文章的后续－源码解读</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过比对几版的polyfill实现，对于bind应该有了比较深刻的认识。作为这道面试题的考察点，肯定不是让面试者实现低版本浏览器的向下兼容，因为我们有了es5-shim,es5-sham处理兼容性问题，并且无脑兼容我也认为是历史的倒退。<br>回到这道题考查点上，他有效的考察了很重要的知识点：比如this的指向，JS的闭包，原型原型链功力，设计程序上的兼容考虑等等硬素质。<br>在前端技术快速发展迭代的今天，在“前端市场是否饱和”“前端求职火爆异常”“前端入门简单，钱多人傻”的浮躁环境下，对基础内功的修炼就显得尤为重要，这也是你在前端路上能走多远、走多久的关键。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想谈谈一道前端面试题，我做面试官的时候经常喜欢用它来考察面试者的基础是否扎实，以及逻辑、思维能力和临场表现，题目是：“模拟实现ES5中原生bind函数”。&lt;br&gt;也许这道题目已经不再新鲜，部分读者也会有思路来解答。社区上关于原生bind的研究也很多，比如用它来实现函数“
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>伍酱的2016</title>
    <link href="https://exp-team.github.io/blog/2017/01/21/other/wujiang-2016/"/>
    <id>https://exp-team.github.io/blog/2017/01/21/other/wujiang-2016/</id>
    <published>2017-01-20T16:00:00.000Z</published>
    <updated>2017-02-19T12:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>二零一六年，是对我来说非常不一样的一年。</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/me.JPG" alt="&quot;Cooks Beach&quot;"></p>
<h2 id="例行总结"><a href="#例行总结" class="headerlink" title="例行总结"></a>例行总结</h2><ul>
<li>读书41本，目标50，<strong>不达标</strong>；</li>
<li>理财，实盘-7.17%，大盘沪指-12.31%，跑赢大盘，目标10%，<strong>不达标</strong>；（出国期间管都没管，要什么自行车）</li>
<li>2016年的技术规划，在我离职时把我能做的都做完了，<strong>get√</strong></li>
<li>新西兰环岛，<strong>get√</strong></li>
</ul>
<p>搞siao，啥都不达标，总结啥！？哦~</p>
<a id="more"></a>
<h2 id="此处开始-——-抒情随意总结"><a href="#此处开始-——-抒情随意总结" class="headerlink" title="此处开始 —— 抒情随意总结"></a>此处开始 —— 抒情随意总结</h2><p>2016年6月，结束了在大百度的工作，我贡献了3年多青春的”初恋”。上半年的故事，之前在<a href="/archives/resign-from-baidu/">《离职这件小事》</a>里已经说得差不多了，姑且当做上半年总结吧。</p>
<p>希望鸡神眷顾我找到靠谱的新工作~</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/chicken.JPG" alt=""></p>
<p>随后，说走就走，开展了为期6个月的新西兰打工旅行。换宿、<a href="/archives/work-whv/">打季节工</a>、半年换了3辆战车、以露营为主的自驾环南北岛……从来没有过那么颠沛流离、充满对未知的恐惧，当然也带着一丝对未来小刺激的期待，像我之前说的，每一天都需要勇气来生活。</p>
<p>2016年下半年的生活的可能性和丰富度，时间只有半年，却比我以往的26年都要多，刺激得不行不行的。于是我变成了一个有故事的女同学，哈哈，故事、人物和感受太多，一时之间，不知从何说起。（让你懒惰之前不写日志！！）</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/farm.JPG" alt="&quot;Kerikeri Nursery&quot;"></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/hitch-hike.JPG" alt="&quot;Hitch hike in Paihia&quot;"></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/fishing.JPG" alt="&quot;Fishing&quot;"></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/Tongariro.JPG" alt="&quot;Tongariro National Park&quot;"></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/camp.JPG" alt="&quot;camping&quot;"></p>
<p>原本有占据2页的篇幅（写于奥克兰机场），记录一个我精心挑选的年度最佳的故事，但是在跟我爸妈聊天后，我决定删掉。出来行走江湖，谁没有几个悲伤的故事，不用时刻拿出来卖惨，我重新认识一个<strong>坚强和强悍抗压的自己</strong>已经够了，哈哈，成长的代价。</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/deleted-post.JPG" alt=""></p>
<p>很好奇发生了什么是不是？我就不说~ 简而言之，就是发生了一个（或者几个）小插曲，让我变得一无所有，差点没有办法回国，我崩溃了一小下，不过很快收拾好心情妥善处理好一切。这些我当时没有跟任何人说，几个小伙伴知道都是我事后说的，不想家人或者朋友干担心瞎着急。</p>
<p>前几天，我跟爸妈说起我在新西兰经历的各种，也包括那些小插曲，并没有收到爸妈的安慰，那个瞬间我真怀疑自己到底是不是亲生的，哈哈。我遇到的“大麻烦”，在阅历丰富的爸妈眼里，不值一提。</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/car.JPG" alt=""></p>
<p>爸妈说：</p>
<blockquote>
<p>你以为自己有多大损失、多委屈，比起你能安全回国，根本不算事儿。你出发之前，我们劝你不要停留那么久，在那边玩2、3个礼拜就算了。但是你坚持要留那么久，我们也只能支持你。</p>
<p>发生这样的事情，完全在我们意料之中，这就是为什么你出国前我们联系到奥克兰的阿姨，让你有事去找她帮忙。你在国外时，我们每天都在担心。你会不会开车冲下山？会不会撞到别人？会不会遇到坏人？会不会失联，从此人间蒸发？</p>
</blockquote>
<p>惊奇地发现，在我出发前后，他们说的话是一样的，但作为听众的我，感受却大不相同。真倒霉起来，老天爷要耍我的话，他们担心的事情是真会变成现实的，最坏情况是客死异乡，而我在途中真实遇到的若干次意外，跟死神擦身而过。细思极恐，他们的担心不无道理，真苦了他们天天为我担惊受怕。</p>
<p><strong>感谢爸妈</strong>，在那么担心的情况下，没有干预我的决定，尊重我的选择。<br><strong>感谢老天</strong>，我顺利安全回国了。</p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/airport.JPG" alt="&quot;Auckland Airport&quot;"></p>
<h2 id="神秘的旅伴-——-猩爷"><a href="#神秘的旅伴-——-猩爷" class="headerlink" title="神秘的旅伴 —— 猩爷"></a>神秘的旅伴 —— 猩爷</h2><p>嗯，虽然我自认为找工作、沟通和抗压的技能指数爆表（了不起！）但是这一路走下来，我特别想<strong>感谢我的旅伴 —— 猩爷</strong></p>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/b-1.JPG" alt="&quot;猩爷的沙滩写真&quot;"></p>
<p>旅行是最能看清楚一个人的时候，因为大家会遇到各种难题各种令人崩溃的事情，变态、极端到你这辈子可能都不会再有机会遇到。我崩溃的时候，还是她把我拉回来的，真真了不起！</p>
<ul>
<li>吃苦耐劳</li>
<li>一身洪荒之力无处释放</li>
<li>做得一桌好菜</li>
<li>搭得一顶好帐篷</li>
<li>开得一手好车（自称“青秀山车神”）</li>
<li>夕阳红爬山队的教练和打杂</li>
</ul>
<p><img src="http://cdn.sinacloud.net/woodysblog/2016/b-2.JPG" alt="&quot;悬崖边上的猩爷&quot;"></p>
<p>在那么艰苦的荒野求生中，我还是长胖了，真的要好好感谢她（咬牙切齿）</p>
<p>（上述各种都是猩爷做，你做了什么？）噢~ 我一般什么都不做，在旁边做<strong>鼓励师</strong>和<strong>卖萌机器人</strong>，衬托能干的她，哈哈哈！</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p><code>问</code> 澳洲的WHV签证还申请吗？<br><code>答</code> 不要。这半年我感觉够够的，后悔得要死，跟我想的完全不一样。短期内也不想旅行了，哈哈。</p>
<p><code>问</code> 如果时光倒流，可以再选一次，还要去新西兰吗？<br><code>答</code> 去啊，说走还走！不去永远不知道，喜欢或者不喜欢，开心抑或不开心，总得经历过才知道，美不在天堂，而在前往天堂的路上，也许这就是成长的代价吧。</p>
<p>原文链接：<a href="http://www.wuyuying.com/archives/year-2016?fr=exp-fe" target="_blank" rel="external">http://www.wuyuying.com/archives/year-2016/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二零一六年，是对我来说非常不一样的一年。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.sinacloud.net/woodysblog/2016/me.JPG&quot; alt=&quot;&amp;quot;Cooks Beach&amp;quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;例行总结&quot;&gt;&lt;a href=&quot;#例行总结&quot; class=&quot;headerlink&quot; title=&quot;例行总结&quot;&gt;&lt;/a&gt;例行总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;读书41本，目标50，&lt;strong&gt;不达标&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;理财，实盘-7.17%，大盘沪指-12.31%，跑赢大盘，目标10%，&lt;strong&gt;不达标&lt;/strong&gt;；（出国期间管都没管，要什么自行车）&lt;/li&gt;
&lt;li&gt;2016年的技术规划，在我离职时把我能做的都做完了，&lt;strong&gt;get√&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;新西兰环岛，&lt;strong&gt;get√&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;搞siao，啥都不达标，总结啥！？哦~&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="https://exp-team.github.io/categories/other/"/>
    
    
      <category term="other" scheme="https://exp-team.github.io/tags/other/"/>
    
      <category term="summary" scheme="https://exp-team.github.io/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10101期</title>
    <link href="https://exp-team.github.io/blog/2017/01/21/weekly/weekly-10101/"/>
    <id>https://exp-team.github.io/blog/2017/01/21/weekly/weekly-10101/</id>
    <published>2017-01-20T16:00:00.000Z</published>
    <updated>2017-02-19T12:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.16-1.21，马上要放假了，提前祝大家春节快乐，年终总结还没写的抓紧了，本期送个大家一副对联</p>
<p>上联：微博知乎占头条谁与争锋</p>
<p>下联：桌面移动待前端一统江湖</p>
<p>横批：瞬息万变</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="二十个令程序员泪流满面的瞬间"><a href="#二十个令程序员泪流满面的瞬间" class="headerlink" title="二十个令程序员泪流满面的瞬间"></a><a href="http://mp.weixin.qq.com/s?__biz=MzI2MzEzNzQ3MQ==&amp;mid=2650307110&amp;idx=1&amp;sn=e7a247e1dd3b86d3441806ad24cb094c&amp;chksm=f24cabf6c53b22e086a09b8481b10879f073e56073290e4f75dddb55cc74ff2b0d76ea15dad0&amp;mpshare=1&amp;scene=1&amp;srcid=0119Hrto64icL7EJf7WWxzwI#rd" target="_blank" rel="external">二十个令程序员泪流满面的瞬间</a></h3><p>只有程序员能看懂的gif图，感同身受，泪流满面啊，%&gt;_&lt;%</p>
<h3 id="2017年的前端该学些什么-md"><a href="#2017年的前端该学些什么-md" class="headerlink" title="2017年的前端该学些什么.md"></a><a href="https://github.com/fezaoduke/TranslationInstitute/blob/master/2017%E5%B9%B4%E7%9A%84%E5%89%8D%E7%AB%AF%E8%AF%A5%E5%AD%A6%E4%BA%9B%E4%BB%80%E4%B9%88.md" target="_blank" rel="external">2017年的前端该学些什么.md</a></h3><p>17年你打算学点啥？给自己设定好规划了没？还在迷茫的同学看看这篇文章吧，2017一起加油</p>
<h3 id="搜罗一切webpack的好文章好工具"><a href="#搜罗一切webpack的好文章好工具" class="headerlink" title="搜罗一切webpack的好文章好工具"></a><a href="https://github.com/webpack-china/awesome-webpack-cn" target="_blank" rel="external">搜罗一切webpack的好文章好工具</a></h3><p>webpakc2发布了，又到了伤筋动骨，加班熬夜的时候了，关于webpack的一切文章都在这里</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="掌握这5大核心概念，你就理解了React"><a href="#掌握这5大核心概念，你就理解了React" class="headerlink" title="掌握这5大核心概念，你就理解了React"></a><a href="https://zhuanlan.zhihu.com/p/24833815" target="_blank" rel="external">掌握这5大核心概念，你就理解了React</a></h3><p>react就这5个东西，还没入门的同学，或者深陷其中的同学快来围观，react不难，难得是用react做东西</p>
<h3 id="一个react-redux工程实例"><a href="#一个react-redux工程实例" class="headerlink" title="一个react+redux工程实例"></a><a href="http://www.jianshu.com/p/8e28be0e7ab1?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-friends" target="_blank" rel="external">一个react+redux工程实例</a></h3><h3 id="揭秘babel的魔法之class继承的处理2"><a href="#揭秘babel的魔法之class继承的处理2" class="headerlink" title="揭秘babel的魔法之class继承的处理2"></a><a href="http://www.jianshu.com/p/95901615f322" target="_blank" rel="external">揭秘babel的魔法之class继承的处理2</a></h3><h3 id="全栈JS工程师的崛起"><a href="#全栈JS工程师的崛起" class="headerlink" title="全栈JS工程师的崛起"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651225356&amp;idx=1&amp;sn=4740cca7ab89b4449bfe5438e1427729&amp;chksm=bd49a4888a3e2d9e8c625d116fcc42db25c11421ba79d47dff272f0db8f6e5427d1bdbf3fe1b&amp;mpshare=1&amp;scene=1&amp;srcid=0120NQv87HQjc6Q50a1LLF0w#rd" target="_blank" rel="external">全栈JS工程师的崛起</a></h3><p>先精后广，一专多长，不想成为全栈的工程师，不是好工程师，一起加油</p>
<h3 id="250行实现一个简单的MVVM"><a href="#250行实现一个简单的MVVM" class="headerlink" title="250行实现一个简单的MVVM"></a><a href="https://zhuanlan.zhihu.com/p/24475845" target="_blank" rel="external">250行实现一个简单的MVVM</a></h3><p>一直想动手写一个mvvm框架，就从这篇文章开始吧</p>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="Google发布新的图像压缩技术，最高可节省75％带宽"><a href="#Google发布新的图像压缩技术，最高可节省75％带宽" class="headerlink" title="Google发布新的图像压缩技术，最高可节省75％带宽"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659598877&amp;idx=1&amp;sn=704e7d5a05adaff567c9adf015753124&amp;chksm=8be9970fbc9e1e191b0f3cf92a9dd6e76ad4a8d0fff38a30ed772033eb0ac10f6356d2a4f528&amp;mpshare=1&amp;scene=1&amp;srcid=0118TvMOVHhoZN10kF4DDpc6#rd" target="_blank" rel="external">Google发布新的图像压缩技术，最高可节省75％带宽</a></h3><h3 id="Bluebird-是如何做到比原生实现更快的？"><a href="#Bluebird-是如何做到比原生实现更快的？" class="headerlink" title="Bluebird 是如何做到比原生实现更快的？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964223&amp;idx=1&amp;sn=f2c37c05fb6ad370a67c59ca745bd7bf&amp;chksm=843aec99b34d658f043acdea3a3c5b948d664cff48947f4616ccebac4548c5b57978c0d3be38&amp;mpshare=1&amp;scene=1&amp;srcid=0117zptRUZNoEger5avSAAem#rd" target="_blank" rel="external">Bluebird 是如何做到比原生实现更快的？</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="你可能不知道的-Mac-技巧-文本操作"><a href="#你可能不知道的-Mac-技巧-文本操作" class="headerlink" title="你可能不知道的 Mac 技巧 - 文本操作"></a><a href="https://zhuanlan.zhihu.com/p/24921055" target="_blank" rel="external">你可能不知道的 Mac 技巧 - 文本操作</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.16-1.21，马上要放假了，提前祝大家春节快乐，年终总结还没写的抓紧了，本期送个大家一副对联&lt;/p&gt;
&lt;p&gt;上联：微博知乎占头条谁与争锋&lt;/p&gt;
&lt;p&gt;下联：桌面移动待前端一统江湖&lt;/p&gt;
&lt;p&gt;横批：瞬息万变&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;二十个令程序员泪流满面的瞬间&quot;&gt;&lt;a href=&quot;#二十个令程序员泪流满面的瞬间&quot; class=&quot;headerlink&quot; title=&quot;二十个令程序员泪流满面的瞬间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MzEzNzQ3MQ==&amp;amp;mid=2650307110&amp;amp;idx=1&amp;amp;sn=e7a247e1dd3b86d3441806ad24cb094c&amp;amp;chksm=f24cabf6c53b22e086a09b8481b10879f073e56073290e4f75dddb55cc74ff2b0d76ea15dad0&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0119Hrto64icL7EJf7WWxzwI#rd&quot;&gt;二十个令程序员泪流满面的瞬间&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;只有程序员能看懂的gif图，感同身受，泪流满面啊，%&amp;gt;_&amp;lt;%&lt;/p&gt;
&lt;h3 id=&quot;2017年的前端该学些什么-md&quot;&gt;&lt;a href=&quot;#2017年的前端该学些什么-md&quot; class=&quot;headerlink&quot; title=&quot;2017年的前端该学些什么.md&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/fezaoduke/TranslationInstitute/blob/master/2017%E5%B9%B4%E7%9A%84%E5%89%8D%E7%AB%AF%E8%AF%A5%E5%AD%A6%E4%BA%9B%E4%BB%80%E4%B9%88.md&quot;&gt;2017年的前端该学些什么.md&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;17年你打算学点啥？给自己设定好规划了没？还在迷茫的同学看看这篇文章吧，2017一起加油&lt;/p&gt;
&lt;h3 id=&quot;搜罗一切webpack的好文章好工具&quot;&gt;&lt;a href=&quot;#搜罗一切webpack的好文章好工具&quot; class=&quot;headerlink&quot; title=&quot;搜罗一切webpack的好文章好工具&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/webpack-china/awesome-webpack-cn&quot;&gt;搜罗一切webpack的好文章好工具&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;webpakc2发布了，又到了伤筋动骨，加班熬夜的时候了，关于webpack的一切文章都在这里&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10100期</title>
    <link href="https://exp-team.github.io/blog/2017/01/13/weekly/weekly-10100/"/>
    <id>https://exp-team.github.io/blog/2017/01/13/weekly/weekly-10100/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2017-01-13T12:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.8-1.13，新的一期，继续积累！</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="《JS-闯关记》之原型及原型链"><a href="#《JS-闯关记》之原型及原型链" class="headerlink" title="《JS 闯关记》之原型及原型链"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ%3D%3D&amp;mid=2650101216&amp;idx=1&amp;sn=dcc39636ebff46aca84df68533fb0742&amp;chksm=f07509c8c70280deb444e9ac5405982e0892f1331bdc02a48f4161dba0f27dcde8f4acf2cd07&amp;scene=0" target="_blank" rel="external">《JS 闯关记》之原型及原型链</a></h3><p>原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的<strong>proto</strong> 属性指向创建它的构造函数的 prototype（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、<strong>proto</strong> 这五个概念入手。</p>
<h3 id="H5项目常见问题及注意事项"><a href="#H5项目常见问题及注意事项" class="headerlink" title="H5项目常见问题及注意事项"></a><a href="http://www.open-open.com/lib/view/open1449325854077.html" target="_blank" rel="external">H5项目常见问题及注意事项</a></h3><p>再也不用为PM嘴中的“H5”发愁了。</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="揭秘babel的魔法之class魔法处理"><a href="#揭秘babel的魔法之class魔法处理" class="headerlink" title="揭秘babel的魔法之class魔法处理"></a><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjE5NzAyMA==&amp;mid=2649879842&amp;idx=1&amp;sn=0e7eb27fd9bb7f5ba9bbd2b3640ba663&amp;chksm=f0ded0d1c7a959c785fd8c8b384e348506ea4dd40ca72a8fac00aa4f34ab07aacab6aa92514b&amp;mpshare=1&amp;scene=1&amp;srcid=01132iAX9Sp6Gpll9otS2un8&amp;key=59506e83f2f7e1fd47b66ec743010bafb62e75b40f02a088b7a58ef822f0fcfe14c244308ee819c24dd7303946792d0ace78d7c18cb31a020ca5b42528939fa5ce021ed6ae7a77d738521132ff2afee9&amp;ascene=0&amp;uin=NjI4NTQ2ODIx&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46" target="_blank" rel="external">揭秘babel的魔法之class魔法处理</a></h3><p>揭秘Babel的同时，在复习一遍原型链基础支持～</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="如何让你的-CSS-更具有可维护性？——大神有绝招-amp"><a href="#如何让你的-CSS-更具有可维护性？——大神有绝招-amp" class="headerlink" title="如何让你的 CSS 更具有可维护性？——大神有绝招&amp;)"></a><a href="https://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964179&amp;idx=1&amp;sn=f7088de66f09efd35057541695582d52&amp;chksm=843aecb5b34d65a3ff8d67142403f3463e08f57041f4212e991248f49770b59943d5c65545bc&amp;mpshare=1&amp;scene=1&amp;srcid=0111H4YARr96el0lj1WY0J09&amp;key=f27a3d85b887ad782291dcbcbc6989e0bb3335f0f66ac9cc6b6994c455227fac808715c21fb47af4ad18b5ff25efbb9aca75f3d0bbf57baefb60f1d36971b42fa9d323e2b3d80208070837dfd770fa49&amp;ascene=0&amp;uin=NjI4NTQ2ODIx&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46" target="_blank" rel="external">如何让你的 CSS 更具有可维护性？——大神有绝招</a>&amp;)</h3><p>这篇文章教你一种方法，能够写出更具有可维护性的CSS，它就是”BEM”。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="回顾-2016-年-Node-js-十大文章-amp"><a href="#回顾-2016-年-Node-js-十大文章-amp" class="headerlink" title="回顾 2016 年 Node.js 十大文章&amp;)"></a><a href="https://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964196&amp;idx=1&amp;sn=d52e8258b54e0d807e14efa5a2791f84&amp;chksm=843aec82b34d65944704e1f7fc04747934bad078ad91906781f21edeb204a9a55f4d9f129369&amp;mpshare=1&amp;scene=1&amp;srcid=0111eOoheFnpABemlLvmHvL9&amp;key=b43a3af60b96e11e86b22b45b526335d70f3fbb0d1f05d664eb97888d1744e7026b64c4bdae93ab2ceb9092123f81dfcaecf157e9a43e4e2bed516a6b9db9e4e0fe03330913f5cfcf971d9ac46dfaf8e&amp;ascene=0&amp;uin=NjI4NTQ2ODIx&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.4+build(14E46" target="_blank" rel="external">回顾 2016 年 Node.js 十大文章</a>&amp;)</h3><p>对于Node.js开发者来说，2016是振奋人心的一年。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.8-1.13，新的一期，继续积累！&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;《JS-闯关记》之原型及原型链&quot;&gt;&lt;a href=&quot;#《JS-闯关记》之原型及原型链&quot; class=&quot;headerlink&quot; title=&quot;《JS 闯关记》之原型及原型链&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ%3D%3D&amp;amp;mid=2650101216&amp;amp;idx=1&amp;amp;sn=dcc39636ebff46aca84df68533fb0742&amp;amp;chksm=f07509c8c70280deb444e9ac5405982e0892f1331bdc02a48f4161dba0f27dcde8f4acf2cd07&amp;amp;scene=0&quot;&gt;《JS 闯关记》之原型及原型链&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的&lt;strong&gt;proto&lt;/strong&gt; 属性指向创建它的构造函数的 prototype（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从函数对象、constructor、new、prototype、&lt;strong&gt;proto&lt;/strong&gt; 这五个概念入手。&lt;/p&gt;
&lt;h3 id=&quot;H5项目常见问题及注意事项&quot;&gt;&lt;a href=&quot;#H5项目常见问题及注意事项&quot; class=&quot;headerlink&quot; title=&quot;H5项目常见问题及注意事项&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1449325854077.html&quot;&gt;H5项目常见问题及注意事项&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;再也不用为PM嘴中的“H5”发愁了。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>如何使用PAC文件“科学上网”</title>
    <link href="https://exp-team.github.io/blog/2017/01/13/tool/using-pac/"/>
    <id>https://exp-team.github.io/blog/2017/01/13/tool/using-pac/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2017-01-15T12:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>万里长城是我们中华民族的瑰宝，是我们民族的骄傲，是世界八大奇迹之一，是我们中华的代表，它让我们避免了外族的侵略！</p>
<p>嗯，不过对我们现代中华儿女，我们要做的就是！翻越它去征服世界上所有的蛮夷之地！</p>
<a id="more"></a>
<h2 id="GFW"><a href="#GFW" class="headerlink" title="GFW"></a>GFW</h2><p>令人敬畏的Great Fire Wall，说起他的由来。。。等下，我有个顺丰快递。</p>
<h2 id="为什么要“科学上网”"><a href="#为什么要“科学上网”" class="headerlink" title="为什么要“科学上网”"></a>为什么要“科学上网”</h2><p>由于GFW的存在，我们失去了不少与友善外族沟通交流的机会，例如Facebook，Twitter，Instagram。我们只能靠那些处于水深火热环境中的朋友给我们搬运回来外族的消息。不过据说这些东西也不好玩，毕竟上面大部分都是外族百姓，我们不玩也罢。</p>
<p>然而！对我们技术宅们，不能与外族高端人士沟通，实属悲哀之事。既然州官不让，那百姓们就自己想办法咯。</p>
<p>“科学上网”方法其实有很多，今天介绍一个我个人比较认同的一个方法吧。</p>
<h2 id="通过PAC文件“科学上网”"><a href="#通过PAC文件“科学上网”" class="headerlink" title="通过PAC文件“科学上网”"></a>通过PAC文件“科学上网”</h2><p>首先，你要有一个可用的代理。没有代理的话就自己想办法搞一个吧。我不教╭(╯^╰)╮</p>
<p>PAC(Proxy Auto Config)实际上就是一个脚本(Script)，通过这个脚本，我们能够让系统判断在怎么样的情形下，要利用哪一台Proxy来进行联机。</p>
<p>在“科学上网”方面呢，我们可以让系统确认，哪些网站通过代理访问，哪些直接通过本机网络访问，这样一来避免了直接整机挂VPN而导致国内不少网站访问不了的尴尬情况。</p>
<p><strong>PAC文件采用JavaScript编写，想要实现高级规则，最好有点JavaScript基础^_^</strong></p>
<h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><p>先新建一个*.pac文件，然后输(fu)入(zhi)以下代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'DIRECT'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FindProxyForURL是PAC文件的“主函数”，PAC文件一定要定义它，所有的请求都会进入这个方法，然后匹配规则。</p>
<p>其中 <em>return ‘DIRECT’;</em> 表示直接使用本机网络直接访问，这一段目前的含义是所有请求通过本机网络直接访问。</p>
<p>PAC一共支持三种访问方式</p>
<ul>
<li>DIRECT <em>直接联机而不透过 Proxy</em></li>
<li>PROXY host:port <em>使用指定的 Proxy 伺服机</em></li>
<li>SOCKS host:port <em>使用指定的 Socks 伺服机</em></li>
</ul>
<p>比如将代码改成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'PROXY 127.0.0.1:7070'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则表示所有的请求，以HTTP方式，通过本机的7070端口访问。</p>
<h3 id="通过域名匹配规则"><a href="#通过域名匹配规则" class="headerlink" title="通过域名匹配规则"></a>通过域名匹配规则</h3><p>我这里就介绍一个比较常用的规则，通过域名匹配，如果一个请求在一个域名下，我们就走代理访问。</p>
<p>直接上代码吧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> autoproxy_host = &#123;</div><div class="line">    <span class="string">"google.com"</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">"twitter.com"</span>: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> lastPos;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span> (autoproxy_host.hasOwnProperty(host)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">'PROXY 127.0.0.1:7070'</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        lastPos = host.indexOf(<span class="string">'.'</span>) + <span class="number">1</span>;</div><div class="line">        host = host.slice(lastPos);</div><div class="line">    &#125; <span class="keyword">while</span> (lastPos &gt;= <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'DIRECT'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实会Js的朋友应该很容易就能看懂了，不断分隔域名，然后去匹配autoproxy_host中设定好了的域名，如果匹配上了，我们就通过本机7070端口代理访问，否则就直接通过本机网络访问。比如这里，访问google.com和twitter.com的时候，就通过代理访问。</p>
<p>实际上用的时候，记得把127.0.0.1:7070换成你自己代理，如果是SSH的代理，就用SOCKS就好了。</p>
<h3 id="使用PAC文件"><a href="#使用PAC文件" class="headerlink" title="使用PAC文件"></a>使用PAC文件</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>Windows上面使用PAC文件很简单，新建一个你的PAC文件，放在一个固定的位置，比如</p>
<p>D:\学习资料\国外学习资料\中外文化交流\跨越\别看\说了别看\搞毛啊\setting.pac</p>
<p>然后，Internet设置 -&gt; 连接 -&gt; 局域网设置 </p>
<p><img src="/bimg/pac-win-1.jpg" alt=""></p>
<p>勾选“自动检测设置”以及“使用自动配置脚本”，在“地址”里面填写</p>
<p>file:\\\ 加 文件路径，如下</p>
<p><img src="/bimg/pac-win-2.jpg" alt=""></p>
<p>然后多确认几次就好了，打开浏览器或者IE（没错我就是来黑IE的）试试看吧！</p>
<h4 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX"></a>Mac OSX</h4><p>Mac上面比较麻烦，因为最新的OSX是不支持本地文件设置的，你需要填写一个网络地址。比较好的办法是你现在本地建立一个服务器，然后把你的pac文件丢进去，然后通过http能访问就好了。</p>
<p>在Mac上建立本地服务器的方法很多，比如自带的apache。直接在命令行输入</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apachectl start</div></pre></td></tr></table></figure>
<p>一般默认的目录都是 /Library/WebServer/Documents，你也可以修改/etc/apache2/httpd.conf里面的DocumentRoot配置项，修改服务器的默认路径。</p>
<p>把pac文件放进根目录，然后就可以直接通过 <a href="http://localhost/file.pac" target="_blank" rel="external">http://localhost/file.pac</a> 来访问了。</p>
<p>接下来是配置网络，系统偏好 -&gt; 网络 -&gt; 高级 -&gt; 代理</p>
<p>勾选“Automatic Proxy Configuration”，在右侧填写pac文件路径就好了。</p>
<p><img src="/bimg/pac-mac-1.png" alt=""></p>
<p>至此，大伙儿就开开心心地来“科学上网”吧！！！\(^o^)/！！</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>然后，没错，我就是被颜大大拜托过来耍宝的！=￣ω￣=</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;万里长城是我们中华民族的瑰宝，是我们民族的骄傲，是世界八大奇迹之一，是我们中华的代表，它让我们避免了外族的侵略！&lt;/p&gt;
&lt;p&gt;嗯，不过对我们现代中华儿女，我们要做的就是！翻越它去征服世界上所有的蛮夷之地！&lt;/p&gt;
    
    </summary>
    
      <category term="tool" scheme="https://exp-team.github.io/categories/tool/"/>
    
    
      <category term="tool" scheme="https://exp-team.github.io/tags/tool/"/>
    
      <category term="pac" scheme="https://exp-team.github.io/tags/pac/"/>
    
  </entry>
  
  <entry>
    <title>深入新版BS4源码 探索flex和工程化sass奥秘</title>
    <link href="https://exp-team.github.io/blog/2017/01/12/program/BS4/"/>
    <id>https://exp-team.github.io/blog/2017/01/12/program/BS4/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-02-19T12:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>你可能已经听说了一个“大新闻”：Bootstrap4 合并了代号为#21389的PR，宣布<a href="https://github.com/twbs/bootstrap/pull/21389" target="_blank" rel="external">放弃支持IE9，并默认使用flexbox弹性盒模型</a>。<br>这标志着前端开发全面步入“现代浏览器”的时代进一步来临；样式处理也再一次面向未来，拥抱更加灵活的弹性盒模型－Flex布局。</p>
<p>这篇文章会带你深入Bootstrap最新版源码，窥探其架构组织奥秘，并解析最具亮点的栅格化系统。<br>你也会了解到sass的高阶用法和flex最新语法奥秘。</p>
<h2 id="BS4的新特性"><a href="#BS4的新特性" class="headerlink" title="BS4的新特性"></a>BS4的新特性</h2><p>在开启我们的探索之前，有必要先梳理一下BS4添加的新特性：<br>1）从Less迁移到Sass：<br>现在，Bootstrap已加入Sass的大家庭中。得益于Libsass（Sass 解析器），Bootstrap的编译速度比以前更快；<br>2）改进网格系统：<br>新增一个网格层适配移动设备，并整顿语义混合。<br>3）默认弹性盒模型（flexbox）：<br>这是项划时代的变动，利用flexbox的优势快速布局。<br>4）废弃了wells、thumbnails和panels，使用cards代替。<br>5）新的自定义选项：<br>不再像上个版本一样，将渐变、淡入淡出、阴影等效果分放在单独的样式表中。而是将所有选项都移到一个Sass变量中。<br>想要给全局或考虑不到的角落定义一个默认效果？很简单，只要更新变量值，然后重新编译就可以了。<br>6）使用rem和em单位。<br>7）重构所有JavaScript插件：<br>Bootstrap 4用ES6重写了所有插件。现在提供UMD支持、泛型拆解方法、选项类型检查等特性。<br>8）改进工具提示和popovers自动定位：<br>这部分要感谢Tether（A positioning engine to make overlays, tooltips and dropdowns better）工具的帮助，<br>如果你还不知道Tether是什么，可以去他家<a href="https://github.com/HubSpot/tether" target="_blank" rel="external">Github地址</a>。</p>
<h2 id="BS4栅格系统揭秘"><a href="#BS4栅格系统揭秘" class="headerlink" title="BS4栅格系统揭秘"></a>BS4栅格系统揭秘</h2><p>了解了以上新特性，我们主要研究BS从诞生以来最大的“卖点”－栅格系统。</p>
<h2 id="一个栅格实例"><a href="#一个栅格实例" class="headerlink" title="一个栅格实例"></a>一个栅格实例</h2><p>我们选取代表性的BS4官网范例，可以<a href="http://v4.bootcss.com/examples/dashboard/#" target="_blank" rel="external">在线参考</a>, 或者参看以下截图，<br>在大屏幕下，我们看到：</p>
<p>当屏幕宽度小于576px时候，我们有：</p>
<p>对应代码：</p>
<pre><code>&lt;div class=&quot;col-6 col-sm-3&quot;&gt;
    ...
&lt;/div&gt;
&lt;div class=&quot;col-6 col-sm-3&quot;&gt;
    ...
&lt;/div&gt;
&lt;div class=&quot;col-6 col-sm-3&quot;&gt;
    ...
&lt;/div&gt;
&lt;div class=&quot;col-6 col-sm-3&quot;&gt;
    ...
&lt;/div&gt;
</code></pre><p>.col-6 class样式在源码里面可以简单归纳（不完全）为：</p>
<pre><code>.col-6 {
    -webkit-box-flex: 0;
    -webkit-flex: 0 0 50%;
    -ms-flex: 0 0 50%;
    flex: 0 0 50%;
    max-width: 50%;
}
</code></pre><p>.col-sm-3 class在源码里面可以归纳为：</p>
<pre><code>.col-sm-3{
    -webkit-box-flex: 0;
    -webkit-flex: 0 0 25%;
        -ms-flex: 0 0 25%;
            flex: 0 0 25%;
    max-width: 25%;
}
</code></pre><h3 id="两种类的共存和交替作用"><a href="#两种类的共存和交替作用" class="headerlink" title="两种类的共存和交替作用"></a>两种类的共存和交替作用</h3><p>我们看到，代码里设置了这两个class进行样式声明，很明显他们的样式属性是有冲突的，那么他们是如何做到“和平共处”交替发挥作用的呢？</p>
<p>1）在屏幕宽度大于576px时候，我们发现.col-sm-3并没有起作用，这时候起作用的是.col-6。<br>我们在源码里发现.col-sm-<em>的样式声明全部在@media (min-width: 576px) {…}的媒体查询中，<br>这就保证了在576px宽度以上的屏幕，只有在媒体查询之外的.col-</em>样式声明发挥了作用。</p>
<p>2）在屏幕宽度小于576px时候，命中媒体查询，命中.col-sm-3的样式声明。他的优先级一定大于.col-6（媒体查询优先级高），这时候就保证了移动端的样式“占上风”。</p>
<h3 id="flex讲解"><a href="#flex讲解" class="headerlink" title="flex讲解"></a>flex讲解</h3><p>我们从样式代码里看到类似flex: 0 0 25%的声明，为了理解它，我们从flex属性入手：<br>flex属性是flex-grow, flex-shrink 和 flex-basis的简写（类似backgroud是很多背景属性的简写一样），<br>它的默认值为0 1 auto。后两个属性可选。语法格式如下：</p>
<pre><code>.item {
    flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]
}
</code></pre><p>1）flex-grow：属性定义项目的放大比例，默认为0。我们看到BS代码里这个值一直为0，即如果存在剩余空间，也不放大。</p>
<p>2）flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p>3）flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。<br>浏览器根据这个属性，计算主轴是否有多余空间。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。<br>当然BS4这里设置为比例值，这也是响应式自然而然实现的基础。</p>
<h2 id="SASS在BS4工程化中的伟大作用"><a href="#SASS在BS4工程化中的伟大作用" class="headerlink" title="SASS在BS4工程化中的伟大作用"></a>SASS在BS4工程化中的伟大作用</h2><p>看到此，不难明白BS4栅格的实现，但是这并不是此文的最终目的。我们可以深入更多，比如，BS4的栅格系统里，一行一共是12栏。他的媒体查询断点又包括：xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px。<br>参考其源码dist/css目录下样式代码，我们会想组织生成如此大量的CSS样式，不用预处理器简直是反人类的。而BS4却是把sass用到了极致。</p>
<h3 id="col-sm-是如何生成的"><a href="#col-sm-是如何生成的" class="headerlink" title=".col-sm-*是如何生成的"></a>.col-sm-*是如何生成的</h3><p>我们深入其scss目录下，scss/mixins/_grid.scss文件：</p>
<pre><code>@if $enable-grid-classes {
    @include make-grid-columns();
}
</code></pre><p>在enable-grid-classes变量为true的情况下（默认为true），调用make-grid-columns()</p>
<p>make-grid-columns()这个mixin定义在scss/mixins/_grid-reamework.scss文件中（找的我好心累。。。）：</p>
<pre><code>@mixin make-grid-columns($columns: $grid-columns, $gutters: $grid-gutter-widths, $breakpoints: $grid-breakpoints) {
    ...
}
</code></pre><p>这个mixin接受三个参数：<br>1）$columns表示栅格数目默认为12<br>2）$gutters默认为30<br>3）$breakpoints表示断点设置，这是一个全局变量，为map类型。<br>这些你可以在scss/mixins/_breakpoints.scss文件中和scss/_variables.scss文件中找到。</p>
<p>认识了这些参数，我们看.col-sm-<em>具体实现，下面代码我已经进行过大范围精简，只保留col-sm-</em>相关部分，并且加了注释：</p>
<pre><code>@each $breakpoint in map-keys($breakpoints) {
    // Returns a blank string if smallest breakpoint, otherwise returns the name with a dash infront.
    $infix: breakpoint-infix($breakpoint, $breakpoints);
    // Media of at least the minimum breakpoint width. No query for the smallest breakpoint.
    // Makes the @content apply to the given breakpoint and wider.
    @include media-breakpoint-up($breakpoint, $breakpoints) {
        @for $i from 1 through $columns {
            .col#{$infix}-#{$i} {
                @include make-col($i, $columns);
            }
        }
    }
}
</code></pre><p>我们一步一步来分析：<br>1）@each $breakpoint in map-keys($breakpoints)，对每一个断点进行遍历；<br>2）breakpoint-infix是一个函数，它定义在css/mixins/_breakpoints.scss文件当中， 返回一个带破折号的断点标识字符串，比如这里我们关系的就是“-sm”；<br>3）media-breakpoint-up是一个mixin：</p>
<pre><code>@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {
    $min: breakpoint-min($name, $breakpoints);
    @if $min {
        @media (min-width: $min) {
        @content;
    }
    } @else {
        @content;
    }
}
</code></pre><p>4）breakpoint-min又是一个函数，它返回了断点的具体数值。这里是用来拼媒体查询条件的。<br>5）最后最关键样式的生成又使用了另外一个定义在css/mixins/_grid.scss文件当中的mixin:</p>
<pre><code>@mixin make-col($size, $columns: $grid-columns) {
    flex: 0 0 percentage($size / $columns);
    max-width: percentage($size / $columns);
}
</code></pre><p>到此为止，我们深入了Bootstrap V4的scss/目录下的源码，研究涉及了：<br>css/mixins/_grid-framework.scss文件;<br>css/mixins/_breakpoints.scss文件;<br>css/mixins/_grid.scss文件;<br>css/_variables.scss文件;<br>css/bootstrap-gris.scss文件;<br>……</p>
<p>如果你理解了这些，那么再去读bootstrap新版源码就不会存在任何难度。相信你也能够在全局上，以“上帝视角”了解sass所起的作用，大型样式框架的架构组织。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读源码的栅格系统部分，我们应该认识到sass对于这样大型样式框架系统的重要意义：<br>1）css模块化在管理组织上的灵活性；<br>2）复用的意义，我们使用了大量的mixin,function,全局变量；<br>3）像JS一样神奇的语法，包括条件、遍历等等等等。<br>我们也应该对flex这一神器有了更加深刻的认识。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可能已经听说了一个“大新闻”：Bootstrap4 合并了代号为#21389的PR，宣布&lt;a href=&quot;https://github.com/twbs/bootstrap/pull/21389&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;放弃支持IE
    
    </summary>
    
      <category term="program" scheme="https://exp-team.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://exp-team.github.io/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>揭秘babel的魔法之class继承的处理</title>
    <link href="https://exp-team.github.io/blog/2017/01/12/js/babel-class2/"/>
    <id>https://exp-team.github.io/blog/2017/01/12/js/babel-class2/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-01-16T07:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你已经看过第一篇<a href="http://www.jianshu.com/p/d36fb31f9cff" target="_blank" rel="external">揭秘babel的魔法之class魔法处理</a>，这篇将会是一个延伸；<br>如果你还没看过，并且也不想<a href="http://www.jianshu.com/p/d36fb31f9cff" target="_blank" rel="external">现在就去读一下</a>，单独看这篇也没有关系，并不存在理解上的障碍。</p>
<p>上一篇针对Babel对ES6里面基础“class”的编译进行了分析。这一篇将会对class的继承，包括extends和super进行讲解。</p>
<p>什么？你还不了解ES6如何实现继承？没关系，下文内容也有详细示例。</p>
<p>再啰嗦一句，这一系列的文章并不是科普ECMAScript新规范。她的意义在于分析Babel对ES6的编译，从而希望读者对JS语言基础，程序设计理念等有更深刻的认识。</p>
<h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><p>在这篇文章中，我会讲解Babel如何处理ES6 Class里面的继承功能，同样，这其实是一系列语法糖的实现。<br>我们先来温习一下实现方式：</p>
<h3 id="ES6-实现继承"><a href="#ES6-实现继承" class="headerlink" title="ES6 实现继承"></a>ES6 实现继承</h3><p>首先，我们定义一个父类：</p>
<pre><code>class Person {
    constructor(){
        this.type = &apos;person&apos;
    }
}
</code></pre><p>这个类包含了一个实例属性。</p>
<p>然后，实现一个Student类，这个“学生”类继承“人”类：</p>
<pre><code>class Student extends Person {
    constructor(){
        super()
    }
}
</code></pre><p>从简出发，我们定义的Person类只包含了type为person的这一个属性，不含有方法。所以我们extends+super()之后，Student类<br>也继承了同样的属性。<br>如下：</p>
<pre><code>var student1 = new Student();
student1.type // &quot;person&quot;
</code></pre><p>我们进一步可以验证原型链上的关系：</p>
<pre><code>student1 instanceof Student // true
student1 instanceof Person // true
student1.hasOwnProperty(&apos;type&apos;) // true
</code></pre><p>一切看上去cool极了，我们实现了ES6里面的继承。并且用instanceof验证了ES6中一系列的实质就是“魔法糖”的本质。<br>那么，经过Babel编译，我们的代码是什么样呢？</p>
<h3 id="Babel-transformation"><a href="#Babel-transformation" class="headerlink" title="Babel transformation"></a>Babel transformation</h3><p>我们一步一步来看，</p>
<p>Step1: Person定义</p>
<pre><code>class Person {
    constructor(){
        this.type = &apos;person&apos;
    }
}
</code></pre><p>被编译为：</p>
<pre><code>var Person = function Person() {
    _classCallCheck(this, Person);
    this.type = &apos;person&apos;;
};
</code></pre><p>如果你看过这一篇的<a href="http://www.jianshu.com/p/d36fb31f9cff" target="_blank" rel="external">前传</a>，<br>你应该就熟悉这一系列的变换，也可能会记得_classCallCheck函数到底是什么鬼。这里因为篇幅和去冗余的原因，就不再展开。</p>
<p>Step2：Student探秘<br>我们这次尝试观察Student子类：</p>
<pre><code>class Student extends Person {
    constructor(){
        super()
    }
}
</code></pre><p>编译结果：</p>
<pre><code>// 实现定义Student构造函数，它是一个自执行函数，接受父类构造函数为参数
var Student = (function(_Person) {
    // 实现对父类原型链属性的继承
    _inherits(Student, _Person);

    // 将会返回这个函数作为完整的Student构造函数
    function Student() {
        // 使用检测
        _classCallCheck(this, Student);  
        // _get的返回值可以先理解为父类构造函数       
        _get(Object.getPrototypeOf(Student.prototype), &apos;constructor&apos;, this).call(this);
    }

    return Student;
})(Person);

// _x为Student.prototype.__proto__
// _x2为&apos;constructor&apos;
// _x3为this
var _get = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
        var object = _x,
            property = _x2,
            receiver = _x3;
        _again = false;
        // Student.prototype.__proto__为null的处理
        if (object === null) object = Function.prototype;
        // 以下是为了完整复制父类原型链上的属性，包括属性特性的描述符
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);
            if (parent === null) {
                return undefined;
            } else {
                _x = parent;
                _x2 = property;
                _x3 = receiver;
                _again = true;
                desc = parent = undefined;
                continue _function;
            }
        } else if (&apos;value&apos; in desc) {
            return desc.value;
        } else {
            var getter = desc.get;
            if (getter === undefined) {
                return undefined;
            }
            return getter.call(receiver);
        }
    }
};

function _inherits(subClass, superClass) {
    // superClass需要为函数类型，否则会报错
    if (typeof superClass !== &apos;function&apos; &amp;&amp; superClass !== null) {
        throw new TypeError(&apos;Super expression must either be null or a function, not &apos; + typeof superClass);
    }
    // Object.create第二个参数是为了修复子类的constructor
    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    // Object.setPrototypeOf是否存在做了一个判断，否则使用__proto__
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
</code></pre><p>虽然我加上了注释，但是这一坨代码仍然看上去恶心极了！没关系，下面我们进行拆解，你很快就能明白。</p>
<p>Step3：抽丝剥茧<br>我们首先看Student的编译结果：</p>
<pre><code>var Student = (function(_Person) {
    _inherits(Student, _Person);

    function Student() {
        _classCallCheck(this, Student);            
        _get(Object.getPrototypeOf(Student.prototype), &apos;constructor&apos;, this).call(this);
    }

    return Student;
})(Person);
</code></pre><p>这是一个自执行函数，它接受一个参数Person（就是他要继承的父类），返回一个构造函数Student。</p>
<p>上面_inherits方法的本质其实就是让Student子类继承Person父类原型链上的方法。它实现原理可以归结为一句话：</p>
<pre><code>Student.prototype = Object.create(Person.prototype);
Object.setPrototypeOf(Student, Person)
</code></pre><p>注意，Object.create接收第二个参数，这就实现了对Student的constructor修复。<br>如果你不了解Object.create，那么<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">请参考这里。</a></p>
<p>以上通过_inherits实现了对父类原型链上属性的继承，那么对于父类的实例属性（就是constructor定义的属性）的继承，也可以归结为一句话：</p>
<pre><code>Person.call(this);
</code></pre><p>如果你还不理解使用call或者apply或者bind来改变JS中this的指向，那么请参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external">这篇文章。</a></p>
<p>这样，我们便透析了Babel编译这一切的秘密。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你看完这一系列的文章可能会有体会：我想灌输的肯定不是ES6新特性的使用，关于这些东西有太多的文章、博客、书籍去讨论。</p>
<p>我是在讲Babel对这些新特性的编译产出，那为什么我会在乎这些呢？<br>其实通过分析，我们悄然回顾了JS中很多重点以及难点，还包括程序设计上的一些小思想。<br>最近面试了很多前端“新同学”：有的人痴迷于框架，可以使用React或者Vue比照tutorial做出页面炫酷的交互，甚至自觉SPA也不在话下；<br>有的人ES6、ES7了解很多，generator，async都能说出一二，仿佛Promise处理异步已经成为了“时代弃儿”。<br>可是同样是这些人，对原型原型链、this、作用域、闭包都没有深刻地理解和掌握。<br>同样是这些页面，即便用callback处理异步回调，嵌套最多也不到两层。</p>
<p>也许，同样一批人也会问：“我能用前端框架、ES6撸出好多页面，可是为什么感觉进步很慢处于瓶颈中、面试也总被挂呢？”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你已经看过第一篇&lt;a href=&quot;http://www.jianshu.com/p/d36fb31f9cff&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;揭秘babel的魔法之class魔法处理&lt;/a&gt;，这篇将会是一个延伸；&lt;br&gt;如果你还没看过，并
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>揭秘babel的魔法之class魔法处理</title>
    <link href="https://exp-team.github.io/blog/2017/01/12/program/babel-class/"/>
    <id>https://exp-team.github.io/blog/2017/01/12/program/babel-class/</id>
    <published>2017-01-11T16:00:00.000Z</published>
    <updated>2017-01-15T12:55:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年，很多人已经开始接触ES6环境，并且早已经用在了生产当中。我们知道ES6在大部分浏览器还是跑不通的，因此我们使用了伟大的Babel来进行编译。很多人可能没有关心过，经过Babel编译之后，我们华丽的ES6代码究竟变成了什么样子？</p>
<p>这篇文章，针对Babel对ES6里面“类class”的编译进行分析，你可以在线<a href="https://babeljs.io/repl/" target="_blank" rel="external">测试编译结果</a>，毕竟纸上得来终觉浅，自己动手，才能真正体会其中的奥秘。</p>
<p>另外，如果你还不明白JS中原型链等OOP相关知识，建议出门左转找到经典的《JS高级程序设计》来补课；如果你对JS中，通过原型链来实现继承一直云里雾里，安利一下我的同事，前端著名网红<a href="http://yanhaijing.com/javascript/2014/11/09/object-inherit-of-js/" target="_blank" rel="external">颜海镜大大早在2014年的文章</a></p>
<a id="more"></a>
<h2 id="为什么使用选择Babel"><a href="#为什么使用选择Babel" class="headerlink" title="为什么使用选择Babel"></a>为什么使用选择Babel</h2><p>Babel：The compiler for writing next generation JavaScript；<br>我们知道，现在大部分浏览器或者类似NodeJS的javascript引擎还不能直接支持ES6语法。但这并不构成障碍，比如Babel的出现，使得我们在生产环境中书写ES6代码成为了现实，它工作原理是编译ES6的新特性为老版本的ES5，从而得到宿主环境的支持。</p>
<h2 id="Class例子"><a href="#Class例子" class="headerlink" title="Class例子"></a>Class例子</h2><p>在这篇文章中，我会讲解Babel如何处理ES6新特性：Class，这其实是一系列语法糖的实现。</p>
<h3 id="Old-school方式实现继承"><a href="#Old-school方式实现继承" class="headerlink" title="Old school方式实现继承"></a>Old school方式实现继承</h3><p>在探究ES6之前，我们先来回顾一下ES5环境下，我们如何实现类的继承：</p>
<pre><code>// Person是一个构造器
function Person(name) {
    this.type = &apos;Person&apos;;
    this.name = name;
}

// 我们可以通过prototype的方式来加一条实例方法
Person.prototype.hello = function() {
    console.log(&apos;hello &apos; + this.name);
}

// 对于私有属性(Static method)，我们当然不能放在原型链上了。我们可以直接放在构造函数上面
Person.fn = function() {
    console.log(&apos;static&apos;);
};
</code></pre><p>我们可以这么应用：</p>
<pre><code>var julien = new Person(&apos;julien&apos;);
var darul = new Person(&apos;darul&apos;);
julien.hello(); // &apos;hello julien&apos;
darul.hello(); // &apos;hello darul&apos;
Person.fn(); // &apos;static&apos;

// 这样会报错，因为fn是一个私有属性
julien.fn(); //Uncaught TypeError: julien.fn is not a function
</code></pre><h3 id="New-school方式-ES6-实现继承"><a href="#New-school方式-ES6-实现继承" class="headerlink" title="New school方式(ES6)实现继承"></a>New school方式(ES6)实现继承</h3><p>在ES6环境下，我们当然迫不及待地试一试Class：</p>
<pre><code>class Person {
    constructor(name) {
        this.name = name;
        this.type=&quot;person&quot;
    }
    hello() {
        console.log(&apos;hello &apos; + this.name);
    }
    static fn() {
        console.log(&apos;static&apos;);
    };
}
</code></pre><p>这样写起来当然很cool，但是经过Babel编译，我们的代码是什么样呢？</p>
<h3 id="Babel-transformation"><a href="#Babel-transformation" class="headerlink" title="Babel transformation"></a>Babel transformation</h3><p>我们一步一步来看，</p>
<p>Step1: 定义<br>我们从最简单开始，试试不加任何方法和属性的情况下，</p>
<pre><code>Class Person{}
</code></pre><p>被编译为：</p>
<pre><code>function _classCallCheck(instance, Constructor) {
    // 检查是否成功创建了一个对象
    if (!(instance instanceof Constructor)) {  
        throw new TypeError(&quot;Cannot call a class as a function&quot;); 
    } 
}

var Person = function Person() {
    _classCallCheck(this, Person);
};
</code></pre><p>你可能会一头雾水,_classCallCheck是什么？其实很简单，它是为了保证调用的安全性。<br>比如我们这么调用：</p>
<pre><code>// ok
var p = new Person();
</code></pre><p>是没有问题的，但是直接调用：</p>
<pre><code>// Uncaught TypeError: Cannot call a class as a function
Person();
</code></pre><p>就会报错，这就是_classCallCheck所起的作用。具体原理自己看代码就好了，很好理解。</p>
<p>我们发现，Class关键字会被编译成构造函数，于是我们便可以通过new来实现实例的生成。</p>
<p>Step2：Constructor探秘<br>我们这次尝试加入constructor,再来看看编译结果：</p>
<pre><code>class Person() {
    constructor(name) {  
        this.name = name;
        this.type = &apos;person&apos;
    }
}
</code></pre><p>编译结果：</p>
<pre><code>var Person = function Person(name) {
    _classCallCheck(this, Person);
    this.type = &apos;person&apos;;
    this.name = name;
};
</code></pre><p>看上去棒极了，我们继续探索。</p>
<p>Step3：增加方法<br>我们尝试给Person类添加一个方法：hello：</p>
<pre><code>class Person {
    constructor(name) {
        this.name = name;
        this.type = &apos;person&apos;
    }

    hello() {
        console.log(&apos;hello &apos; + this.name);
    }
}
</code></pre><p>编译结果(已做适当省略)：</p>
<pre><code>// 如上，已经解释过
function _classCallCheck.... 

// MAIN FUNCTION
var _createClass = (function () { 
    function defineProperties(target, props) { 
        for (var i = 0; i &lt; props.length; i++) { 
            var descriptor = props[i]; 
            descriptor.enumerable = descriptor.enumerable || false; 
            descriptor.configurable = true; 
            if (&apos;value&apos; in descriptor) 
            descriptor.writable = true; 
            Object.defineProperty(target, descriptor.key, descriptor); 
        } 
    } 
    return function (Constructor, protoProps, staticProps) { 
        if (protoProps) 
            defineProperties(Constructor.prototype, protoProps); 
        if (staticProps) 
            defineProperties(Constructor, staticProps); 
        return Constructor; 
    }; 
})();

var Person = (function () {
    function Person(name) {
        _classCallCheck(this, Person);

        this.name = name;
    }

    _createClass(Person, [{
        key: &apos;hello&apos;,
        value: function hello() {
            console.log(&apos;hello &apos; + this.name);
        }
    }]);

    return Person;
})();
</code></pre><p>Oh…no,看上去有很多需要消化!不要急，我尝试先把他精简一下，并加上注释，你就会明白核心思路：</p>
<pre><code>var _createClass = (function () {   
    function defineProperties(target, props) { 
        // 对于每一个定义的属性props，都要完全拷贝它的descriptor,并扩展到target上
    }  
    return defineProperties(Constructor.prototype, protoProps);    
})();

var Person = (function () {
    function Person(name) { // 同之前... }

    _createClass(Person, [{
        key: &apos;hello&apos;,
        value: function hello() {
            console.log(&apos;hello &apos; + this.name);
        }
    }]);

    return Person;
})();
</code></pre><p>如果你不明白defineProperty方法, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">请参考这里</a></p>
<p>现在，我们知道我们添加的方法：</p>
<pre><code>hello() {
    console.log(&apos;hello &apos; + this.name);
}
</code></pre><p>被编译为：</p>
<pre><code>_createClass(
    Person, [{
    key: &apos;hello&apos;,
    value: function hello() {
        console.log(&apos;hello &apos; + this.name);
    }
}]);
</code></pre><p>而_createClass接受2个－3个参数，分别表示：</p>
<pre><code>参数1 =&gt; 我们要扩展属性的目标对象，这里其实就是我们的Person
参数2 =&gt; 需要在目标对象原型链上添加的属性，这是一个数组
参数3 =&gt; 需要在目标对象上添加的属性，这是一个数组
</code></pre><p>这样，Babel的魔法就一步一步被揭穿了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望这篇文章能够让你了解到Babel是如何初步把我们ES6 Class语法编译成ES5的。下一篇文章我会继续介绍Babel如何处理子类的Super(), 并会通过一段函数桥梁，使得ES5环境下也能够继承ES6定义的Class。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年，很多人已经开始接触ES6环境，并且早已经用在了生产当中。我们知道ES6在大部分浏览器还是跑不通的，因此我们使用了伟大的Babel来进行编译。很多人可能没有关心过，经过Babel编译之后，我们华丽的ES6代码究竟变成了什么样子？&lt;/p&gt;
&lt;p&gt;这篇文章，针对Babel对ES6里面“类class”的编译进行分析，你可以在线&lt;a href=&quot;https://babeljs.io/repl/&quot;&gt;测试编译结果&lt;/a&gt;，毕竟纸上得来终觉浅，自己动手，才能真正体会其中的奥秘。&lt;/p&gt;
&lt;p&gt;另外，如果你还不明白JS中原型链等OOP相关知识，建议出门左转找到经典的《JS高级程序设计》来补课；如果你对JS中，通过原型链来实现继承一直云里雾里，安利一下我的同事，前端著名网红&lt;a href=&quot;http://yanhaijing.com/javascript/2014/11/09/object-inherit-of-js/&quot;&gt;颜海镜大大早在2014年的文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="program" scheme="https://exp-team.github.io/categories/program/"/>
    
    
      <category term="program" scheme="https://exp-team.github.io/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10011期</title>
    <link href="https://exp-team.github.io/blog/2017/01/07/weekly/weekly-10011/"/>
    <id>https://exp-team.github.io/blog/2017/01/07/weekly/weekly-10011/</id>
    <published>2017-01-06T16:00:00.000Z</published>
    <updated>2017-01-13T10:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.1-1.7，2017年的第一期，美好的事情即将发生，翘首期待。</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="2016年javascript回顾"><a href="#2016年javascript回顾" class="headerlink" title="2016年javascript回顾"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651224793&amp;idx=1&amp;sn=68ae9a4b327ac26d141484392afa52ac&amp;chksm=bd49a35d8a3e2a4bac8fac53163bad6526ee2824f77e5491cbbf6010eb98cf545956bc5367b3&amp;mpshare=1&amp;scene=1&amp;srcid=0106gQOA9sJ99tDSaTQzGVOA#rd" target="_blank" rel="external">2016年javascript回顾</a></h3><p>又是一篇非常好的导读文章，本文仅仅是16年js的导读文章，17年值得期待。</p>
<h3 id="JavaScript-全栈工程师培训教程"><a href="#JavaScript-全栈工程师培训教程" class="headerlink" title="JavaScript 全栈工程师培训教程"></a><a href="http://www.ruanyifeng.com/blog/2016/11/javascript.html" target="_blank" rel="external">JavaScript 全栈工程师培训教程</a></h3><p>阮一峰老师的又一大作，本文重在理解各种技术想要解决的问题，掌握基本用法，为进一步自学打下基础。</p>
<h3 id="JavaScript模块化编程简史（2009-2016）"><a href="#JavaScript模块化编程简史（2009-2016）" class="headerlink" title="JavaScript模块化编程简史（2009-2016）"></a><a href="http://mp.weixin.qq.com/s/Z8bG125LvKJFIpF8w3efRg" target="_blank" rel="external">JavaScript模块化编程简史（2009-2016）</a></h3><p>@余果 整理的js模块发展史，如果你搞不懂AMD,CMD,UMD,commonjs那就来看看这篇文章吧。</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="如何写好-JavaScript-的函数？没那么简单！"><a href="#如何写好-JavaScript-的函数？没那么简单！" class="headerlink" title="如何写好 JavaScript 的函数？没那么简单！"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964169&amp;idx=1&amp;sn=bc46bd908a439dad80ee19b796eb8fe7&amp;chksm=843aecafb34d65b9fdb0d6c379faf0cf80872fe4dea097b0b7de898f378f22da6aae70dd49ab&amp;mpshare=1&amp;scene=1&amp;srcid=0105fgcdjqeGJs4cCmQhP0r8#rd" target="_blank" rel="external">如何写好 JavaScript 的函数？没那么简单！</a></h3><p>没有最好的选择，只有最适合的，来看看这篇文章对参数的诠释吧，很小的一个点，却饱含了很多哲学。</p>
<h3 id="在-2017-年如何成为一名更好的-Node-js-开发者"><a href="#在-2017-年如何成为一名更好的-Node-js-开发者" class="headerlink" title="在 2017 年如何成为一名更好的 Node.js 开发者"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964152&amp;idx=1&amp;sn=c16caec1507ee0d6f97e14169c6fe697&amp;chksm=843aecdeb34d65c8d8fb0b1d1691125501972e790ce7a191037495f003ee9eed2756f20634c7&amp;mpshare=1&amp;scene=1&amp;srcid=0104Cyk96Ol4lpv3AiHFq3Md#rd" target="_blank" rel="external">在 2017 年如何成为一名更好的 Node.js 开发者</a></h3><h3 id="月薪三万与月薪三千的区别-——-浅谈-API-设计"><a href="#月薪三万与月薪三千的区别-——-浅谈-API-设计" class="headerlink" title="月薪三万与月薪三千的区别 —— 浅谈 API 设计"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964146&amp;idx=1&amp;sn=6ca5de478d3c9c4a700a9ef281ee505d&amp;chksm=843aecd4b34d65c276da8566f2cfa57c43123a287013f59c07f61de0bd2c99556f2b1828aae6&amp;mpshare=1&amp;scene=1&amp;srcid=01035xFI3xqOddQHKYEUIt6K#rd" target="_blank" rel="external">月薪三万与月薪三千的区别 —— 浅谈 API 设计</a></h3><p>本文看起来就是微博上的红绿灯大战哈，来看看一段代码是怎么进化和演进的。</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="Browserscope"><a href="#Browserscope" class="headerlink" title="Browserscope"></a><a href="http://www.browserscope.org/" target="_blank" rel="external">Browserscope</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.1-1.7，2017年的第一期，美好的事情即将发生，翘首期待。&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;2016年javascript回顾&quot;&gt;&lt;a href=&quot;#2016年javascript回顾&quot; class=&quot;headerlink&quot; title=&quot;2016年javascript回顾&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651224793&amp;amp;idx=1&amp;amp;sn=68ae9a4b327ac26d141484392afa52ac&amp;amp;chksm=bd49a35d8a3e2a4bac8fac53163bad6526ee2824f77e5491cbbf6010eb98cf545956bc5367b3&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0106gQOA9sJ99tDSaTQzGVOA#rd&quot;&gt;2016年javascript回顾&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;又是一篇非常好的导读文章，本文仅仅是16年js的导读文章，17年值得期待。&lt;/p&gt;
&lt;h3 id=&quot;JavaScript-全栈工程师培训教程&quot;&gt;&lt;a href=&quot;#JavaScript-全栈工程师培训教程&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 全栈工程师培训教程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/11/javascript.html&quot;&gt;JavaScript 全栈工程师培训教程&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;阮一峰老师的又一大作，本文重在理解各种技术想要解决的问题，掌握基本用法，为进一步自学打下基础。&lt;/p&gt;
&lt;h3 id=&quot;JavaScript模块化编程简史（2009-2016）&quot;&gt;&lt;a href=&quot;#JavaScript模块化编程简史（2009-2016）&quot; class=&quot;headerlink&quot; title=&quot;JavaScript模块化编程简史（2009-2016）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/Z8bG125LvKJFIpF8w3efRg&quot;&gt;JavaScript模块化编程简史（2009-2016）&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;@余果 整理的js模块发展史，如果你搞不懂AMD,CMD,UMD,commonjs那就来看看这篇文章吧。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第10010期</title>
    <link href="https://exp-team.github.io/blog/2016/12/31/weekly/weekly-10010/"/>
    <id>https://exp-team.github.io/blog/2016/12/31/weekly/weekly-10010/</id>
    <published>2016-12-30T16:00:00.000Z</published>
    <updated>2017-01-13T08:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>12.26-12.31，2016年最后一期了，2016你有什么后悔的事吗？2017你有什么想去做的事吗？欢迎在评论区留言。</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="2016，你有什么后悔的事吗？"><a href="#2016，你有什么后悔的事吗？" class="headerlink" title="2016，你有什么后悔的事吗？"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712946&amp;idx=1&amp;sn=b34c2783ebda8a16722d18d5cc542adc&amp;chksm=bec0652189b7ec377b7da8b7e5baffc1f9c535f6ed4178cf88b6eb5b1cde21a3212c73c7668a&amp;mpshare=1&amp;scene=1&amp;srcid=1228MrSq7al4EQSvvud9dZad#rd" target="_blank" rel="external">2016，你有什么后悔的事吗？</a></h3><p>欢迎大家在评论区留言讨论。</p>
<h3 id="2016前端开发技术巡礼"><a href="#2016前端开发技术巡礼" class="headerlink" title="2016前端开发技术巡礼"></a><a href="http://www.infoq.com/cn/articles/2016-review-frontend" target="_blank" rel="external">2016前端开发技术巡礼</a></h3><p>本文才算是真正的16年前端总结，蜻蜓点水的提到了各种前端新技术，看得人热血沸腾，感叹技术发展太快了。</p>
<h3 id="张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）"><a href="#张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）" class="headerlink" title="张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTE4Njc4NQ==&amp;mid=2657611912&amp;idx=1&amp;sn=f91c228764f9a3b4ed696276fae1ee1b&amp;chksm=bd6f01868a188890c72c32e3082f2bc36d7f79efab345a9a58595a4a19c9fa39f522e9981b2d&amp;mpshare=1&amp;scene=1&amp;srcid=1228p1Ap3ZKbPl1Lwsajn0Cy#rd" target="_blank" rel="external">张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）</a></h3><p>小程序在微信没有入口，没有流量，小程序的入口在无处无在的二维码，这终将是一个伟大的平台。</p>
<a id="more"></a>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="为什么总有人黑-JavaScript？"><a href="#为什么总有人黑-JavaScript？" class="headerlink" title="为什么总有人黑 JavaScript？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651551609&amp;idx=1&amp;sn=7396635dddfb6ebe6949aa2ee8b38132&amp;chksm=8025a0b8b75229aef34f72ec0c5fed8ccc46a0553e4002b395485e8db89213e84aa52c6d0df3&amp;mpshare=1&amp;scene=1&amp;srcid=1230e73LuUspDg41MwU0OaKY#rd" target="_blank" rel="external">为什么总有人黑 JavaScript？</a></h3><p>因为火呗，用的人多才会有人黑，不过每一门语言都不是完美的，js作为领域语言，肯定是有一些槽点的。</p>
<h3 id="ES6-新特性汇总（一图全览）"><a href="#ES6-新特性汇总（一图全览）" class="headerlink" title="ES6 新特性汇总（一图全览）"></a><a href="https://zhuanlan.zhihu.com/p/24570791" target="_blank" rel="external">ES6 新特性汇总（一图全览）</a></h3><h3 id="为什么这样也能运行-concat-1-2-3"><a href="#为什么这样也能运行-concat-1-2-3" class="headerlink" title="为什么这样也能运行? [ ].concat[1,2,3]"></a><a href="http://mp.weixin.qq.com/s?__biz=MzI0NTAyNjE0NQ==&amp;mid=2675577402&amp;idx=1&amp;sn=ca14e15fc6255f133fcf48fd6cd5f64f&amp;chksm=f3da6e34c4ade722e5b81ca75ffcf899e7d82c16add6510cf164de5dc0f6c0916dbe8c5d5628&amp;mpshare=1&amp;scene=1&amp;srcid=1227FMaDJKLPEhwS0b4ZEywu#rd" target="_blank" rel="external">为什么这样也能运行? [ ].concat[1,2,3]</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="我的效率工具箱"><a href="#我的效率工具箱" class="headerlink" title="我的效率工具箱"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxODE1MDYwMQ==&amp;mid=2650898818&amp;idx=1&amp;sn=9ad15d6a89fd7ac39887d2abc86fefb6&amp;chksm=802f8424b7580d323d78b3853dbf9d7bc5ed90cd951c7cae28fae18b460b22e87c5f54e1fcb5&amp;mpshare=1&amp;scene=1&amp;srcid=1227ezYVN9AGExsE4uYYOnPr#rd" target="_blank" rel="external">我的效率工具箱</a></h3><p>工欲善其事必先利其器，也欢迎大家积极分享自己的工具。</p>
<h3 id="前端疲劳"><a href="#前端疲劳" class="headerlink" title="前端疲劳"></a><a href="http://www.jianshu.com/p/a2eff3d721cb" target="_blank" rel="external">前端疲劳</a></h3><p>看完上面的2016前端开发技术巡礼，你一定会感叹前端的繁荣，或者如果你是一个关注新技术的前端，一定会有疲劳的感觉，那不妨看看这篇文章，也许对你有帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;12.26-12.31，2016年最后一期了，2016你有什么后悔的事吗？2017你有什么想去做的事吗？欢迎在评论区留言。&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;2016，你有什么后悔的事吗？&quot;&gt;&lt;a href=&quot;#2016，你有什么后悔的事吗？&quot; class=&quot;headerlink&quot; title=&quot;2016，你有什么后悔的事吗？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650712946&amp;amp;idx=1&amp;amp;sn=b34c2783ebda8a16722d18d5cc542adc&amp;amp;chksm=bec0652189b7ec377b7da8b7e5baffc1f9c535f6ed4178cf88b6eb5b1cde21a3212c73c7668a&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1228MrSq7al4EQSvvud9dZad#rd&quot;&gt;2016，你有什么后悔的事吗？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;欢迎大家在评论区留言讨论。&lt;/p&gt;
&lt;h3 id=&quot;2016前端开发技术巡礼&quot;&gt;&lt;a href=&quot;#2016前端开发技术巡礼&quot; class=&quot;headerlink&quot; title=&quot;2016前端开发技术巡礼&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/2016-review-frontend&quot;&gt;2016前端开发技术巡礼&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;本文才算是真正的16年前端总结，蜻蜓点水的提到了各种前端新技术，看得人热血沸腾，感叹技术发展太快了。&lt;/p&gt;
&lt;h3 id=&quot;张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）&quot;&gt;&lt;a href=&quot;#张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）&quot; class=&quot;headerlink&quot; title=&quot;张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NTE4Njc4NQ==&amp;amp;mid=2657611912&amp;amp;idx=1&amp;amp;sn=f91c228764f9a3b4ed696276fae1ee1b&amp;amp;chksm=bd6f01868a188890c72c32e3082f2bc36d7f79efab345a9a58595a4a19c9fa39f522e9981b2d&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=1228p1Ap3ZKbPl1Lwsajn0Cy#rd&quot;&gt;张小龙首次全面阐述小程序，定档1月9日上线（内附演讲全文）&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;小程序在微信没有入口，没有流量，小程序的入口在无处无在的二维码，这终将是一个伟大的平台。&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
</feed>
