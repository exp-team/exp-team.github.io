<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>exp team</title>
  <subtitle>together, stronger</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://exp-team.github.io/"/>
  <updated>2017-04-10T04:52:33.000Z</updated>
  <id>https://exp-team.github.io/</id>
  
  <author>
    <name>exp developer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解析Twitter前端架构 学习复杂场景数据设计</title>
    <link href="https://exp-team.github.io/blog/2017/04/20/js/twitter/"/>
    <id>https://exp-team.github.io/blog/2017/04/20/js/twitter/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天刷Twitter，发现Nicolas（Engineering at @twitter. Technical Lead for Twitter Lite）发布了这么一条推文：</p>
<p>图片</p>
<p>大家可以忽略我未发的留言lol～</p>
<p>大体意思就是Twitter前端经过重构，已经完全迁移到React＋Redux技术栈了。<br>听到这个消息之后，我觉得去深挖一下Twitter的Redux store组织架构，将会非常有意思。<br>这对于在复杂场景下的前端数据学习，以及React、Redux数据流设计十分有意义。</p>
<p>本文将剖析Twitter前端数据结构层次，如果你对React技术栈不是很了解，也不妨碍阅读；同样，如果你对这套技术栈有兴趣的话，欢迎参看我的其他类似文章：</p>
<p>本文主体内容翻译自Ryan Johnson的文章：<a href="https://medium.com/statuscode/dissecting-twitters-redux-store-d7280b62c6b1" target="_blank" rel="external">Dissecting Twitter’s Redux Store</a>，笔者进行了一定程度的拓展。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>想要看Redux store的前提是你需要配有React Developer Tools (RDT)，在RDT tab中选中应用根节点。<br>确保选中之后，在console面板中输入：</p>
<pre><code>// $r is a shortcut that references the selected element in RDT
$r.store.getState();
</code></pre><p>接下来，我们就可以看到Redux数据树，就像图中所示：</p>
<p>图片</p>
<h2 id="设计分析"><a href="#设计分析" class="headerlink" title="设计分析"></a>设计分析</h2><p>我建议大家花些时间对每个不同的state进行展开，并加以学习。这篇文章中，我挑选entities/tweets和homeTimeline两个最主要也是最核心的state进行剖析。这两个states包含了一条tweet的所有关联数据。</p>
<p>tweet，就像下图中我所发的：</p>
<p>图片</p>
<p>一条tweet内容的数据信息全部存储在entities/tweets/entities中，entities/tweets/entities可以理解为一个normalized的data table；<br>在这个table中，每一条tweet都是一个键值对类型的js object：key为该条tweet的id，value为该条tweet的数据。</p>
<p>下图中，我将第一条tweet展开，方便大家一探究竟：</p>
<p>图片</p>
<p>了解了tweet存储结构，我们接下来看一下Twitter首页的timeline结构。<br>每个用户的首页timeline信息可以在homeTimelines/timeline找到。首页timeline展示的顺序，按照timeline这个数组的顺序。也就是说，timeline数组index为0的条目，就是你在首页timeline上看到的第一条tweet；</p>
<p>首页timeline上的每条tweet，都有一个唯一的id，这个id和上面介绍的，存储在entities/tweets/entities之中的tweet id相匹配。</p>
<p>看到这里，你也许会感叹：“This is pretty much normalizing state shape 101 from Dan Abramov！”<br>没错，这样的范式也是Redux所推崇的，完全的扁平化设计带来的开发体验是无与伦比的。</p>
<p>当然，你可能会问为什么Redux包括Twitter都在推崇扁平化的数据结构呢？<br>这个问题建议参考：<a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">Redux core concepts</a>，如果您英语阅读吃力，可以留言与我交流。</p>
<p>继续言归正传，首页timeline加载新tweets方式有两种：<br>1）上拉加载track tweets by top<br>2）下拉加载track tweets by bottom</p>
<p>第一种用于拉取更新的tweets，第二种用于拉取更旧的tweets；比如你新发了一条tweet，就要上拉，方可显示在timeline上；如果没有最新的，向下拉到底部后，自动加载更早的tweets。</p>
<p>这种情况下，homeTimelines下的lastFetch.bottom和lastFetch.top，分别为时间戳，记录最后一次更新数据的信息。<br>cursor.bottom和cursor.top值分别为一个tweet id，表示当前timeline上，最上边和最底部分别是哪一条tweet。</p>
<p>最后一个非常有意思的是，entities下除了存在entities/tweets之外，还分别有cards, lists and users；当你打开这其余三项的时候，会发现这三项与entities/tweets保持在相同的结构，他们都一个fetchStatus的data table，key为tweet id, value为加载状态，据统计一共有一下几种：<br>‘none’;<br>‘loading’;<br>‘loaded’;<br>‘failed’.</p>
<p>这几种状态的设置无外乎这么几个目的：<br>保证在loading状态或loaded的tweet不会再发送请求给server；<br>在未加载完时，可以显示加载动画或者展位图；<br>在加载失败时，可以显示失败提示或者在此请求时进行补救。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了Twitter在采用Redux架构下的数据设计结构，在一个复杂的场景下，希望引起读者对redux能有一个更深入的认识。</p>
<p>Happy coding!</p>
<p>PS: 作者<a href="https://github.com/HOUCe" target="_blank" rel="external">Github仓库</a>，欢迎通过代码各种形式交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天刷Twitter，发现Nicolas（Engineering at @twitter. Technical Lead for Twitter Lite）发布了这么一条推文：&lt;/p&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;p&gt;大家可以忽略我未发的留言lol～&lt;/p&gt;
&lt;p&gt;大体意思就是
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>做出Uber移动网页版还不够 极致性能打造才见真章</title>
    <link href="https://exp-team.github.io/blog/2017/04/20/js/uber-clone-performance/"/>
    <id>https://exp-team.github.io/blog/2017/04/20/js/uber-clone-performance/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2017-04-10T04:55:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前分享过两篇关于React技术栈的原创文章：</p>
<ul>
<li><a href="http://www.jianshu.com/p/cde3cf7e2760" target="_blank" rel="external">React+Redux打造“NEWS EARLY”单页应用 一个项目理解最前沿技术栈真谛</a></li>
<li><a href="http://www.jianshu.com/p/8e28be0e7ab1" target="_blank" rel="external">一个react+redux工程实例</a>。</li>
</ul>
<p>今天进一步剖析一个实际案例：<strong>Uber APP 移动网页版。</strong></p>
<p>如果你对React技术栈没有多大兴趣，或者不是很了解，也没有关系。因为读下来，你会发现，这篇文章的真谛其实在于<strong>性能优化</strong>上。</p>
<p>本文灵感和主体内容翻译自Narendra N Shetty的<a href="https://hackernoon.com/how-i-built-a-super-fast-uber-clone-for-mobile-web-863680d2100f" target="_blank" rel="external">文章：How I built a super fast Uber clone for mobile web</a>，同时进行了大量扩充以及深挖。</p>
<h2 id="出发点和产品雏形"><a href="#出发点和产品雏形" class="headerlink" title="出发点和产品雏形"></a>出发点和产品雏形</h2><p>很早以来，相信大家都会认同一个观点：<strong>移动端流量超越PC端是不争的事实。</strong>对于前端开发者来说，移动端web的开发同样非常有趣，也充满挑战。</p>
<p>这不，Uber最近发布了最新版本APP，全新样式，体验超棒。于是，笔者决定使用React来从零开始构建一个新的属于自己的Uber。</p>
<p>开发期间，笔者花费了很多时间在基础组件和样式搭建上。这环节中，主要应用了<a href="https://github.com/uber/react-map-gl" target="_blank" rel="external">Uber官方开放的React地图库</a>，并在地图上“目的地”和“起始点”之间采用svg-overlay和html-overlay去绘制路线。</p>
<p>最终的基本交互可以参考下面Gif图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-59027620881f3e91.gif?imageMogr2/auto-orient/strip" alt="uber.gif"></p>
<h2 id="走上优化之路"><a href="#走上优化之路" class="headerlink" title="走上优化之路"></a>走上优化之路</h2><p>现在，我们有基本的产品形态了。目前面临的问题在于提高产品的各方面性能体验。我使用了Chrome Lighthouse去检验产品的性能表现。最终得到的结果为：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-ea0f448ffd3ae4f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果1.png"></p>
<p>wow…<br>第一次绘制时间就已经<strong>接近2秒</strong>，后面的时间惨不忍睹就不要看了吧。<br>想象一下，一个用户拿出手机，企图叫车。主屏时间的绘制就超过了19189.9ms，这是极其不能忍受的。</p>
<p>接下来，什么也不说了，撸起袖子，想办法去优化吧。</p>
<h2 id="优化方法1－代码分离（Code-Splitting）"><a href="#优化方法1－代码分离（Code-Splitting）" class="headerlink" title="优化方法1－代码分离（Code Splitting）"></a>优化方法1－代码分离（Code Splitting）</h2><p>我最开始想到并使用的方法就是：Code Splitting（代码分离），正好我们可以借助webpack来实现这项技术。<br>什么是webpack code splitting呢? 您可以参考<a href="https://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">这里</a>，如果英语阅读吃力，可以参考下面引文：</p>
<blockquote>
<p>code splitting就是指将文件分割为块(chunk)，webpack使我们可以定义一些分割点(split point)，根据这些分割点对文件进行分块，并实现按需加载。</p>
</blockquote>
<p>因为笔者使用了React技术栈，并采用了react-router，所以代码的划分（split）就可以按照路由和加载时机进行。具体操作可以使用react-router的getComponent api来实现：</p>
<pre><code>&lt;Route path=&quot;home&quot; name=&quot;home&quot; getComponent={(nextState, cb) =&gt; {
    require.ensure([], (require) =&gt; {
        cb(null, require(&apos;../components/Home&apos;).default);
    }, &apos;HomeView&apos;);
}}&gt; 
</code></pre><p>只有当对应路由被请求时，相应的组件才会被加载呈现。</p>
<p>同时，笔者使用了webpack的CommonChunkPlugin插件提取第三方代码。这是出于什么考虑呢？</p>
<p>细心的读者可能会发现上面的code splitting也许会存在一个问题：<br><strong>按需（按路由）引入资源后，这些资源可能存在大量重复代码。尤其是我们使用的第三方资源。</strong><br>想明白这个问题，这时候，你应该就会明白CommonChunkPlugin这个插件的意义了。关于这个插件配置方法有多种，这里我们采用了：有选择性的提取（对象方式传参）：</p>
<pre><code>{
    &apos;entry&apos;: {
        &apos;app&apos;: &apos;./src/index.js&apos;,
        &apos;vendor&apos;: [
            &apos;react&apos;,
            &apos;react-redux&apos;,
            &apos;redux&apos;,
            &apos;react-router&apos;,
            &apos;redux-thunk&apos;
        ]
    },
    &apos;output&apos;: {
        &apos;path&apos;: path.resolve(__dirname, &apos;./dist&apos;),
        &apos;publicPath&apos;: &apos;/&apos;,
        &apos;filename&apos;: &apos;static/js/[name].[hash].js&apos;,
        &apos;chunkFilename&apos;: &apos;static/js/[name].[hash].js&apos;
    },
    &apos;plugins&apos;: [
        new webpack.optimize.CommonsChunkPlugin({
            name: [&apos;vendor&apos;], // 公共块的块名称
            minChunks: Infinity, // 最小被引用次数，最小是2。传递Infinity只是创建公共块，但不移动模块。 
            filename: &apos;static/js/[name].[hash].js&apos;, // 公共块的文件名
        }),
    ]
}
</code></pre><p>这样子，我们把公共代码（react、react-redux、redux、react-router、redux-thunk）专门抽取到vendor模块中。</p>
<p>通过上述方法，笔者欣喜地发现：<br>First meaningful paint时间由19189.9ms缩短到4584.3ms：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-b7384bf2a9c9bb5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果2"></p>
<p>这无疑是激动人心的。</p>
<h2 id="优化方法2－Server-side-rendering（服务端直出）"><a href="#优化方法2－Server-side-rendering（服务端直出）" class="headerlink" title="优化方法2－Server side rendering（服务端直出）"></a>优化方法2－Server side rendering（服务端直出）</h2><p>也许你一直在听说过“服务端渲染”或者“服务端直出”这样的名词。但是从未实践过，也从来没有了解过他的意义。好吧，这里我先描述一下，到底什么是服务端直出。</p>
<p>服务端直出，其实简单总结为服务器在接到来自浏览器第一次请求时，便返回一个“初步最终”HTML文档。这个HTML文档已经进行了数据拼接。这样用户能以最快的时间看到首屏的效果，当然这个效果是“阉割版”的，非最终版本。</p>
<p>这种方式主要是针对“前后分离”的传统模式。传统模式中，服务器返回HTML文档，之后浏览器解析文档标签，拉取CSS，之后拉取JS文件。JS文件加载完成之后，执行JS内容，并发送请求获取数据。最终，将数据渲染在页面上。</p>
<p>由此，Server side rendering方式将JS请求数据的过程放在了服务器上，甚至对于数据与HTML结合处理也可以在服务器上做。</p>
<p>这样一来，<strong>主要就是加快了首屏渲染时间。</strong>当然，使用服务端渲染，还能够优化前端渲染难以克服的SEO问题。</p>
<p>理论理解起来很简单，难处就在于服务器端环境的前端脚本如何处理，如何与客户端保持一致。</p>
<p>在这个项目中，我使用了Express作为nodeJS框架，结合react－router完成：</p>
<pre><code>server.use((req, res)=&gt; {
    match({
    &apos;routes&apos;: routes,
    &apos;location&apos;: req.url
    }, (error, redirectLocation, renderProps) =&gt; {
        if (error) {
            res.status(500).send(error.message);
        } 
        else if (redirectLocation) {
            res.redirect(302, redirectLocation.pathname + redirectLocation.search);
        } 
        else if (renderProps) {
            // Create a new Redux store instance
            const store = configureStore();

            // Render the component to a string
            const html = renderToString(&lt;Provider store={store}&gt;&lt;RouterContext {...renderProps} /&gt;&lt;/Provider&gt;);

            const preloadedState = store.getState();

            fs.readFile(&apos;./dist/index.html&apos;, &apos;utf8&apos;, function (err, file) {
                if (err) {
                    return console.log(err);
                }
                let document = file.replace(/&lt;div id=&quot;app&quot;&gt;&lt;\/div&gt;/, `&lt;div id=&quot;app&quot;&gt;${html}&lt;/div&gt;`);
                document = document.replace(/&apos;preloadedState&apos;/, `&apos;${JSON.stringify(preloadedState)}&apos;`);
                res.setHeader(&apos;Cache-Control&apos;, &apos;public, max-age=31536000&apos;);
                res.setHeader(&quot;Expires&quot;, new Date(Date.now() + 2592000000).toUTCString());
                res.send(document);
            });
        } 
        else {
            res.status(404).send(&apos;Not found&apos;)
        }
    });
});
</code></pre><p>通过上述方法，我们欣喜地发现：<br>First meaningful paint时间已经缩短到921.5ms：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-b4c9aa1eff18344c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果3"></p>
<p>这无疑是令人振奋的。</p>
<h2 id="优化方法3－Compressed-static-assets（压缩静态文件）"><a href="#优化方法3－Compressed-static-assets（压缩静态文件）" class="headerlink" title="优化方法3－Compressed static assets（压缩静态文件）"></a>优化方法3－Compressed static assets（压缩静态文件）</h2><p>压缩文件，当然是一个容易想到而且行之有效的措施。为此，我使用了webpack的CompressionPlugin插件：</p>
<pre><code>{
    &apos;plugins&apos;: [
        new CompressionPlugin({
            test: /\.js$|\.css$|\.html$/
        })
    ]
}
</code></pre><p>同时，使用express-static-gzip来对服务端进行配置：</p>
<pre><code>server.use(&apos;/static&apos;, expressStaticGzip(&apos;./dist/static&apos;, {
    &apos;maxAge&apos;: 31536000,
    setHeaders: function(res, path, stat) {
    res.setHeader(&quot;Expires&quot;, new Date(Date.now() + 2592000000).toUTCString());
        return res;
    }
}));
</code></pre><p>express-static-gzip是一个处于express.static之上的中间件。如果对于指定路径的文件没有找到压缩版本，就使用为压缩版本进行返回。</p>
<p>经过此处理，我们缩短了400ms时间，OK，现在First meaningful paint时间为546.6ms.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-29234133ac7f9edd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果4"></p>
<h2 id="优化方法4－Caching（缓存）"><a href="#优化方法4－Caching（缓存）" class="headerlink" title="优化方法4－Caching（缓存）"></a>优化方法4－Caching（缓存）</h2><p>截止到此，我们已经从最初的19189.9ms已经优化到546ms，我们当然继续可以在客户端进行<strong>静态文件缓存</strong>来使得加载时间变得更短。</p>
<p>笔者使用了<a href="https://github.com/GoogleChrome/sw-toolbox" target="_blank" rel="external">sw-toolbox</a>搭配service workers进行。</p>
<blockquote>
<p>sw-toolbox：A collection of service worker tools for offlining runtime requests.<br>Service Worker Toolbox provides some simple helpers for use in creating your own service workers. Specifically, it provides common caching strategies for dynamic content, such as API calls, third-party resources, and large or infrequently used local resources that you don’t want precached.</p>
</blockquote>
<p>简单翻译下：<br>Service Worker实现常见运行时缓存模式，例如动态内容、API调用以及第三方资源，实现方法就像编写README一样简单。</p>
<p>也许到这里你一头雾水，没关系，我们从最初开始，了解一下什么是service worker:</p>
<blockquote>
<p>在2014年，W3C公布了service worker的草案，service worker提供了很多新的能力，使得web app拥有与native app相同的离线体验、消息推送体验。<br>service worker是一段脚本，与web worker一样，也是在后台运行。<br>作为一个独立的线程，运行环境与普通脚本不同，所以不能直接参与web交互行为。native app可以做到离线使用、消息推送、后台自动更新，service worker的出现是正是为了使得web app也可以具有类似的能力。</p>
</blockquote>
<p>而sw-toolbox，顾名思义，就是service worker一个toolbox，具体我们看代码：</p>
<pre><code>toolbox.router.get(&apos;(.*).js&apos;, toolbox.fastest, {
    &apos;origin&apos;:/.herokuapp.com|localhost|maps.googleapis.com/,
    &apos;mode&apos;:&apos;cors&apos;,
    &apos;cache&apos;: {
        &apos;name&apos;: `js-assets-${VERSION}`,
        &apos;maxEntries&apos;: 50,
        &apos;maxAgeSeconds&apos;: 2592e3
    }
});
</code></pre><p>上面代码的意思是，我们对于get类型的请求，当请求内容为js脚本时，应用toolbox.fastest handler处理。<br>toolbox.fastest指示：对于这个请求，我们既从缓存中获取，也同时通过正常的请求network获取。<strong>这两种方式哪个返回快，就应用哪一个。</strong><br>另外，toolbox.router.get的第三个参数表示配置项。</p>
<p>考虑周到的读者可能会想，上面是对于支持Service worker的浏览器，那么对于不支持的浏览器呢？我们干脆设置：</p>
<pre><code>res.setHeader(&quot;Expires&quot;, new Date(Date.now() + 2592000000).toUTCString());
</code></pre><p>通过这样处理，我们来直观感受一下页面加载瀑布流：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-1a5ca5dd910efece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Service worker"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-456cb5a07f1acd0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="不使用Service worker"></p>
<h2 id="优化方法5－Preload-and-then-load（预加载／延后加载）"><a href="#优化方法5－Preload-and-then-load（预加载／延后加载）" class="headerlink" title="优化方法5－Preload and then load（预加载／延后加载）"></a>优化方法5－Preload and then load（预加载／延后加载）</h2><p>如果你还没听说过“Preload”，不要紧。我们这就来了解一下：</p>
<blockquote>
<p>Preload作为一个新的web标准，旨在提高性能和为web开发人员提供更细粒度的加载控制。Preload使开发者能够自定义资源的加载逻辑，且无需忍受基于脚本的资源加载器带来的性能损失。</p>
</blockquote>
<p>换成你能听明白的话来说：<br><strong>preload建议允许始终预加载某些资源，浏览器必须请求preload标记的资源。</strong></p>
<p>这样子，究竟有什么意义呢？<br>举个例子：比如一些隐藏在CSS和Javascript中的资源。<br>当浏览器发现自己需要这些资源时已经为时已晚，所以大多数情况，这些资源的加载都会对页面渲染造成延迟。</p>
<p>preload的出现就是为了优化这个过程。<br>对于preload的兼容性，可以参考<a href="http://caniuse.com/#search=preload" target="_blank" rel="external">这里。</a></p>
<p>对于不支持preload的浏览器，笔者使用了prefetch来处理。<br>但于preload不同，prefetch的作用是告诉浏览器加载下一页面可能会用到的资源，注意，是下一页面，而不是当前页面。因此该方法的加载优先级非常低。</p>
<p>这些新标准其实很有意思，里面的内容远不止这些。有兴趣的同学可以自行了解，也欢迎与我讨论。</p>
<p>回到正题，我在head标签中使用：</p>
<pre><code>&lt;link rel=&quot;preload&quot; ... as=&quot;script&quot;&gt;
</code></pre><p>最终优化的结果如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-8823ee4b69444430.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终结果"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，使用React＋Webpack做出一个Uber已经不是重点了。真正激动人心的是整套流程的优化之路。我们使用了大量成熟的、未成熟（新技术），希望对读者有所启发！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前分享过两篇关于React技术栈的原创文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/cde3cf7e2760&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React+Redux打造“NEWS EA
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于数组乱序的深挖——“感觉一直在写毒代码”</title>
    <link href="https://exp-team.github.io/blog/2017/04/20/js/shuffle-array/"/>
    <id>https://exp-team.github.io/blog/2017/04/20/js/shuffle-array/</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一篇非常有趣的文章：<a href="http://mp.weixin.qq.com/s/0j7iMJwaXYt3BD036M8s-w" target="_blank" rel="external">关于JavaScript的数组随机排序</a>，其作者为oldj前辈。<br>文中指出了我们用来“将一个数组随机排序”的经典写法存在的问题，获益匪浅。</p>
<p>本文将以更加详尽的材料和更多样的code demo进行阐述。并尝试用“Fisher–Yates shuffle”洗牌算法进行终极解答。</p>
<h2 id="多个熟悉的场景"><a href="#多个熟悉的场景" class="headerlink" title="多个熟悉的场景"></a>多个熟悉的场景</h2><p>将一个数组进行乱序处理，是一个非常简单但是非常常用的需求。比如，“猜你喜欢”、“点击换一批”、“中奖方案”等等都可能应用到这样的处理。包括我自己在写代码的时候，也确实遇到过。当时的处理很简单也很流行：对对象数组采用array.sort()方法，并传入一个比较函数（comparison function），这个比较函数随机返回一个介于［－0.5， 0.5］之间的数值：</p>
<pre><code>var numbers = [12,4,16,3];
numbers.sort(function() {
    return .5 - Math.random();
});
</code></pre><p>关于这个做的理论基础这里不再进行阐释。如果您不明白，可以了解一下JS中sort函数的使用方法。</p>
<h2 id="有毒的array-sort方法"><a href="#有毒的array-sort方法" class="headerlink" title="有毒的array.sort方法"></a>有毒的array.sort方法</h2><p>正像oldj前辈文章指出的那样，其实使用这个方法乱序一个数组是有问题的。</p>
<p>为此，我写了一个脚本进行验证。强烈建议读者去<a href="">Github</a>围观一下，可以clone下来自己试验。</p>
<p>脚本中，我对</p>
<pre><code>var letters = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;];
</code></pre><p>letters这样一个数组使用上述方法进行了10000次排序，并把排序结果存储在countings当中。结果在页面上进行输出：</p>
<pre><code>var countings = [
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0},
    {A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0}
];
var letters=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;];
for (var i = 0; i &lt; 10000; i++) {
    var r = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;].sort(function() {
        return .5 - Math.random();
    });
    for(var j = 0; j &lt;= 9; j++) {
        countings[j][r[j]]++;
    }
}
for(var i = 0; i &lt;= 9;i++) {
    for(var j = 0;j &lt;= 9;j++) {
        document.getElementById(&apos;results&apos;).rows[i + 1].cells[j + 1].firstChild.data = countings[i][letters[j]];
    }
}
</code></pre><p>做中得到结果如图：</p>
<pre><code>图片
</code></pre><p>如果点击“recalculate”按钮，可以进行多次10000次取样试验。</p>
<p>不管点击按钮几次，你都会发现整体乱序之后的结果绝对不是“完全随机”。由此可以得出结论，使用array.sort方法进行乱序处理，绝对是有问题的。</p>
<h2 id="array-sort方法底层究竟如何实现？"><a href="#array-sort方法底层究竟如何实现？" class="headerlink" title="array.sort方法底层究竟如何实现？"></a>array.sort方法底层究竟如何实现？</h2><p>但是为什么会有问题呢？这需要从array.sort方法排序底层说起。<br>在<a href="https://github.com/v8/v8/blob/master/src/js/array.js" target="_blank" rel="external">Chrome v8引擎源码中</a>，可以清晰看到，</p>
<blockquote>
<p>v8在处理sort方法时，使用了插入排序和快排两种方案。当目标数组长度小于10时，使用插入排序；反之，使用快排。<br>Chrome’s v8 uses a combination of InsertionSort and QuickSort. That is, if the array is less than 10 elements in length, it uses an InsertionSort.</p>
</blockquote>
<p>其实不管用什么排序方法，大多数排序算法的时间复杂度介于O(n)到O(n2)之间，元素之间的比较次数通常情况下要远小于n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。</p>
<p>怎么理解上边这句话呢？其实我们想使用array.sort进行乱序，理想的方案或者说纯乱序的方案是数组中每两个元素都要进行比较，这个比较有50%的交换位置概率。这样一来，比较次数为n(n-1)。而在sort排序算法中，大多数情况都不会满足这样的条件。因而当然不是完全随机的结果了。</p>
<p>顺便说一下，关于v8引擎的排序方案，源码使用JS实现的，利于前端程序员阅读。其中，使用了大量的性能优化技巧，尤其是关于快排的pivot选择上十分有意思。感兴趣的读者不妨研究一下。</p>
<h2 id="真正意义上的乱序"><a href="#真正意义上的乱序" class="headerlink" title="真正意义上的乱序"></a>真正意义上的乱序</h2><p>要想实现真正意义上的乱序，其实不难。我们首先要规避不稳定的array.sort方法。在计算机科学中，有一个专门的：<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank" rel="external">洗牌算法Fisher–Yates shuffle。</a>如果你对算法天生迟钝，也不要慌张。这里我一步一步来实现，相信您一定要得懂。</p>
<p>先来整体看一下所有代码实现，一共也就10行：</p>
<pre><code>Array.prototype.shuffle = function() {
    var input = this;
    for (var i = input.length-1; i &gt;=0; i--) {
        var randomIndex = Math.floor(Math.random()*(i+1)); 
        var itemAtIndex = input[randomIndex]; 
        input[randomIndex] = input[i]; 
        input[i] = itemAtIndex;
    }
    return input;
}
var tempArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
tempArray.shuffle();
console.log(tempArray);  
</code></pre><p>解析：<br>首先我们有一个已经排好序的数组：<br>图片</p>
<p>Step1：<br>第一步需要做的就是，从数组末尾开始，选取最后一个元素。<br>在数组一共9个位置中，随机产生一个位置，该位置元素与最后一个元素进行交换。</p>
<p>Step2：<br>我们已经把数组末尾元素进行随机置换。<br>接下来，对数组倒数第二个元素动手。在除去已经排好的最后一个元素位置以外的8个位置中，随机产生一个位置，该位置元素与倒数第二个元素进行交换。</p>
<p>Step3：<br>理解了前两部，接下来就是依次进行，如此简单。</p>
<h2 id="自己实现乱序"><a href="#自己实现乱序" class="headerlink" title="自己实现乱序"></a>自己实现乱序</h2><p>以上方法，是基于Fisher–Yates shuffle洗牌算法。下面，我们就需要自己开动脑筋，完成一个乱序方案。<br>其实这并不难，关键在于如何生产真正的乱序。因为往往生成的并不是完全意义上的乱序，关于这一点，读者可以参考<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank" rel="external">The Danger of Naïveté</a>一文。</p>
<p>我们来看一下社区上<a href="http://www.cnblogs.com/Wayou/p/fisher_yates_shuffle.html" target="_blank" rel="external">刘哇勇</a>的一系列进阶方案：</p>
<pre><code>function shuffle (array) {
    var copy = [],
        n = array.length,
        i;
    while (n) {
        i = Math.floor(Math.random() * array.length);
        if (i in array) {
            copy.push(array[i]);
            delete array[i];
            n--;
        }
    }
    return copy;
}
</code></pre><p>关于这种方案，也给出了分析：<br>我们创建了一个copy数组，然后遍历目标数组，将其元素复制到copy数组里，同时将该元素从目标数组中删除，这样下次遍历的时候就可以跳过这个序号。而这一实现的问题正在于此，即使一个序号上的元素已经被处理过了，由于随机函数产生的数是随机的，所有这个被处理过的元素序号可能在之后的循环中不断出现，一是效率问题，另一个就是逻辑问题了，存在一种可能是永远运行不完。</p>
<p>改进的方案为：</p>
<pre><code>function shuffle(array) {
    var copy = [],
        n = array.length,
        i;
    while (n) {
        i = Math.floor(Math.random() * n--);
        copy.push(array.splice(i, 1)[0]);
    }
    return copy;
}
</code></pre><p>改进的做法就是处理完一个元素后，用Array的splice()方法将其从目标数组中移除同时也更新了目标数组的长度。如此一来下次遍历的时候是从新的长度开始，不会重复处理的情况了。</p>
<p>当然这样的方案也有不足之处：比如，我们创建了一个copy数组进行返回，在内存上开辟了新的空间。<br>当然，这可以完全避免：</p>
<pre><code>function shuffle(array) {
    var m = array.length,
        t, i;
    while (m) {
        i = Math.floor(Math.random() * m--);
        t = array[m];
        array[m] = array[i];
        array[i] = t;
    }
    return array;
}
</code></pre><p>有趣的是，这样的实现已经完全等同于上文洗牌算法Fisher–Yates shuffle的方案了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文剖析了乱序数组，这么一个简单但是有趣的需求场景。并且介绍了部分V8引擎对array.sort的处理、洗牌算法Fisher–Yates等内容。<br>同时也安利了一个<a href="">可视化array.sort乱序的例证。</a>希望对读者有所启发。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一篇非常有趣的文章：&lt;a href=&quot;http://mp.weixin.qq.com/s/0j7iMJwaXYt3BD036M8s-w&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于JavaScript的数组随机排序&lt;/a&gt;，其作者为oldj前
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Async/Await 完爆Promise的6个原因</title>
    <link href="https://exp-team.github.io/blog/2017/04/14/js/async/"/>
    <id>https://exp-team.github.io/blog/2017/04/14/js/async/</id>
    <published>2017-04-13T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从Node的7.6版本，已经默认支持async/await特性了。如果你还没有使用过他，或者对他的用法不太了解，这篇文章会告诉你为什么这个特性“不容错过”。本文辅以大量实例，相信你能很轻松的看懂，并了解Javascript处理异步的一大杀器。</p>
<p>文章灵感和内容借鉴了<a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="external">6 Reasons Why JavaScript’s Async/Await Blows Promises Away (Tutorial)</a>，英文好的同学可以直接戳原版参考。</p>
<h2 id="初识Async-await"><a href="#初识Async-await" class="headerlink" title="初识Async/await"></a>初识Async/await</h2><p>对于还不了解Async/await特性的同学，下面一段是一个“速成”培训。<br>Async/await 是Javascript编写异步程序的新方法。以往的异步方法无外乎回调函数和Promise。但是Async/await建立于Promise之上。对于Javascript处理异步，是个老生常谈却历久弥新的话题：</p>
<blockquote>
<p>从最早的回调函数，到 Promise 对象，再到 Generator 函数，每次都有所改进，但又让人觉得不彻底。它们都有额外的复杂性，都需要理解抽象的底层运行机制。<br>异步编程的最高境界，就是根本不用关心它是不是异步。<br>async 函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。</p>
</blockquote>
<h2 id="Async-await语法"><a href="#Async-await语法" class="headerlink" title="Async/await语法"></a>Async/await语法</h2><p>试想一下，我们有一个getJSON方法，该方法发送一个异步请求JSON数据，并返回一个promise对象。这个promise对象的resolve方法传递异步获得的JSON数据。具体例子的使用如下：</p>
<pre><code>const makeRequest = () =&gt;
    getJSON()
        .then(data =&gt; {
            console.log(data)
            return &quot;done&quot;
        })

makeRequest()
</code></pre><p>在使用async/await时，写法如下：</p>
<pre><code>const makeRequest = async () =&gt; {
    console.log(await getJSON())
    return &quot;done&quot;
}

makeRequest()
</code></pre><p>对比两种写法，针对第二种，我需要进一步说明：</p>
<p>1）第二种写法（使用async/await），在主体函数之前使用了async关键字。在函数体内，使用了await关键字。当然await关键字只能出现在用async声明的函数体内。该函数会隐式地返回一个Promise对象，函数体内的return值，将会作为这个Promise对象resolve时的参数。<br>可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>2）示例中，await getJSON() 说明console.log的调用，会等到getJSON()返回的promise对象resolve之后触发。</p>
<p>我们在看一个例子加强一下理解，该例子取自阮一峰大神的《ECMAScript 6 入门》一书：</p>
<pre><code>function timeout(ms) {
    return new Promise((resolve) =&gt; {
        setTimeout(resolve, ms);
    });
}

async function asyncPrint(value, ms) {
    await timeout(ms);
    console.log(value);
}

asyncPrint(&apos;hello world&apos;, 50);
</code></pre><p>上面代码指定50毫秒以后，输出hello world。</p>
<h2 id="Async-await究竟好在哪里？"><a href="#Async-await究竟好在哪里？" class="headerlink" title="Async/await究竟好在哪里？"></a>Async/await究竟好在哪里？</h2><p>那么，同样是处理异步操作，Async/await究竟好在哪里呢？<br>我们总结出以下6点。</p>
<h3 id="简约而干净Concise-and-clean"><a href="#简约而干净Concise-and-clean" class="headerlink" title="简约而干净Concise and clean"></a>简约而干净Concise and clean</h3><p>我们看一下上面两处代码的代码量，就可以直观地看出使用Async/await对于代码量的节省是很明显的。对比Promise，我们不需要书写.then，不需要新建一个匿名函数处理响应，也不需要再把数据赋值给一个我们其实并不需要的变量。同样，我们避免了耦合的出现。这些看似很小的优势其实是很直观的，在下面的代码示例中，将会更加放大。</p>
<h3 id="错误处理Error-handling"><a href="#错误处理Error-handling" class="headerlink" title="错误处理Error handling"></a>错误处理Error handling</h3><p>Async/await使得处理同步＋异步错误成为了现实。我们同样使用try/catch结构，但是在promises的情况下，try/catch难以处理在JSON.parse过程中的问题，原因是这个错误发生在Promise内部。想要处理这种情况下的错误，我们只能再嵌套一层try/catch，就像这样：</p>
<pre><code>const makeRequest = () =&gt; {
    try {
    getJSON()
        .then(result =&gt; {
            // this parse may fail
            const data = JSON.parse(result)
            console.log(data)
        })
        // uncomment this block to handle asynchronous errors
        // .catch((err) =&gt; {
        //   console.log(err)
        // })
        } 
    catch (err) {
        console.log(err)
    }
}
</code></pre><p>但是，如果用async/await处理，一切变得简单，解析中的错误也能轻而易举的解决：</p>
<p>const makeRequest = async () =&gt; {<br>    try {<br>        // this parse may fail<br>        const data = JSON.parse(await getJSON())<br>        console.log(data)<br>    }<br>    catch (err) {<br>        console.log(err)<br>    }<br>}</p>
<h3 id="条件判别Conditionals"><a href="#条件判别Conditionals" class="headerlink" title="条件判别Conditionals"></a>条件判别Conditionals</h3><p>想象一下这样的业务需求：我们需要先拉取数据，然后根据得到的数据判断是否输出此数据，或者根据数据内容拉取更多的信息。如下：</p>
<pre><code>const makeRequest = () =&gt; {
    return getJSON()
        .then(data =&gt; {
            if (data.needsAnotherRequest) {
                return makeAnotherRequest(data)
                        .then(moreData =&gt; {
                            console.log(moreData)
                            return moreData
                        })
            } 
            else {
                console.log(data)
                return data
            }
        })
}
</code></pre><p>这样的代码会让我们看的头疼。这这么多层（6层）嵌套过程中，非常容易“丢失自我”。<br>使用async/await，我们就可以轻而易举的写出可读性更高的代码：</p>
<pre><code>const makeRequest = async () =&gt; {
    const data = await getJSON()
    if (data.needsAnotherRequest) {
        const moreData = await makeAnotherRequest(data);
        console.log(moreData)
        return moreData
    } 
    else {
        console.log(data)
        return data    
    }
}
</code></pre><h3 id="中间值Intermediate-values"><a href="#中间值Intermediate-values" class="headerlink" title="中间值Intermediate values"></a>中间值Intermediate values</h3><p>一个经常出现的场景是，我们先调起promise1，然后根据返回值，调用promise2，之后再根据这两个Promises得值，调取promise3。使用Promise，我们不难实现：</p>
<pre><code>const makeRequest = () =&gt; {
    return promise1()
        .then(value1 =&gt; {
            // do something
            return promise2(value1)
                .then(value2 =&gt; {
                    // do something          
                    return promise3(value1, value2)
                })
        })
}
</code></pre><p>如果你难以忍受这样的代码，我们可以优化我们的Promise，方案是使用Promise.all来避免很深的嵌套。<br>就像这样：</p>
<pre><code>const makeRequest = () =&gt; {
    return promise1()
        .then(value1 =&gt; {
            // do something
            return Promise.all([value1, promise2(value1)])
        })
        .then(([value1, value2]) =&gt; {
            // do something          
            return promise3(value1, value2)
        })
}
</code></pre><p>Promise.all这个方法牺牲了语义性，但是得到了更好的可读性。<br>但是其实，把value1 &amp; value2一起放到一个数组中，是很“蛋疼”的，某种意义上也是多余的。</p>
<p>同样的场景，使用async/await会非常简单：</p>
<pre><code>const makeRequest = async () =&gt; {
    const value1 = await promise1()
    const value2 = await promise2(value1)
    return promise3(value1, value2)
}
</code></pre><h3 id="错误堆栈信息Error-stacks"><a href="#错误堆栈信息Error-stacks" class="headerlink" title="错误堆栈信息Error stacks"></a>错误堆栈信息Error stacks</h3><p>想象一下我们链式调用了很多promises，一级接一级。紧接着，这条promises链中某处出错，如下：</p>
<pre><code>const makeRequest = () =&gt; {
    return callAPromise()
        .then(() =&gt; callAPromise())
        .then(() =&gt; callAPromise())
        .then(() =&gt; callAPromise())
        .then(() =&gt; callAPromise())
        .then(() =&gt; {
            throw new Error(&quot;oops&quot;);
        })
}

makeRequest()
    .catch(err =&gt; {
        console.log(err);
        // output
        // Error: oops at callAPromise.then.then.then.then.then (index.js:8:13)
    })
</code></pre><p>此链条的错误堆栈信息并没用线索指示错误到底出现在哪里。更糟糕的事，他还会误导开发者：错误信息中唯一出现的函数名称其实根本就是无辜的。<br>我们再看一下async/await的展现：</p>
<pre><code>const makeRequest = async () =&gt; {
    await callAPromise()
    await callAPromise()
    await callAPromise()
    await callAPromise()
    await callAPromise()
    throw new Error(&quot;oops&quot;);
}

makeRequest()
    .catch(err =&gt; {
        console.log(err);
        // output
        // Error: oops at makeRequest (index.js:7:9)
    })
</code></pre><p>也许这样的对比，对于在本地开发阶段区别不是很大。但是想象一下在服务器端，线上代码的错误日志情况下，将会变得非常有意义。你一定会觉得上面这样的错误信息，比“错误出自一个then的then的then。。。”有用的多。</p>
<h3 id="调试Debugging"><a href="#调试Debugging" class="headerlink" title="调试Debugging"></a>调试Debugging</h3><p>最后一点，但是也是很重要的一点，使用async/await来debug会变得非常简单。<br>在一个返回表达式的箭头函数中，我们不能设置断点，这就会造成下面的局面：</p>
<pre><code>const makeRequest = () =&gt; {
    return callAPromise()
        .then(()=&gt;callAPromise())
        .then(()=&gt;callAPromise())
        .then(()=&gt;callAPromise())
        .then(()=&gt;callAPromise())
}
</code></pre><p>我们无法在每一行设置断点。但是使用async/await时：</p>
<pre><code>const makeRequest = async () =&gt; {
    await callAPromise()
    await callAPromise()
    await callAPromise()
    await callAPromise()
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Async/await是近些年来JavaScript最具革命性的新特性之一。他让读者意识到使用Promise存在的一些问题，并提供了自身来代替Promise的方案。<br>当然，对这个新特性也有一定的担心，体现在：<br>他使得异步代码变的不再明显，我们好不容易已经学会并习惯了使用回调函数或者.then来处理异步。新的特性当然需要时间成本去学习和体会；<br>退回来说，熟悉C#语言的程</p>
<p>PS: 作者<a href="https://github.com/HOUCe" target="_blank" rel="external">Github仓库</a>，欢迎通过代码各种形式交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从Node的7.6版本，已经默认支持async/await特性了。如果你还没有使用过他，或者对他的用法不太了解，这篇文章会告诉你为什么这个特性“不容错过”。本文辅以大量实例，相信你能很轻松的看懂，并了解Javascript处理异步的一大杀器。&lt;/p&gt;
&lt;p&gt;文章灵感和内容
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>通过实例，学习编写React组件的最佳实践</title>
    <link href="https://exp-team.github.io/blog/2017/04/14/js/react-best-pratice/"/>
    <id>https://exp-team.github.io/blog/2017/04/14/js/react-best-pratice/</id>
    <published>2017-04-13T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在前端程序员都知道，React是组件化的。当我开始学习React的时候，我记得当时已经存在了很多不同编写组件的方式了。这个教程，那个教程，也许组件的组织方式不尽相同。如今，React社区已经愈发成熟，但是对于组件正确编写姿势却没有一个相对完备的指导。<br>这篇文章从作者的观点出发，来谈一谈我们究竟应该如何来写React组件。</p>
<p>在开始前，需要说明以下几个问题：<br>1）这篇文章以及代码实例，都采用了ES6或者ES7的写法；<br>2）对于一些基本概念不再进行科普。比如，如果你还不知道木偶组件（展示组件）和容器组件的区别，建议先对React基础进行学习；<br>3）如果有任何问题，欢迎留言交流。</p>
<p>另外，这篇文章并不是我原创，我翻译了<a href="https://engineering.musefind.com/our-best-practices-for-writing-react-components-dec3eb5c3fc8" target="_blank" rel="external">Our Best Practices for Writing React Components</a>一文，并在此基础上进行了较大扩展。<br>如果您对React生态有兴趣，推荐我的其他几篇文章：</p>
<h2 id="基于Class的组件编写Class-Based-Components"><a href="#基于Class的组件编写Class-Based-Components" class="headerlink" title="基于Class的组件编写Class Based Components"></a>基于Class的组件编写Class Based Components</h2><p>基于Class的组件是状态化的，包含有方法和属性等。最佳实践包括但不限于以下内容：</p>
<h3 id="引入CSS依赖Importing-CSS"><a href="#引入CSS依赖Importing-CSS" class="headerlink" title="引入CSS依赖Importing CSS"></a>引入CSS依赖Importing CSS</h3><p>我很喜欢CSS in JavaScript这一理念。但是在此之前，这都是停留于理论层面的。直到我们可以为每一个React组件引入相应的CSS文件，这一“梦想”成为了现实。在下面的代码示例中，我把CSS文件的引入与其他依赖隔行分开，以示区别：</p>
<pre><code>import React, {Component} from &apos;react&apos;
import {observer} from &apos;mobx-react&apos;

import ExpandableForm from &apos;./ExpandableForm&apos;
import &apos;./styles/ProfileContainer.css&apos;
</code></pre><h3 id="设定初始状态Initializing-State"><a href="#设定初始状态Initializing-State" class="headerlink" title="设定初始状态Initializing State"></a>设定初始状态Initializing State</h3><p>在编写组件过程中，一定要注意的是初始状态的设定。并且利用ES6模块化的知识，我们确保该组件的对外暴露都是“export default”形式，方便其他模块（组件）的调用。</p>
<pre><code>import React, {Component} from &apos;react&apos;
import {observer} from &apos;mobx-react&apos;

import ExpandableForm from &apos;./ExpandableForm&apos;
import &apos;./styles/ProfileContainer.css&apos;

export default class ProfileContainer extends Component {
    state = { expanded: false }
</code></pre><h3 id="设定propTypes和defaultProps"><a href="#设定propTypes和defaultProps" class="headerlink" title="设定propTypes和defaultProps"></a>设定propTypes和defaultProps</h3><p>propTypes和defaultProps都是组件的静态属性。在组件的代码中，这两个属性的设定位置越高越好。因为这样方便其他阅读代码者或者自己，一眼就能看到这些信息。这些信息就如同组件文档一样，对于理解或熟悉当前组件非常重要。<br>同样，原则上，你编写的组件都需要有propTypes属性。如同以下代码：</p>
<pre><code>export default class ProfileContainer extends Component {
    state = { expanded: false }

    static propTypes = {
        model: React.PropTypes.object.isRequired,
        title: React.PropTypes.string
    }

    static defaultProps = {
        model: {
            id: 0
        },
        title: &apos;Your Name&apos;
    }
</code></pre><h3 id="组件方法Methods"><a href="#组件方法Methods" class="headerlink" title="组件方法Methods"></a>组件方法Methods</h3><p>在编写方法时，尤其是你将一个方法作为props传递给子组件时，你需要确保this的正确指向。我们通常使用bind或者ES6箭头函数来达到此目的。</p>
<pre><code>export default class ProfileContainer extends Component {
    state = { expanded: false }

    handleSubmit = (e) =&gt; {
        e.preventDefault()
        this.props.model.save()
    }

    handleNameChange = (e) =&gt; {
        this.props.model.changeName(e.target.value)
    }

    handleExpand = (e) =&gt; {
        e.preventDefault()
        this.setState({ expanded: !this.state.expanded })
    }
</code></pre><h3 id="setState接受一个函数作为参数Passing-setState-a-Function"><a href="#setState接受一个函数作为参数Passing-setState-a-Function" class="headerlink" title="setState接受一个函数作为参数Passing setState a Function"></a>setState接受一个函数作为参数Passing setState a Function</h3><p>在上面的代码示例中，我们使用了：</p>
<pre><code>this.setState({ expanded: !this.state.expanded })
</code></pre><p>这里，关于setState hook函数，其实有一个非常“有意思”的问题。React在设计时，为了性能上的优化，采用了Batch思想，会收集“一波”state的变化，统一进行处理。就像浏览器绘制的实现一样。所以setState之后，state也许不会马上就发生变化。</p>
<p>这说明，我们要谨慎地在setState中使用当前的state，因为当前的state也许是不可靠的。<br>为了规避这个问题，我们可以这样做：</p>
<pre><code>this.setState(prevState =&gt; ({ expanded: !prevState.expanded }))
</code></pre><p>我们给setState方法传递一个函数，函数参数为上一刻state，来保证setState能够立刻执行。</p>
<p>关于React setState的设计，我的长发“男神”Eric Elliott也曾经这么喷过：<a href="https://medium.com/javascript-scene/setstate-gate-abc10a9b2d82#.ftefj7nn2" target="_blank" rel="external">setState() Gate</a><br>如果你对setState方法的异步性还有困惑，可以同我讨论，这里不再展开。</p>
<h3 id="合理利用解构Destructuring-Props"><a href="#合理利用解构Destructuring-Props" class="headerlink" title="合理利用解构Destructuring Props"></a>合理利用解构Destructuring Props</h3><p>这个其实没有太多可说的，仔细观察代码吧。我们使用了解构赋值。除此之外，如果一个组件有很多的props的话，每个props应该都另起一行，这样子书写上和阅读性上都有更好的体验。</p>
<pre><code>export default class ProfileContainer extends Component {
    state = { expanded: false }

    handleSubmit = (e) =&gt; {
    e.preventDefault()
    this.props.model.save()
    }

    handleNameChange = (e) =&gt; {
        this.props.model.changeName(e.target.value)
    }

    handleExpand = (e) =&gt; {
        e.preventDefault()
        this.setState(prevState =&gt; ({ expanded: !prevState.expanded }))
    }

    render() {
        const {model, title} = this.props

        return ( 
            &lt;ExpandableForm 
            onSubmit={this.handleSubmit} 
            expanded={this.state.expanded} 
            onExpand={this.handleExpand}&gt;
                &lt;div&gt;
                    &lt;h1&gt;{title}&lt;/h1&gt;
                    &lt;input
                    type=&quot;text&quot;
                    value={model.name}
                    onChange={this.handleNameChange}
                    placeholder=&quot;Your Name&quot;/&gt;
                &lt;/div&gt;
            &lt;/ExpandableForm&gt;
        )
    }
}
</code></pre><h3 id="使用修饰器Decorators"><a href="#使用修饰器Decorators" class="headerlink" title="使用修饰器Decorators"></a>使用修饰器Decorators</h3><p>这一条是对使用mobx的开发者来说的。如果你不懂mobx，可以大体扫一眼（作为翻译者，其实我也不是用mobx的）。<br>我们强调使用decorate来修饰我们的组件，如同：</p>
<pre><code>@observer
export default class ProfileContainer extends Component {
</code></pre><p>使用修饰器更加灵活且可读性更高的实践。即便你不使用修饰器，也需要如此暴露你的组件：</p>
<pre><code>class ProfileContainer extends Component {
    // Component code
}
export default observer(ProfileContainer)
</code></pre><h3 id="闭包Closures"><a href="#闭包Closures" class="headerlink" title="闭包Closures"></a>闭包Closures</h3><p>一定要尽量避免以下用法：</p>
<pre><code>&lt;input
    type=&quot;text&quot;
    value={model.name}
    // onChange={(e) =&gt; { model.name = e.target.value }}
    // ^ Not this. Use the below:
    onChange={this.handleChange}
    placeholder=&quot;Your Name&quot;/&gt;
</code></pre><p>总结一下，就是不要</p>
<pre><code>onChange = {(e) =&gt; { model.name = e.target.value }}
</code></pre><p>而是：</p>
<pre><code>onChange = {this.handleChange}
</code></pre><p>原因其实很简单，每次父组件render的时候，都会新建一个新的函数并传递给input。<br>如果input是一个React组件，这会粗暴地直接导致这个组件的re-render，需要知道，Reconciliation可是React成本最高的部分。<br>另外，我们推荐的方法，会使得阅读、调试和更改更加方便。</p>
<h2 id="函数式组件Functional-Components"><a href="#函数式组件Functional-Components" class="headerlink" title="函数式组件Functional Components"></a>函数式组件Functional Components</h2><p>以上内容是针对Class Components来讲的，下面我们看一下Functional Components的最佳实践。<br>Functional Components是指没有状态、没有方法，纯组件。我们应该最大限度地编写和使用这一类组件。</p>
<h3 id="使用propTypes"><a href="#使用propTypes" class="headerlink" title="使用propTypes"></a>使用propTypes</h3><p>在组件声明之前，我们需要使用propTypes，以达到更好的代码组织效果。<br>当然，依赖JavaScript的函数提升function hoisting，这么做不会报错。</p>
<pre><code>ExpandableForm.propTypes = {
    onSubmit: React.PropTypes.func.isRequired,
    expanded: React.PropTypes.bool
}
// Component declaration
</code></pre><h3 id="解构Destructuring-Props-and-defaultProps"><a href="#解构Destructuring-Props-and-defaultProps" class="headerlink" title="解构Destructuring Props and defaultProps"></a>解构Destructuring Props and defaultProps</h3><p>我们先来看一下反例：</p>
<pre><code>ExpandableForm.propTypes = {
    onSubmit: React.PropTypes.func.isRequired,
    expanded: React.PropTypes.bool,
    onExpand: React.PropTypes.func.isRequired
}
function ExpandableForm(props) {
    const formStyle = props.expanded ? {height: &apos;auto&apos;} : {height: 0}
    return (
        &lt;form style={formStyle} onSubmit={props.onSubmit}&gt;
            {props.children}
            &lt;button onClick={props.onExpand}&gt;Expand&lt;/button&gt;
        &lt;/form&gt;
    )
}
</code></pre><p>Our component is a function, which takes its props as its argument. We can expand them like so:<br>组件其实是一个function，他的参数为props，在充分利用解构的情况下，我们可以这样重构：</p>
<pre><code>function ExpandableForm({ onExpand, expanded = false, children, onSubmit }) {
    const formStyle = expanded ? {height: &apos;auto&apos;} : {height: 0}
    return (
        &lt;form style={formStyle} onSubmit={onSubmit}&gt;
            {children}
        &lt;button onClick={onExpand}&gt;Expand&lt;/button&gt;
        &lt;/form&gt;
    )
}
</code></pre><p>上面代码，我们也给expanded参数设置了默认值。</p>
<h3 id="封装Wrapping"><a href="#封装Wrapping" class="headerlink" title="封装Wrapping"></a>封装Wrapping</h3><p>对于functional components，无法使用修饰符。这种情况下，只需要简单地将函数作为参数传递就可以了：</p>
<pre><code>function ExpandableForm({ onExpand, expanded = false, children, onSubmit }) {
    const formStyle = expanded ? {height: &apos;auto&apos;} : {height: 0}
    return (
        &lt;form style={formStyle} onSubmit={onSubmit}&gt;
            {children}
            &lt;button onClick={onExpand}&gt;Expand&lt;/button&gt;
        &lt;/form&gt;
    )
}
</code></pre><h2 id="JSX中的条件判别Conditionals-in-JSX"><a href="#JSX中的条件判别Conditionals-in-JSX" class="headerlink" title="JSX中的条件判别Conditionals in JSX"></a>JSX中的条件判别Conditionals in JSX</h2><p>真正写过React项目的同学一定会明白，JSX中可能会存在大量的条件判别，以达到根据不同的情况渲染不同组件形态的效果。<br>就像下图这样：</p>
<pre><code>图片
</code></pre><p>然后，这样的结果是不理想的。我们丢失了代码的可读性，也使得代码组织显得混乱异常。多层次的嵌套也是应该避免的。</p>
<p>针对于此，有很对类库来解决此类问题JSX-Control Statements，但是与其引入第三方类库的依赖，还不如我们先自己尝试探索解决问题。<br>是不是有点怀念if…else？<br>我们可以使用大括号内包含立即执行函数IIFE，来达到使用if…else的目的：</p>
<pre><code>图片
</code></pre><p>当然，大量使用立即执行函数会造成性能上的损失。所以，考虑代码可读性上的权衡，还是有必要好好斟酌的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原文的总结部分其实没什么营养。我决定选取原文下的一些有道理的评论奉献给大家吧。<br>相信下面的很多评论也能让你收获不少：</p>
<blockquote>
<p>Instead of styled-components, I think css-modules is the best way to write a react component style. It totally avoid css pollution on pages. Besides, some react ui libraries have already used it in production: react-toolbox and light-ui.</p>
<p>For conditionals in JSX you could use a “do expression”. It is a new proposal in ES7 and babel can transform it.</p>
<p>have you checked out cxs for your css in js concerns? it’s fantastic.</p>
<p>what do you feel about the approach of moving all that logic from the IIFE to a helper method? Something like {this.renderFooter()} and then putting all that logic in there as regular javascript?</p>
<p>Our approach is a bit different from others in that we use MobX for state management, which encourages direct modification of data, as opposed to something like Redux where you would dispatch an action there.<br>However, I’ve realized that since MobX is still an alternative choice and so direct modification of props isn’t really a best practice for React in general, so I’m going to revise the article to phase that out.</p>
</blockquote>
<p>PS: 作者<a href="https://github.com/HOUCe" target="_blank" rel="external">Github仓库</a>，欢迎通过代码各种形式交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在前端程序员都知道，React是组件化的。当我开始学习React的时候，我记得当时已经存在了很多不同编写组件的方式了。这个教程，那个教程，也许组件的组织方式不尽相同。如今，React社区已经愈发成熟，但是对于组件正确编写姿势却没有一个相对完备的指导。&lt;br&gt;这篇文章从作者
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>React大会上我们能学到什么？React + ES next = ♥</title>
    <link href="https://exp-team.github.io/blog/2017/04/14/js/react-conf-es6/"/>
    <id>https://exp-team.github.io/blog/2017/04/14/js/react-conf-es6/</id>
    <published>2017-04-13T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>React Conf 2017在加利福尼亚州的圣克拉拉万豪酒店圆满落幕，这已经是Facebook举办的第三届React官方大会了。<br>虽然不能参会，但是作为前端开发者，我们当然不能错过这个绝佳的学习契机。</p>
<p>笔者利用清明假期，参看了YouTube上关于这次大会的记录。一共34个精彩演讲，对应34个视频。获益匪浅。</p>
<p>这里，将会作为一个系列，对其中的几篇演讲进行翻译和分析。并辅助以code demo，帮助大家理解。<br>欢迎关注我的<a href="http://www.jianshu.com/u/452568260db5" target="_blank" rel="external">简书</a>或<a href="https://juejin.im/user/58305395a22b9d006b83d214" target="_blank" rel="external">掘金</a>账号，也欢迎在Github上floow，相信你一定也会有所收获。</p>
<p>今天为大家介绍的是Ben Ilegbodu的主题：React + ES next = ♥ </p>
<p>Ben Ilegbodu是“为数不多的”参会有色程序员，黑人程序员如同女性程序员一样凤毛麟角，同样，本次分享主题也很有爱，很有营养。如果你不了解React也不要紧，因为这次讲的是ES6、ES7在React中的应用。所以，其实是对下一代ES的普及和介绍。</p>
<p>本文将以Destructuring、Spread Opetator、Arrow Function、Promises、Async Functions展开。并通过nodeJS实现一个兼具前端和后端的小型“评论／留言发布阅读系统”。</p>
<h2 id="实现预览"><a href="#实现预览" class="headerlink" title="实现预览"></a>实现预览</h2><p>如图，我们实现了如下的页面。当然，样式是极其简陋的。作为“粗糙”的程序员，实在懒得在页面上花时间。<br>我们可以在输入框内输入姓名和留言内容。并点击按钮提交。后台使用nodeJS express框架，实现对文件的读写更新。</p>
<pre><code>app.post(&apos;/api/comments&apos;, function(req, res) {
    fs.readFile(COMMENTS_FILE, function(err, data) {
        if (err) {
            console.error(err);
            process.exit(1);
        }
        var comments = JSON.parse(data);
        var newComment = {
            id: Date.now(),
            author: req.body.author,
            text: req.body.text,
        };
        comments.push(newComment);
        fs.writeFile(COMMENTS_FILE, JSON.stringify(comments, null, 4), function(err) {
            if (err) {
                console.error(err);
                process.exit(1);
            }
            res.json(comments);
        });
    });
});
</code></pre><p>这是nodeJS的后端代码，是为了介绍实现的这个project前后端协作。<br>接下来我们继续回到演讲。</p>
<h2 id="解构Destructuring"><a href="#解构Destructuring" class="headerlink" title="解构Destructuring"></a>解构Destructuring</h2><p>在我们的项目中，最初版存在这样的一段代码：</p>
<pre><code>_handleCommentSubmit(comment) {
    let comments = this.state.comments;
    ...
    // remaining code
}
</code></pre><p>请务必记住这个_handleCommentSubmit函数，接下来的全文都是围绕他展开，并进行一步步拓展。<br>这个函数的逻辑是对新提交的comment进行处理，首先他需要从state中读取现有的comments数组。<br>在使用解构赋值的情况下，我们重构为：</p>
<pre><code>_handleCommentSubmit(comment) {
    let {comments} = this.state;
    ...
    // remaining code
}
</code></pre><p>也许这还看不出来解构到底有什么作用，但是在逻辑多的时候，他是很有必要的。比如：</p>
<pre><code>let author = this.state.author;
let text = this.state.text;
</code></pre><p>就可以写为：</p>
<pre><code>let {author, text} = this.state;
</code></pre><p>如果需要改变变量名时，就可以从：</p>
<pre><code>let authorName = this.state.author;
let fullText = this.state.text;
</code></pre><p>改为：</p>
<pre><code>let {author: authorName, text: fullText} = this.state;
</code></pre><p>再举一个例子，在function component情况下：</p>
<pre><code>function MyComponent(props) {
    return (
        &lt;div style={props.style}&gt;{props.children}&lt;/div&gt;
    )
}
&lt;MyComponent style=&quot;dark&quot;&gt;Stateless function!&lt;/MyComponent&gt;
</code></pre><p>我们可以改写为：</p>
<pre><code>function MyComponent({children, style}) {
    return (
        &lt;div style={style}&gt;{children}&lt;/div&gt;
    )
}
&lt;MyComponent style=&quot;dark&quot;&gt;Stateless function!&lt;/MyComponent&gt;
</code></pre><h2 id="展开符Spread-Opetator"><a href="#展开符Spread-Opetator" class="headerlink" title="展开符Spread Opetator"></a>展开符Spread Opetator</h2><p>还记得上面那个_handleCommentSubmit函数吗？接下来我们要进行扩充。首先我们将新提交的comment（即函数参数），添加一个时间戳作为id。接下来，<br>我们拿到旧的state.comments之后，就要将新的comment（包含id）加入到state.comments当中。</p>
<p>初版做法是：</p>
<pre><code>_handleCommentSubmit(comment) {
    let {comments} = this.state;
    let newComment = comment;

    newComment.id = Date.now();

    let newComments = comments.concat([newComment]);

    ...
    // setState + ajax stuffs
}
</code></pre><p>在使用展开符后，我们可以重构为：</p>
<pre><code>_handleCommentSubmit(comment) {
    let {comments} = this.state;
    let newComment = {...comment, id: Date.now()};
    let newComments = [...comments, newComment];
    ...
    // setState + ajax stuffs
}
</code></pre><p>当然，展开符还有很多其他benefits，比如，平时我们可以使用Math.max方法对数组求出最大值：</p>
<pre><code>var arrayOfValue = [33, 2, 9];
var maxValueFromArray = Math.max.apply(null, arrayOfValue)
</code></pre><p>这个思路利用了apply接受一个数组作为函数参数的特性。<br>使用展开符，我们就可以：</p>
<pre><code>var arrayOfValue = [33, 2, 9];
var maxValueFromArray = Math.max(...arrayOfValue);
</code></pre><p>同理，我们可以这样扩充一个数组：</p>
<pre><code>let values = [2, 3, 4];
let verbose = [1, ...values, 5];
</code></pre><p>当然，以上都是对数组的展开。对对象属性的展开符的使用，也已经到了Stage3阶段。今后，我们可以这样写代码：</p>
<pre><code>let warriors = {Steph: 95, Klay: 82, Draymond: 79};
let newWarriors = {
    ...warriors,
    Kevin: 97
}
</code></pre><p>而不必再使用Object.assign进行对象的扩展。</p>
<h2 id="箭头函数Arrow-Function"><a href="#箭头函数Arrow-Function" class="headerlink" title="箭头函数Arrow Function"></a>箭头函数Arrow Function</h2><p>箭头函数带来的好处无疑是对this的绑定。<br>现在再回到我们的_handleCommentSubmit函数，做完了初始化工作，我们需要将新的comment通过ajax，异步发送给后端。在成功的回调函数中，进行setState处理：</p>
<pre><code>$.ajax({
    url: this.props.url,
    data: comment,
    success: function(resJson) {
        this.setState({comments: resJson})
    }.bind(this)
})
</code></pre><p>有经验的同学注意到了我使用bind更改this指向的处理。在ES6箭头函数下，我们可以直接：</p>
<pre><code>$.ajax({
    url: this.props.url,
    data: comment,
    success: (resJson) =&gt; {
        this.setState({comments: resJson})
    }
})
</code></pre><p>我们再展开看看箭头函数的几种用法：<br>1）匿名函数，单参数情况，比如实现一个数组的各项平方：</p>
<pre><code>let squares = [1, 2, 3].map(value =&gt; value * value);
</code></pre><p>2) 匿名函数，多参数情况，比如实现一个数组的各项累加：</p>
<pre><code>let sum = [9, 8, 7].reduce((prev, value) =&gt; prev + value, 0)
</code></pre><p>这时候，需要把参数放在括号之中。</p>
<p>3) 非匿名函数，无返回值情况：</p>
<pre><code>const alertUser = (message) =&gt; {
    alert(message)
}
</code></pre><p>这时候，函数体用花括号围起来。</p>
<p>4）更复杂的情况，比如上面我们用到过的：</p>
<pre><code>const MyComponent = ({children, style}) =&gt; (
    &lt;div style={style}&gt;{children}&lt;/div&gt;
)
</code></pre><h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>上面的代码我们使用了jquery的ajax方法发送异步请求，这可能在某些情况下出现“回调地狱”的情况。为此，我们使用基于Promise的fetch方法，进行重构：</p>
<pre><code>_handleCommentSubmit(comment) {
    // ...
    fetch(this.props.url, {
        method: &apos;POST&apos;,
        body: Json.stringify(comment)
    })
        .then((res)=&gt;res.json())
        .then((resJson)=&gt;{
            this.setState({comments: resJson})
        })
        .catch((ex)=&gt;{
            console.error(this.props.url, ex)
        })
}
</code></pre><p>当然，我们可以把上述代码做的更抽象：</p>
<pre><code>const fetchJson = (path, options) =&gt; {
    fetch(`${DOMAIN}${path}`, options)
        .then((res)=&gt;res.json())
}
</code></pre><p>我们在拉取评论时，就可以：</p>
<pre><code>const fetchComments = () =&gt; fetchJson(&apos;api/comments&apos;)
</code></pre><p>基于promises的fetch，让异步请求变的灵活可靠。</p>
<p>同时，我再安利一个基于promises的sleep函数：</p>
<pre><code>const sleep = (delay = 0) =&gt; {
    new Promise((resolve)=&gt;{
        setTimeout(resolve, delay)
    })
}

sleep(3000)
    .then(()=&gt;getUniqueCommentAuthors())
    .then((uniqueAuthors)=&gt;{this.state({uniqueAuthors})})
</code></pre><p>回到我们的Project中，在后端nodeJS实现里，我们把所有的评论存在data/comments.json文件当中。<br>在渲染视图时，就不可避免地要进行对data/comments.json文件读取，这个过程也应该是异步完成的：</p>
<pre><code>const readFile = (filePath) =&gt; (
    new Promise((resolve, reject)=&gt;{
        fs.readFile(filePath, (err, data)=&gt;{
            if (err) {reject(err)}
            resolve(data)
        })
    })
)

readFile(&apos;data/comments.json&apos;)
    .then((data)=&gt;console.log(&apos;Here is the data&apos;, data))
    .catch((ex)=&gt;console.log(&apos;Arg!&apos;, ex))
</code></pre><h2 id="Async-Functions"><a href="#Async-Functions" class="headerlink" title="Async Functions"></a>Async Functions</h2><p>当然，Promises实现也有缺点。关于Promises和Async的对比，具体可以看我的一篇文章：<a href=""></a></p>
<p>更先进的方式，就是使用Async，回到我们的_handleCommentSubmit方法，我们可以重构为：</p>
<pre><code>async _handleCommentSubmit(comment) {
    try {
        let res = await fetch(this.props.url, {
            method: &apos;POST&apos;,
            body: JSON.stringify(comment)
        });
        newComments = await res.json();
    }
    catch (ex) {
        console.error(this.props.url, ex);
        newComments = comments;
    }

    this.setState({comments: newComments});
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇演讲生动形象地阐释了React是怎样与ES next融合天衣无缝的。不论是React也好，还是ES也好，其实笔者认为说到底，都是为了更大限度地解放生产力。</p>
<p>欢迎读者与我交流，有任何问题可以留言。今后几天，将有更多新鲜的react conf视频翻译奉献给大家。</p>
<p>PS: 作者<a href="https://github.com/HOUCe" target="_blank" rel="external">Github仓库</a>，欢迎通过代码各种形式交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React Conf 2017在加利福尼亚州的圣克拉拉万豪酒店圆满落幕，这已经是Facebook举办的第三届React官方大会了。&lt;br&gt;虽然不能参会，但是作为前端开发者，我们当然不能错过这个绝佳的学习契机。&lt;/p&gt;
&lt;p&gt;笔者利用清明假期，参看了YouTube上关于这次大
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>nodeJS实现基于Promise的爬虫 定时发送简书作者信息到指定邮件</title>
    <link href="https://exp-team.github.io/blog/2017/04/10/js/node_crawler/"/>
    <id>https://exp-team.github.io/blog/2017/04/10/js/node_crawler/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>英国人Robert Pitt曾在<a href="https://github.com/robertpitt/plus-scraper" target="_blank" rel="external">Github</a>上公布了他的爬虫脚本，导致任何人都可以容易地取得Google Plus的大量公开用户的ID信息。至今大概有2亿2千5百万用户ID遭曝光。</p>
<p>亮点在于，这是个nodejs脚本，非常短，包括注释只有71行。</p>
<p>毫无疑问，nodeJS改变了整个前端开发生态。本文一步步完成了一个基于promise的nodeJS爬虫程序，收集<a href="http://www.jianshu.com/" target="_blank" rel="external">简书</a>任意指定作者的文章信息。并最终把爬下来结果以邮件的形式，自动化发给目标对象。千万不要被nodeJS的外表吓到，既是你是初入前端的小菜鸟，或是刚接触nodeJS不久的新同学，都不妨碍对这篇文章的阅读和理解。</p>
<h2 id="nodeJS-VS-Python实现爬虫"><a href="#nodeJS-VS-Python实现爬虫" class="headerlink" title="nodeJS VS Python实现爬虫"></a>nodeJS VS Python实现爬虫</h2><p>我们先从爬虫说起。对比一下，讨论为什么nodeJS适合／不适合作为爬虫编写语言。<br>首先，总结一下：</p>
<blockquote>
<p>NodeJS单线程、事件驱动的特性可以在单台机器上实现极大的吞吐量，非常适合写网络爬虫这种资源密集型的程序。</p>
</blockquote>
<p>但是，对于一些复杂场景，需要更加全面的考虑。以下内容总结自<a href="https://www.zhihu.com/question/56666548" target="_blank" rel="external">知乎相关问题</a>，感谢<a href="https://www.zhihu.com/people/chuanliang/answers" target="_blank" rel="external">@梁川</a>，对答案的贡献。</p>
<ul>
<li><p>如果是定向爬取几个页面，做一些简单的页面解析，爬取效率不是核心要求，那么用什么语言差异不大。   </p>
</li>
<li><p>如果是定向爬取，且主要目标是解析js动态生成的内容 :<br>此时，页面内容是由js/ajax动态生成的，用普通的请求页面＋解析的方法就不管用了，需要借助一个类似firefox、chrome浏览器的js引擎来对页面的js代码做动态解析。</p>
</li>
<li><p>如果爬虫是涉及大规模网站爬取，效率、扩展性、可维护性等是必须考虑的因素时候:<br>大规模爬虫爬取涉及诸多问题：多线程并发、I/O机制、分布式爬取、消息通讯、判重机制、任务调度等等，此时候语言和所用框架的选取就具有极大意义了。具体来看：<br>PHP：对多线程、异步支持较差，不建议采用。<br>NodeJS：对一些垂直网站爬取倒可以。但由于分布式爬取、消息通讯等支持较弱，根据自己情况判断。<br>Python：建议，对以上问题都有较好支持。</p>
</li>
</ul>
<p>当然，我们今天所实现的是一个简易爬虫，不会对目标网站带来任何压力，也不会对个人隐私造成不好影响。毕竟，他的目的只是熟悉nodeJS环境。适用于新人入门和练手。</p>
<p>当然，任何恶意的爬虫性质是恶劣的，我们应当全力避免影响，共同维护网络环境的健康。</p>
<h2 id="爬虫实例"><a href="#爬虫实例" class="headerlink" title="爬虫实例"></a>爬虫实例</h2><p>今天要编写的爬虫目的是爬取<a href="http://www.jianshu.com/u/452568260db5" target="_blank" rel="external">简书作者：LucasHC（我本人）</a>在简书平台上，发布过的所有文章信息，包括：每篇文章的发布日期、文章字数、评论数、浏览数、赞赏数等等。</p>
<p>最终爬取结果的输出如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-c19cbb8aa9b79d04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爬取输出"></p>
<p>以下结果，我们需要通过脚本，自动地发送邮件到指定邮箱。收件内容如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-1b0bde5ca54b3c73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="邮件内容"></p>
<p>以上操作只需要一键操作便可完成。</p>
<h2 id="爬虫设计"><a href="#爬虫设计" class="headerlink" title="爬虫设计"></a>爬虫设计</h2><p>我们的程序一共依赖三个模块／类库：</p>
<pre><code>const http = require(&quot;http&quot;);
const Promise = require(&quot;promise&quot;);
const cheerio = require(&quot;cheerio&quot;);
</code></pre><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>http是nodeJS的原生模块，自身就可以用来构建服务器，而且http模块是由C++实现的，性能可靠。<br>我们使用Get，来请求简书作者相关文章的对应页面：</p>
<pre><code>http.get(url, function(res) {
    var html = &quot;&quot;;
    res.on(&quot;data&quot;, function(data) {
        html += data;
    });

    res.on(&quot;end&quot;, function() {
        ...
    });
}).on(&quot;error&quot;, function(e) {
    reject(e);
    console.log(&quot;获取信息出错!&quot;);
});
</code></pre><p>因为我发现，简书中每一篇文章的链接形式如下：<br>完整形式：“<a href="http://www.jianshu.com/p/ab2741f78858”，" target="_blank" rel="external">http://www.jianshu.com/p/ab2741f78858”，</a><br>即 “<a href="http://www.jianshu.com/p/”" target="_blank" rel="external">http://www.jianshu.com/p/”</a> ＋ “文章id”。</p>
<p>所以，上述代码中相关作者的每篇文章url：由baseUrl和相关文章id拼接组成：</p>
<pre><code>articleIds.forEach(function(item) {
    url = baseUrl + item;
});
</code></pre><p>articleIds自然是存储作者每篇文章id的数组。</p>
<p>最终，我们把每篇文章的html内容存储在html这个变量中。</p>
<h3 id="异步promise封装"><a href="#异步promise封装" class="headerlink" title="异步promise封装"></a>异步promise封装</h3><p>由于作者可能存在多篇文章，所以对于每篇文章的获取和解析我们应该异步进行。这里我使用了promise封装上述代码：</p>
<pre><code>function getPageAsync (url) {
    return new Promise(function(resolve, reject){
        http.get(url, function(res) {
            ...
        }).on(&quot;error&quot;, function(e) {
            reject(e);
            console.log(&quot;获取信息出错!&quot;);
        });
    });
};
</code></pre><p>这样一来，比如我写过14篇原创文章。这样对每一片文章的请求和处理全都是一个promise对象。我们存储在预先定义好的数组当中：</p>
<pre><code>const articlePromiseArray = [];
</code></pre><p>接下来，我使用了Promise.all方法进行处理。</p>
<p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。<br>该方法接受一个promise实例数组作为参数，实例数组中所有实例的状态都变成Resolved，Promise.all返回的实例才会变成Resolved，并将Promise实例数组的所有返回值组成一个数组，传递给回调函数。</p>
<p>也就是说，我的14篇文章的请求对应14个promise实例，这些实例都请求完毕后，执行以下逻辑：</p>
<pre><code>Promise.all(articlePromiseArray).then(function onFulfilled (pages) {
    pages.forEach(function(html) {
        let info = filterArticles(html);
        printInfo(info);        
    });
}, function onRejected (e) {
    console.log(e);
});
</code></pre><p>他的目的在于：对每一个返回值（这个返回值为单篇文章的html内容），进行filterArticles方法处理。处理所得结果进行printInfo方法输出。<br>接下来，我们看看filterArticles方法做了什么。</p>
<h3 id="html解析"><a href="#html解析" class="headerlink" title="html解析"></a>html解析</h3><p>其实很明显，如果您理解了上文的话。filterArticles方法就是对单篇文章的html内容进行有价值的信息提取。这里有价值的信息包括：<br>1）文章标题；<br>2）文章发表时间；<br>3）文章字数；<br>4）文章浏览量；<br>5）文章评论数；<br>6）文章赞赏数。</p>
<pre><code>function filterArticles (html) {
    let $ = cheerio.load(html);
    let title = $(&quot;.article .title&quot;).text();
    let publishTime = $(&apos;.publish-time&apos;).text();
    let textNum = $(&apos;.wordage&apos;).text().split(&apos; &apos;)[1];
    let views = $(&apos;.views-count&apos;).text().split(&apos;阅读&apos;)[1];
    let commentsNum = $(&apos;.comments-count&apos;).text();
    let likeNum = $(&apos;.likes-count&apos;).text();

    let articleData = {
        title: title,
        publishTime: publishTime,
        textNum: textNum
        views: views,
        commentsNum: commentsNum,
        likeNum: likeNum
    }; 

    return articleData;
};
</code></pre><p>你也许会奇怪，为什么我能使用类似jQuery中的$对html信息进行操作。其实这归功于<a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">cheerio类库。</a></p>
<p>filterArticles方法返回了每篇文章我们感兴趣的内容。这些内容存储在articleData对象当中，最终由printInfo进行输出。</p>
<h2 id="邮件自动发送"><a href="#邮件自动发送" class="headerlink" title="邮件自动发送"></a>邮件自动发送</h2><p>到此，爬虫的设计与实现到了一段落。接下来，就是把我们爬取的内容以邮件方式进行发送。<br>这里我使用了<a href="https://github.com/nodemailer/nodemailer" target="_blank" rel="external">nodemailer</a>模块进行发送邮件。相关逻辑放在Promise.all当中：</p>
<pre><code>Promise.all(articlePromiseArray).then(function onFulfilled (pages) {
    let mailContent = &apos;&apos;;
    var transporter = nodemailer.createTransport({
        host : &apos;smtp.sina.com&apos;,
        secureConnection: true, // 使用SSL方式（安全方式，防止被窃取信息）
        auth : {
            user : &apos;**@sina.com&apos;,
            pass : ***
        },
    });
    var mailOptions = {
        // ...
    };
    transporter.sendMail(mailOptions, function(error, info){
        if (error) {
            console.log(error);
        }
        else {
            console.log(&apos;Message sent: &apos; + info.response);
        }
    });
}, function onRejected (e) {
    console.log(e);
});
</code></pre><p>邮件服务的相关配置内容我已经进行了适当隐藏。读者可以自行配置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文，我们一步一步实现了一个爬虫程序。涉及到的知识点主要有：nodeJS基本模块用法、promise概念等。如果拓展下去，我们还可以做nodeJS连接数据库，把爬取内容存在数据库当中。当然也可以使用<a href="https://www.npmjs.com/package/node-schedule" target="_blank" rel="external">node-schedule</a>进行定时脚本控制。</p>
<p>这些东西还只是nodeJS的冰山一角，希望大家一起探索。如果你对完整代码感兴趣，请点击<a href="https://github.com/HOUCe/node-crawler-jianshu" target="_blank" rel="external">这里。</a></p>
<p>Happy Coding!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英国人Robert Pitt曾在&lt;a href=&quot;https://github.com/robertpitt/plus-scraper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github&lt;/a&gt;上公布了他的爬虫脚本，导致任何人都可以容易地取得Goo
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第11011期</title>
    <link href="https://exp-team.github.io/blog/2017/04/08/weekly/weekly-11011/"/>
    <id>https://exp-team.github.io/blog/2017/04/08/weekly/weekly-11011/</id>
    <published>2017-04-07T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>4.3-4.8，每月读一本书，一年就有12本</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="Stack-Overflow-推荐编程书单"><a href="#Stack-Overflow-推荐编程书单" class="headerlink" title="Stack Overflow 推荐编程书单"></a><a href="https://zhuanlan.zhihu.com/p/26081885" target="_blank" rel="external">Stack Overflow 推荐编程书单</a></h3><h3 id="Mobi-css-2-发布-beta-版，一个轻量、可拓展、移动端优先的-css-框架"><a href="#Mobi-css-2-发布-beta-版，一个轻量、可拓展、移动端优先的-css-框架" class="headerlink" title="Mobi.css 2 发布 beta 版，一个轻量、可拓展、移动端优先的 css 框架"></a><a href="https://www.v2ex.com/t/352809" target="_blank" rel="external">Mobi.css 2 发布 beta 版，一个轻量、可拓展、移动端优先的 css 框架</a></h3><h3 id="Angular4-0-0正式发布，附新特性及升级指南"><a href="#Angular4-0-0正式发布，附新特性及升级指南" class="headerlink" title="Angular4.0.0正式发布，附新特性及升级指南"></a><a href="https://zhuanlan.zhihu.com/p/26001925" target="_blank" rel="external">Angular4.0.0正式发布，附新特性及升级指南</a></h3><a id="more"></a>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="IMVC（同构-MVC）的前端实践"><a href="#IMVC（同构-MVC）的前端实践" class="headerlink" title="IMVC（同构 MVC）的前端实践"></a><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485119&amp;idx=1&amp;sn=5cd3855a84cd0a7bfd5b7c69ac853258&amp;chksm=9723647da054ed6b9429d6360338ea95df11d64206a2937312f9dbe0a6db656888e1030bdb4e&amp;mpshare=1&amp;scene=1&amp;srcid=0402DsLjlUbhVfaqwg0kTcPm#rd" target="_blank" rel="external">IMVC（同构 MVC）的前端实践</a></h3><h3 id="10道典型的JavaScript面试题"><a href="#10道典型的JavaScript面试题" class="headerlink" title="10道典型的JavaScript面试题"></a><a href="https://zhuanlan.zhihu.com/p/26068507" target="_blank" rel="external">10道典型的JavaScript面试题</a></h3><h3 id="从一道坑人的面试题说函数式编程"><a href="#从一道坑人的面试题说函数式编程" class="headerlink" title="从一道坑人的面试题说函数式编程"></a><a href="https://www.h5jun.com/post/parseInt-to-functional.html" target="_blank" rel="external">从一道坑人的面试题说函数式编程</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="为什么我不赞成在代码中写注释：谈写注释的几种境界"><a href="#为什么我不赞成在代码中写注释：谈写注释的几种境界" class="headerlink" title="为什么我不赞成在代码中写注释：谈写注释的几种境界"></a><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=2653548512&amp;idx=1&amp;sn=801eed1269697852cb01971d660abd3f&amp;chksm=813a7e78b64df76e15eb3e871411813ebc9fcf2ac637a779e18b7ee7c41f2faa7a4124679e7e&amp;mpshare=1&amp;scene=1&amp;srcid=04076RjvNcwG0o0NDCZLH1d6" target="_blank" rel="external">为什么我不赞成在代码中写注释：谈写注释的几种境界</a></h3><h3 id="悄悄发布一个hexo的npm模块"><a href="#悄悄发布一个hexo的npm模块" class="headerlink" title="悄悄发布一个hexo的npm模块"></a><a href="http://www.wuyuying.com/archives/npm-publish/" target="_blank" rel="external">悄悄发布一个hexo的npm模块</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;4.3-4.8，每月读一本书，一年就有12本&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;Stack-Overflow-推荐编程书单&quot;&gt;&lt;a href=&quot;#Stack-Overflow-推荐编程书单&quot; class=&quot;headerlink&quot; title=&quot;Stack Overflow 推荐编程书单&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26081885&quot;&gt;Stack Overflow 推荐编程书单&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;Mobi-css-2-发布-beta-版，一个轻量、可拓展、移动端优先的-css-框架&quot;&gt;&lt;a href=&quot;#Mobi-css-2-发布-beta-版，一个轻量、可拓展、移动端优先的-css-框架&quot; class=&quot;headerlink&quot; title=&quot;Mobi.css 2 发布 beta 版，一个轻量、可拓展、移动端优先的 css 框架&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.v2ex.com/t/352809&quot;&gt;Mobi.css 2 发布 beta 版，一个轻量、可拓展、移动端优先的 css 框架&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;Angular4-0-0正式发布，附新特性及升级指南&quot;&gt;&lt;a href=&quot;#Angular4-0-0正式发布，附新特性及升级指南&quot; class=&quot;headerlink&quot; title=&quot;Angular4.0.0正式发布，附新特性及升级指南&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26001925&quot;&gt;Angular4.0.0正式发布，附新特性及升级指南&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>一个有趣的react demo 教你如何处理树形结构</title>
    <link href="https://exp-team.github.io/blog/2017/04/05/js/react-tree-data/"/>
    <id>https://exp-team.github.io/blog/2017/04/05/js/react-tree-data/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍一个简单的react demo，并通过此实例，剖析react的经典用法。并演示如何使用react思想，处理复杂的数据结构。</p>
<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>这个项目通过树形可操纵列表，展示了美国典型的“三权分立”政治体制，截图如下：</p>
<p>如果实现这样一个view，其实并不难。我们使用原生的javascript或者jquery都能简单的实现。关键在于，这里的树形可操纵列表是可以实现定制化的。比如，今天我们剖析了“三权分立”政治体制，明天我们想实现一个公司管理层级结构，后天我们想表述一个文件系统的嵌套关系。通过这个项目，我们只需要更改数据表（配置表），便可以一键生成我们想要的结果。</p>
<h2 id="数据设计"><a href="#数据设计" class="headerlink" title="数据设计"></a>数据设计</h2><p>关于配置表，我们使用一个js对象实现。比如，“三权分立”的tree如下：</p>
<p>var tree = {<br>    title: “American Government System”,<br>    childNodes: [<br>        {title: “Legislative”, childNodes: [<br>            {title: “Congress”, childNodes: [<br>                {title: “Agencies”}<br>            ]}<br>        ]},<br>        {title: “Executive”, childNodes: [<br>            {title: “President”, childNodes: [<br>                {title: “Cabinet”},<br>                {title: “Exec Office Of The President”},<br>                {title: “Vice-president”},<br>                {title: “Independent Agencies”, childNodes: [<br>                    {title: “Agriculture”},<br>                    {title: “Commerce”},<br>                    {title: “Defense”},<br>                    {title: “Education”},<br>                    {title: “……”}<br>                ]}<br>            ]}<br>        ]},<br>        {title: “Judicial”, childNodes: [<br>            {title: “Supreme Court”, childNodes: [<br>                {title: “Lower Courts”}<br>            ]}<br>        ]}<br>    ]<br>};</p>
<p>这样的一个数据结构中，title表示当前节点展示名称，与他同级的是一个childNodes数组。</p>
<p>这个数组的每一项又是一个类似“tree”结构的节点：这个节点包括了一个title表示当前节点展示名称，和一个childNodes数组。<br>如此递归，无穷匮也。。。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>设计思想上，其实上文已经说的很清楚了，就是递归。同时需要react作为视图层框架，对每一个Node节点配置以state。<br>好吧，我们来看一下代码：</p>
<pre><code>class Component1 extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            visible: true,
        };
    }
    toggle() {
        this.setState({visible: !this.state.visible});
    };

    render() {
        ....

        return (
            ....
        )
    }
}
</code></pre><p>上面是一个Node节点的组件设计情况。他通过props继承了父节点传递过来的tree属性，该属性值既为上文中的tree数据结构。<br>这个组件的状态只有一个：visible，该值为true，表示节点展开可见；否则不可见。对应的样式集合为：style = {display: “none”}。</p>
<p>同时，最重要的是需要判断此Node节点是否存在子节点，既node.childNodes是否为空：</p>
<pre><code>if (this.props.node.childNodes != null) {
    ....
}
</code></pre><p>我们首先分析此节点存在子节点的情况，既node.childNodes!= null时，</p>
<pre><code>childNodes = this.props.node.childNodes.map(function(node, index){
    return &lt;li key={index}&gt;&lt;Component1 node={node}/&gt;&lt;/li&gt;
})

let className1 = &apos;togglable&apos;;
let className2 = this.state.visible ? &apos;togglable-down&apos; : &apos;togglable-up&apos;;
var classNameFinal = className1 + &apos; &apos; + className2;
</code></pre><p>我们对node.childNodes的每一项子节点进行遍历，并返回childNodes变量。<br>同时根据组件的状态，选择合适的class进行拼接。togglable类名是必有的，同时<br>togglable-down/togglable-up根据状态，选择其一。</p>
<p>需要注意的是我们针对包含子节点的情况，进行了递归调用：<component1 node="{node}/">，能理解这一点至关重要。</component1></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章虽然简短，但是涉及到了react思想的核心部分：组件间的通信和组件状态的选择切换。同时还涉及到了一些基本的算法，比如递归调用组件和数据结构的设计。<br>可谓，麻雀虽小，五脏具全。</p>
<p>Happy Coding!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍一个简单的react demo，并通过此实例，剖析react的经典用法。并演示如何使用react思想，处理复杂的数据结构。&lt;/p&gt;
&lt;h2 id=&quot;项目简介&quot;&gt;&lt;a href=&quot;#项目简介&quot; class=&quot;headerlink&quot; title=&quot;项目简介&quot;&gt;&lt;/a&gt;项
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>万军丛中取敌将首级－如何优雅安全地在深层数据结构中取值</title>
    <link href="https://exp-team.github.io/blog/2017/04/04/js/access/"/>
    <id>https://exp-team.github.io/blog/2017/04/04/js/access/</id>
    <published>2017-04-03T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>古有赵子龙面对“冲锋之势，有进无退，陷阵之志，有死无生”的局面，能万军丛中取敌将首级。<br>在我们的Javascript中，往往用对象（Object）来存储一个数据结构。如果这个结构非常复杂，那么想要安全优雅地取出一个值，也并非简单。</p>
<p>这篇文章将会详细阐述在一个嵌套较深的场景中，如何安全的完成读写操作。先后会尝试多种方法，希望对读者有所启发。</p>
<p>本文示例借鉴A.Sharif的最新文章：<a href="https://medium.com/javascript-inside/safely-accessing-deeply-nested-values-in-javascript-99bf72a0855a" target="_blank" rel="external">Safely Accessing Deeply Nested Values In JavaScript</a>，喜欢看英文原版的同学可以直接戳链接。</p>
<h2 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h2><p>在React开发中，我们根据数据来渲染视图。经常会出现类似下面这种情况：</p>
<pre><code>const props = {
    user: {
        posts: [
            { title: &apos;Foo&apos;, comments: [ &apos;Good one!&apos;, &apos;Interesting...&apos; ] },
            { title: &apos;Bar&apos;, comments: [ &apos;Ok&apos; ] },
            { title: &apos;Baz&apos;, comments: []}
        ],
        comments: [...]
    }
}
</code></pre><p>这是一个典型的获取用户评论信息并加以展示的场景。其实，这还嵌套的不够深，试想一个回复存在多层：回复的回复，回复的回复的回复。。。</p>
<p>姑且先看我们的示例吧，此时我们想获取第一个post的评论信息。用传统的javascript方法应该这么做：</p>
<pre><code>props.user &amp;&amp;
props.user.posts &amp;&amp;
props.user.posts[0] &amp;&amp;
props.user.posts[0].comments
</code></pre><p>也许经验丰富的javascript开发者会明白使用这么多&amp;&amp;的意义。这是为了在对象中相关取值的过程，需要验证每一个key和index的存在性。否则会有报错，这将会是致命性的。并且props这个数据结构必然是动态生成的，存在有时valid有时invalid的情况。在测试过程中，很难复现。</p>
<p>同样的尴尬场景比比皆是，想象一下，如果我们需要获取一名用户最后一个评论博客的题目，就需要：</p>
<pre><code>props.user &amp;&amp;
props.user.comments &amp;&amp;
props.user.comments[0] &amp;&amp;
props.user.comments[0].blog.title
</code></pre><p>这些例子夸张吗？其实不然。我们明白了，想要获取一个数据值，需要一层一层遍历属性的存在性。这无疑是繁琐的。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>现在明白了我们面临的困扰，接下来我会用纯JavaScript方法，以及最具有函数式代表的JavaScript库－Ramda，辅以柯粒化（currying）等思想和方案解决问题。</p>
<h3 id="JavaScript方案"><a href="#JavaScript方案" class="headerlink" title="JavaScript方案"></a>JavaScript方案</h3><p>先直接上代码：</p>
<pre><code>const get = (p, o) =&gt; p.reduce((xs, x) =&gt; (xs &amp;&amp; xs[x]) ? xs[x] : null, o)

console.log(get([&apos;user&apos;, &apos;posts&apos;, 0, &apos;comments&apos;], props)) // [ &apos;Good one!&apos;, &apos;Interesting...&apos; ]
console.log(get([&apos;user&apos;, &apos;post&apos;, 0, &apos;comments&apos;], props)) // null
</code></pre><p>注意这里我使用了一个ES5中，比较偏向函数式思想的reduce方法。关于这个方法，我想很多人其实还并不理解，建议先去进行学习，或者参考我之前的<a href="http://www.jianshu.com/p/5b4c2f4c7a52" target="_blank" rel="external">一篇文章。</a><br>同时，我尝试获取：user－&gt;posts[0]－&gt;comments，<br>并配以一个反例：user－&gt;post[0]－&gt;comments；<br>当然，在反例中，post数组并不存在。</p>
<p>我们来分析一下代码。</p>
<pre><code>const get = (p, o) =&gt;
    p.reduce((xs, x) =&gt;
        (xs &amp;&amp; xs[x]) ? xs[x] : null, o)
</code></pre><p>我们实现的get方法中，接收两个参数，第一个p表示获取值的路径（path）；另外一个参数表示目标对象。</p>
<p>同样，为了设计上的更加灵活和抽象。我们可以柯粒化我们的方法：</p>
<pre><code>const get = p =&gt; o =&gt;
    p.reduce((xs, x) =&gt;
        (xs &amp;&amp; xs[x]) ? xs[x] : null, o)
</code></pre><p>这样的话，就可以这个姿势调用：</p>
<pre><code>const getUserComments = get([&apos;user&apos;, &apos;posts&apos;, 0, &apos;comments&apos;])
console.log(getUserComments(props))
// [ &apos;Good one!&apos;, &apos;Interesting...&apos; ]
console.log(getUserComments({user:{posts: []}}))
// null
</code></pre><p>如果关于get方法中reduce的使用还不清楚，那就再看一个简单的例子：</p>
<pre><code>[&apos;id&apos;].reduce((xs, x) =&gt; (xs &amp;&amp; xs[x]) ? xs[x] : null, {id: 10})
// 返回10
</code></pre><h3 id="Ramda方案"><a href="#Ramda方案" class="headerlink" title="Ramda方案"></a>Ramda方案</h3><p>如果不自己手动设计上述方法的话，我们可以使用Ramda函数式类库完成：</p>
<pre><code>const getUserComments = R.path([&apos;user&apos;, &apos;posts&apos;, 0, &apos;comments&apos;])
</code></pre><p>接下来调用需要这个姿势：</p>
<pre><code>getUserComments(props) // [ &apos;Good one!&apos;, &apos;Interesting...&apos; ]
getUserComments({}) // null
</code></pre><p>如果我们想在指定路径下未找到一个值时，不返回null，而是返回自定义的内容呢？我们可以使用pathOr方法，第一个参数用来设置默认输出。</p>
<pre><code>const getUserComments = R.pathOr([], [&apos;user&apos;, &apos;posts&apos;, 0, &apos;comments&apos;])
getUserComments(props) // [ &apos;Good one!&apos;, &apos;Interesting...&apos; ]
getUserComments({}) // []
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章翻译自A.Sharif的最新文章：<a href="https://medium.com/javascript-inside/safely-accessing-deeply-nested-values-in-javascript-99bf72a0855a" target="_blank" rel="external">Safely Accessing Deeply Nested Values In JavaScript</a>，其中后半部分未做翻译。<br>后半部分其实分析了 Ramda＋<a href="http://folktalejs.org/" target="_blank" rel="external">Folktale</a>的实现，以及Ramda＋<a href="https://medium.com/@dtipson/functional-lenses-d1aba9e52254" target="_blank" rel="external">Lenses</a>的实现。Folktale和Lenses是非常函数式Functional Programming的思想，理解起来相对晦涩且比较小众。有兴趣的读者可以点击原文去自行了解。</p>
<p>如果你对函数式编程并不感冒，大可只学习第一部分的实现。对于函数式编程有兴趣的同学，希望这篇文章能够抛砖引玉，欢迎与我交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;古有赵子龙面对“冲锋之势，有进无退，陷阵之志，有死无生”的局面，能万军丛中取敌将首级。&lt;br&gt;在我们的Javascript中，往往用对象（Object）来存储一个数据结构。如果这个结构非常复杂，那么想要安全优雅地取出一个值，也并非简单。&lt;/p&gt;
&lt;p&gt;这篇文章将会详细阐述在
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从ES6 Const看Javascript语言的诡异与灵活</title>
    <link href="https://exp-team.github.io/blog/2017/04/04/js/const/"/>
    <id>https://exp-team.github.io/blog/2017/04/04/js/const/</id>
    <published>2017-04-03T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>不管您对Javascript有多大偏见，不管您究竟认为什么是世界上最好的语言。都不可否认的是，Javascript现今的火热与流行。根据Stack Overflow最新 年度开发者调查（2017年3月23日），JS又蝉联最热门的编程语言。</p>
<p>笔者对Javascript研究也就不到两年时间，资历尚浅。其实，阮一峰2015年的一篇文章也有谈到类似的话题：<a href="http://www.ruanyifeng.com/blog/2015/02/flexible-javascript.html" target="_blank" rel="external">JavaScript有多灵活？</a>，这篇文章非常不错，但是所举的例子稍微有些“偏”而像“奇技异巧”。</p>
<p>今天我们通过ES6中一个新特性来展开，更加大众而普遍，谈一谈Javascript这门语言的灵活性。</p>
<p>本文示例借鉴Jacopo Daeli的最新文章：<a href="https://medium.com/the-node-js-collection/what-does-const-stand-for-in-es6-f7ab3d9e06fc" target="_blank" rel="external">What does const stand for in ES6?</a>，喜欢看英文原版的同学可以直接戳链接。</p>
<h2 id="C-like-VS-JavaScript"><a href="#C-like-VS-JavaScript" class="headerlink" title="C-like VS JavaScript"></a>C-like VS JavaScript</h2><p>如果你习惯了C-like语言，也许你会很奇怪下边这两段代码：</p>
<pre><code>// JavaScript
const numbers = [1, 2, 3, 4, 6]
numbers[4] = 5
console.log(numbers[4]) // print 5 

// C
const int numbers[] = {1, 2, 3, 4, 6};
numbers[4] = 5; // error: read-only variable is not assignable
printf(&quot;%d\n&quot;, numbers[4]); 
</code></pre><p>没错，对于关键字const声明的变量在C语言中，编译会报错；但是在JavaScript里，一点问题也没有。</p>
<p>为什么呢？<br>其实原因在于，C语言中，const表述定义一个只读（read-only）变量。这个变量是不可被更改的。但是在JavaScript中，const表示的并不是变量值不可变，并不意味着变量值是个绝对常量或者只读常量。</p>
<p>那么，JavaScript里，关键字为什么脑残的也叫“const”呢？const究竟从何而来？<br>其实，const关键字顾名思义，一定是确定了某种紧密恒定关系。事实上，JavaScript里，const实际上保证的是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<p>我完全可以通过下面代码来证明：</p>
<pre><code>const numbers = [1, 2, 3, 4, 6]
numbers = [7, 8, 9, 10, 11] // error: assignment to constant variable
console.log(numbers[4])
</code></pre><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><p>为了更加深入理解上面的逻辑，我们需要理解JavaScript基本类型和引用类型不同的存储方式：堆存储和栈存储。</p>
<p>社区上关于这个概念的讲解不少，其实大体都可以总结为一下这么两个方面：</p>
<ol>
<li><p>基本计算机概念<br>两者都是存放临时数据的地方。<br>栈是先进后出的。<br>堆是在程序运行时（而不是在程序编译时），申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。对于堆，我们可以随心所欲的进行增加变量和删除变量，不用遵循次序。<br>栈区（stack）由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。<br>堆区（heap）一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。 </p>
</li>
<li><p>JavaScript两种类型<br>基本数据类型：基本数据类型值指保存在栈内存中的简单数据段。访问方式是按值访问。<br>引用数据类型：引用数据类型值指保存在堆内存中的对象。也就是，变量中保存的实际上的只是一个指针，这个指针指向内存中的另一个位置，该位置保存着对象。访问方式是按引用访问。</p>
</li>
</ol>
<p>还好吗？如果你被上面大段专业术语搞得云里雾里，可以去再找写资料进行了解。这里不再科普，针对上面示例代码，我画一个图，相信会很快明白：</p>
<pre><code>图片
</code></pre><p>numbers这个数组变量属于引用类型。他的存储包含两大部分：<br>栈内存中保存了变量标识符numbers和指向堆内存中该对象／数组的指针；<br>堆内存中保存了对象／数组的实际内容。</p>
<p>而const关键字，保证了第一个左边短箭头的指定关系。numbers这个数组变量标识符不能指向其他的引用指针。因此，</p>
<pre><code>const numbers = [1, 2, 3, 4, 6]
numbers = [7, 8, 9, 10, 11]
</code></pre><p>就会报错，他的做法是把numbers指向了了其他的引用指针，该指针指向的是一个新的数组。</p>
<p>而右边的箭头并没有指定关系。我们可以任意改变[1, 2, 3, 4, 6]这个数组的内容。如先前所示。</p>
<h2 id="如何产生一个完全不可变的数据"><a href="#如何产生一个完全不可变的数据" class="headerlink" title="如何产生一个完全不可变的数据"></a>如何产生一个完全不可变的数据</h2><p>关于不可变数据，我之前的<a href="http://www.jianshu.com/p/89f1d4245b20" target="_blank" rel="external">一篇文章有过深入讲解</a>，这里所说的产生一个完全不可变数据，就类似于C语言当中的const用法。</p>
<p>当然，如果你理解了前文，就知道基本类型的变量，用const声明，永远都是不可变的：</p>
<pre><code>const a = 10
a = a + 1 // error: assignment to constant variable

const isTrue = true
isTrue = false // error: assignment to constant variable

const sLower = &apos;hello world&apos;
const sUpper = sLower.toUpperCase() // create a new string
console.log(sLower) // print hello world
console.log(sUpper) // print HELLO WORLD
</code></pre><p>那么对于一个引用类型，若想实现不可变性，我们可以使用ES5当中新增的Object.freeze方法。发方法产生一个“被冻结”的对象，具体用法不再科普，可以看下例子：</p>
<pre><code>const me = Object.freeze({name: “Jacopo”})
me.age = 28
console.log(me.age) // print undefined

# Example 5
const arr = Object.freeze([-1, 1, 2, 3])
arr[0] = 0
console.log(arr[0]) // print -1
</code></pre><p>但是他的问题在于，该方法只能对完全的“属性－值”（property-value pair）范式的对象起作用。也就是说，类似Date, Map and Set这种对象，该方法无解。<br>另外，这也是一种shallow处理，如果对象存在嵌套，超过一层的话，也无法完全冻结：</p>
<pre><code>const me = Object.freeze({
    name: &apos;Jacopo&apos;, 
    pet: {
        type: &apos;dog&apos;,
        name: &apos;Spock&apos;
    }
})
me.pet.name = &apos;Rocky&apos;
me.pet.breed = &apos;German Shepherd&apos;
console.log(me.pet.name) // print Rocky
console.log(me.pet.breed) // print German Shepherd
</code></pre><p>如果想把一个对象完全冻结（包括其嵌套对象），你可以递归实现一个deepFreeze()方法。实现思路并不难，使用递归就可以，比如：</p>
<pre><code>function deepFreeze(obj) {
    var propNames = Object.getOwnPropertyNames(obj);

    propNames.forEach(function(name) {
        var prop = obj[name];

        if (typeof prop == &apos;object&apos; &amp;&amp; prop !== null)
        deepFreeze(prop);
    });

    return Object.freeze(obj);
}

obj2 = {
    internal: {}
};

deepFreeze(obj2);
obj2.internal.a = &apos;anotherValue&apos;;
obj2.internal.a; // undefined
</code></pre><p>同时，我们还可以使用Immutable.js类库，他本身并不会实现冻结一个对象，但是提供了很对不可变数据类型。比如：List, Stack, Map, OrderedMap, Set, OrderedSet and Record等等。</p>
<h2 id="var-let-or-const"><a href="#var-let-or-const" class="headerlink" title="var, let or const?"></a>var, let or const?</h2><p>到这里，我们已经深入理解了const这个关键字。那么，在实践中，该如何处理或者使用var， let or const这三个声明方式呢？<br>在ES6环境下，开发者应该永远避免使用var去声明一个变量或者常量。它现在是最没有语义指导性的关键字。</p>
<p>合理的使用 var， let 和 const对于保证代码的干净和可读性具有重要意义。既然const用来表明标识符的引用无法被再分配（the identifier can’t be reassigned），他应该用在所有标识符的引用固定不变的代码中。如果标识符引用会发生变化，我们应当使用let来代替。举个例子，对于大部分循环中的计数器index，我们需要使用let来声明，这是一种极好的做法。同样，在子程序中，值会被交换替换的情况，当然也需要使用let来声明。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章深入分析了ES6中的const，并尝试实现了一个冻结对象的方法。<br>其实javascript语言的灵活性体现在很多层面：基于原型链的继承，执行环境上下文、this指向等等。<br>今天这些当然只是庐山一面，想象一下，不论是let还是const，或者是var，都是我们平时写程序天天用到的。理解其中内涵，不仅可以减少BUGs的出现，也会让我们对这门语言有更深入的了解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不管您对Javascript有多大偏见，不管您究竟认为什么是世界上最好的语言。都不可否认的是，Javascript现今的火热与流行。根据Stack Overflow最新 年度开发者调查（2017年3月23日），JS又蝉联最热门的编程语言。&lt;/p&gt;
&lt;p&gt;笔者对Javascr
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>三个叹为观止的ES6 Array hack</title>
    <link href="https://exp-team.github.io/blog/2017/04/04/js/array_hack/"/>
    <id>https://exp-team.github.io/blog/2017/04/04/js/array_hack/</id>
    <published>2017-04-03T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript中，数组随处可见。在最新版本的ECMAScript 6背景下，借助新的展开符、解构等特性，我们可以对数组做很多“四两拨千斤”的事情。<br>这片文章我会分享几个超级有用的hack技巧。</p>
<h2 id="遍历空数组"><a href="#遍历空数组" class="headerlink" title="遍历空数组"></a>遍历空数组</h2><p>JavaScript数组其实是天生“稀疏”的。稀疏数组其实是一个很重要的概念：</p>
<blockquote>
<p>A sparse array is one in which the elements do not have contiguous indexes starting at 0.</p>
</blockquote>
<p>从定义来看，稀疏数组就是没有从0开始的连续的index。</p>
<p>那么什么样会有稀疏数组？<br>有没有被赋值的项；<br>有被删除（delete）的项</p>
<p>我们从下面这个例子来看：</p>
<pre><code>const arr = new Array(4);
</code></pre><p>我们新建了一个长度为4的数组。你会发现，遍历这个数组我们只会得到：</p>
<pre><code>arr.map((elem, index) =&gt; index);
// [undefined, undefined, undefined, undefined]
</code></pre><p>为了解决这个问题，比如，我想得到一个每一项值为其index的数组，长度为4，可以这样做：</p>
<pre><code>const arr = Array.apply(null, new Array(4));
arr.map((elem, index) =&gt; index);
// [0, 1, 2, 3]
</code></pre><p>当然，我们有一个更好的方法，就是使用ES6的展开符特性：</p>
<pre><code>const arr = [...new Array(4)];
arr.map((elem, index) =&gt; index);
// [0, 1, 2, 3]
</code></pre><h2 id="给方法传递一个空参数"><a href="#给方法传递一个空参数" class="headerlink" title="给方法传递一个空参数"></a>给方法传递一个空参数</h2><p>如果你想调用某个方法，但是忽略这个方法的某个参数，那么正常情况下，这样做是会报错的：</p>
<pre><code>function method (a1, a2, a3) { console.log(&apos;ok&apos;); }
method(&apos;parameter1&apos;, , &apos;parameter3&apos;);
Uncaught SyntaxError: Unexpected token ,
</code></pre><p>在实际开放中，这样的场景其实屡见不鲜，我们通常的做法是，将这个函数参数传递为null或者undefined:</p>
<pre><code>method(&apos;parameter1&apos;, null, &apos;parameter3&apos;) // or
method(&apos;parameter1&apos;, undefined, &apos;parameter3&apos;);
</code></pre><p>我个人其实并不喜欢用null来代替，因为在JavaScript中，null会被当作一个object来处理，这其实是很奇怪的。但是在ES6中，借助展开符和数组特性，我们能更好地实现上述做法。</p>
<p>上文提到JavaScript中数组其实是天生稀疏的，所以，给一个数组传递一个空值是没有问题的。因此，我们这样做：</p>
<pre><code>method(...[&apos;parameter1&apos;, , &apos;parameter3&apos;]);
// ok
</code></pre><ol>
<li>Unique array values<br>I always wonder why the Array constructor doesn’t have a designated method to facilitate the use of unique array values. Spread operators are here for the rescue. Use spread operators with the Set constructor to generate unique array values.<blockquote>
<p>const arr = […new Set([1, 2, 3, 3])]<br>[1, 2, 3]</p>
</blockquote>
</li>
</ol>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>数组去重，是一个老生常谈的话题。实现方式真的已经很多了。但是我其实一直以来不明白Array构造函数的原型上，为什么没有一个“官方”的方法，来产生一个不重复的数组或者完成数组去重的功能。ES6展开符的出现，成为了一种“官方”解决方案。</p>
<p>我们使用展开符，结合Set构造函数，便可以产生一个不含重复项的数组：</p>
<pre><code>const arr = [...new Set([1, 2, 3, 3])]
// [1, 2, 3]
</code></pre><p>其实， NaN != NaN 对数组去重的不同方法会产生不同影响。在上述方法当中，我们会得到：</p>
<pre><code>const arr = [...new Set([1, 2, 3, 3, NaN, NaN])]
// [1, 2, 3, NaN]   
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天介绍了几个利用ES6新特性对数组实现的一些hack方法，简单有效且优雅得体。在ES6引领前端开发的今天，希望对大家能有所启发。也欢迎留言，与我讨论。</p>
<p>PS: 作者<a href="https://github.com/HOUCe" target="_blank" rel="external">Github仓库</a>，欢迎通过代码各种形式交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JavaScript中，数组随处可见。在最新版本的ECMAScript 6背景下，借助新的展开符、解构等特性，我们可以对数组做很多“四两拨千斤”的事情。&lt;br&gt;这片文章我会分享几个超级有用的hack技巧。&lt;/p&gt;
&lt;h2 id=&quot;遍历空数组&quot;&gt;&lt;a href=&quot;#遍历空数
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从一个拖拽类小游戏开发 谈一谈ES6中面向对象思路设计组件</title>
    <link href="https://exp-team.github.io/blog/2017/04/02/js/match-lovers/"/>
    <id>https://exp-team.github.io/blog/2017/04/02/js/match-lovers/</id>
    <published>2017-04-01T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>无意中在Github看到了一个拖拽类小游戏，翻看了一下代码，发现拖拽的实现使用了jQuery UI当中现成的组件。<br>同样在不经意间，看到了@波同学一系列的<a href="http://www.jianshu.com/u/10ae59f49b13" target="_blank" rel="external">进阶教程</a>，每一章节内容很丰富，质量也很高，尤其有一节讲到了“面向对象实战之封装拖拽对象”，并且最后实现了封装成jquery插件。</p>
<p>这里，我将这两个“无意中”进行了整合。使用ES6中的面向对象，实现了“拖拽”类，并且使用并开发成了一个新的小游戏－lovers match.</p>
<p>这篇文章谈一谈设计“拖拽”类的实现思路和整个游戏开发的设计。</p>
<h2 id="游戏一瞥"><a href="#游戏一瞥" class="headerlink" title="游戏一瞥"></a>游戏一瞥</h2><h2 id="ES6中的class和原型链系列知识"><a href="#ES6中的class和原型链系列知识" class="headerlink" title="ES6中的class和原型链系列知识"></a>ES6中的class和原型链系列知识</h2><p>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。<br>ES6中提供了更接近传统语言的写法，引入了Class（类）这个概念。通过class关键字，可以定义类。<br>当然，ES6的class其实只是一个语法糖，它的绝大部分功能，ES5都可以做到。我曾经也写过<a href="http://www.jianshu.com/p/d36fb31f9cff" target="_blank" rel="external">分析文章</a>，来讨论Babel是如何对ES6中的Class进行编译并实现继承的。</p>
<p>如果你对传统模式很感兴趣，或者想修炼基础知识，<a href="http://www.jianshu.com/p/d36fb31f9cff" target="_blank" rel="external">不妨一读</a>。<br>同样，也很建议对比一下@波同学的传统代码实现，和我的ES6版本实现。相信对于原型、原型链、构造函数的知识会有一个更加清晰的认识。</p>
<h2 id="ES6封装的拖拽类"><a href="#ES6封装的拖拽类" class="headerlink" title="ES6封装的拖拽类"></a>ES6封装的拖拽类</h2><p>先来看一下实现的Drag类实现结构：</p>
<pre><code>class Drag {
    constructor(opt) {
        ...
    }
    init() {
        ...
    }
    getPosition() {
        ...
    }
    setPostion(pos) {
        ...
    }
    getTransform() {
        ...
    }
}
</code></pre><p>上面代码定义了一个Drag类，可以看到里面有一个constructor方法，这就是构造方法，其实相当于传统的构造函数。我们在这里进行一些初始化操作。</p>
<p>另外，需要注意的是，除了init方法，我们还可以看到getPosition，setPostion，getTransform这三个方法。其实这三个只是工具函数，不需要对外暴露。所以写在上面那样的位置，并不是很合理的。在每一个Drag的实例中，并不需要这样的方法。</p>
<p>更好的做法当然是加上类似Java中的private关键字，使之成为私有方法。那么在ES6中，是否有这样一个关键字呢？<br>在阮一峰大大的《ECMAScript6 标准》一书中，这么写到：</p>
<blockquote>
<p>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。很有意思的一点是，之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为JavaScript是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby语言使用@表示私有属性，ES6没有用这个符号而使用#，是因为@已经被留给了 Decorator。</p>
</blockquote>
<p>另外，可以接受的方法是使用static关键字：加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<p>其实，这些关键字要么就是在草案阶段，要么就是在提议阶段，不可能直接使用。为此，我们应该把这三个工具方法放在class声明之外，作用域之内。</p>
<h2 id="Transform属性的嗅探"><a href="#Transform属性的嗅探" class="headerlink" title="Transform属性的嗅探"></a>Transform属性的嗅探</h2><p>如果你理解拖拽这种交互细节，你就会想到拖拽过程中需要改变目标元素的位置信息。位置信息的改变，大体上使用两种方式：<br>1）left/top/right/bottom属性<br>当然，这要配合relative或者absolute属性使用。<br>2）CSS3 transform:translate()属性</p>
<p>我们推荐第二种方法，毕竟如果我们使用translate3d()赋值，会开启GPU加速，在拖拽性能上会更有优势。<br>但是问题在于浏览器兼容性上。有的浏览器不支持，有的浏览器需要加浏览器前缀。<br>因此更合理的做法是做一个嗅探，在不支持的情况下，采用left/top/right/bottom属性的Plan B:</p>
<pre><code>getTransform() {
    let transform = &apos;&apos;;
    let divStyle = document.createElement(&apos;div&apos;).style;
    let transformArr = [&apos;transform&apos;, &apos;webkitTransform&apos;, &apos;MozTransform&apos;, &apos;msTransform&apos;, &apos;OTransform&apos;];
    var i = 0;
    let len = transformArr.length;
    for(; i &lt; len; i++)  {
        if(transformArr[i] in divStyle) {
            return transform = transformArr[i];
        }
    }
    return transform;
}
</code></pre><p>上面这个工具方法的目的是对transform进行统一范化。主要是路是创建一个div标签，之后使用for…in遍历div的style属性。<br>如果浏览器不兼容，transform值为空，否则为相应支持的加上浏览器前缀的transform属性。</p>
<p>其实上面程序实现不太完美的一点是，我们每次嗅探，都会生成一个无意义的div标签。这样当然会造成浪费。</p>
<h2 id="拖拽过程设计"><a href="#拖拽过程设计" class="headerlink" title="拖拽过程设计"></a>拖拽过程设计</h2><p>在拖拽过程设计上，应该很容易想到需要监听touchstart/mousedown，touchmove/mousemove，touchend/mouseup这三对事件。<br>当mousedown触发时，我们执行：</p>
<pre><code>me.startX = e.pageX;
me.startY = e.pageY;

const pos = me.getPosition();
me.sourceX = pos.x;
me.sourceY = pos.y;

me.dragStart &amp;&amp; me.dragStart({me.startX, me.startY, ...pos});

function moveHandler(e) {
    ...
}
function endHandler() {
    ...
}

$(document).on(eMove, moveHandler);
$(document).on(eEnd, endHandler);
</code></pre><p>dragStart是我设计暴漏给用户在mousedown触发时的回调函数，在获取到事件各种信息（事件坐标，事件对象坐标）之后执行。<br>之后在document上绑定mousemove触发时的处理函数：moveHandler，和mouseup触发时的处理函数：endHandler。</p>
<p>细心的读者可能要问了，为什么要把这些事件绑定在document上，而不是目标元素上呢？其实在亲自动手实现前，我也不是很理解。<br>后来发现这么做的目的是为了防止在拖拽过程中，因为移动过快，鼠标已经移出目标元素，而造成拖拽效果实效的问题。如果您不理解，相信动手实践下就会发现。</p>
<p>在mousemove处理函数即moveHandler中，当然要实现的就是根据鼠标移动距离，算出目标元素的坐标信息了。唯一要注意的细节是，对于left/top/right/bottom和transform:translate()的分情况处理。另外，如果你是用原生JS实现，那就需要在注意取目标元素样式值的数字转换问题以及浏览器兼容性问题。<br>计算和处理过程这里我就不贴出来了。</p>
<p>在mouseup处理函数即endHandler中，需要做的就是对document上已经绑定事件的解绑，并执行定制的回调函数：</p>
<pre><code>$(document).off(eMove);
$(document).off(eEnd);
me.dragEnd &amp;&amp; me.dragEnd({target:me.element});
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Happy Coding!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意中在Github看到了一个拖拽类小游戏，翻看了一下代码，发现拖拽的实现使用了jQuery UI当中现成的组件。&lt;br&gt;同样在不经意间，看到了@波同学一系列的&lt;a href=&quot;http://www.jianshu.com/u/10ae59f49b13&quot; target=&quot;_
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>React+Redux打造“NEWS EARLY”单页应用 一步步让你理解最前沿技术栈的真谛</title>
    <link href="https://exp-team.github.io/blog/2017/03/30/js/news-early/"/>
    <id>https://exp-team.github.io/blog/2017/03/30/js/news-early/</id>
    <published>2017-03-29T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇文章，分享了我利用闲暇时间，使用React+Redux技术栈重构的百度某产品个人中心页面。您可以<a href="http://www.jianshu.com/p/8e28be0e7ab1" target="_blank" rel="external">参考这里</a>，或者参考<a href="https://github.com/HOUCe/react-redux-demo" target="_blank" rel="external">Github代码仓库地址。</a><br>这个工程实例中，我采用了厂内的工程构建工具－FIS，并贯穿了react+redux基本思想。</p>
<p>今天这篇文章给大家分享一个更加复杂，但是非常有趣的一个项目-</p>
<blockquote>
<p>News Early单页应用。</p>
</blockquote>
<p>我把这个项目所有代码托管在了我个人Github之中，感兴趣的读者可以跟我探讨。</p>
<p>最近我发现，React Redux生态圈项目活跃。但是作品质量“良莠不齐”，很多非常热门的项目不仅没有起到“布道”作用，而且在一定程度上“误导”了读者。在这篇文章里面我会有详细说明。当然，我自己也是资历浅显，水平有限。希望大神能够给与斧正。</p>
<p>同时通过这个项目实例和这篇文章，一步一步说明了这个项目开发细节，并且包括了优化手段等内容。希望使大家对于React技术栈，包括：Redux数据流框架＋React Router路由管理＋Webpack构建工具等，有一个更加清晰深刻的理解。</p>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>在国外上学和工作期间，能畅通无阻的访问诸如：BBC，CNN，ESPN，Le Figaro等新闻媒体是一大便利，也是我个人闲暇时期一个喜好之一。<br>甚至外出旅游时，在酒店收看这些媒体卫视（尤其CNN）竟然也是放松休闲的一大方式。。。</p>
<p>当然，国内环境对于这些境外媒体显然不是太友好。<br>基于此，我设计开发了News Early项目。</p>
<blockquote>
<p>这个项目是一个包括：BBC，CNN，The NewYork Times等70多个国际知名媒体的即时头条新闻聚合APP。</p>
<p>News Early is a simple and easy-to-use Web APP that gathers the headlines currently published on a range of news sources and blogs (70 and counting so far).</p>
</blockquote>
<p>整个项目我使用了包括但不限于以下技术栈和构建工具：<br>1）React UI框架from Facebook；<br>2）JSX模版；<br>3）Redux数据流设计；<br>4）Webpack构建工具；<br>5）Less预处理器；<br>……</p>
<h2 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h2><p>整个Web APP的部分使用体验，我用以下GIF图示来呈现：<br>（请耐心等待GIF图加载）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-f960f8050f049833.gif?imageMogr2/auto-orient/strip" alt="APP 使用截图"></p>
<ul>
<li>1）<strong>页面顶部导航条</strong><br>包括：侧栏菜单开启按钮和右侧的刷新页面按钮。</li>
<li>2）<strong>页面内容头部轮播图</strong><br>支持自动播放和手势滑动操控。</li>
<li>3）<strong>页面主体部分</strong><br>主体部分是所对应的新闻频道的headlines头条新闻，一般有10-20个items左右。每一个item包含一张新闻图片，新闻导读（Abstract）以及新闻发布时间（publish time）。</li>
<li>4）<strong>左侧折叠菜单栏</strong><br>功能用于新闻频道的筛选。<br>以Gif图截取为止，一共接入了：BBC News，BBC Sport，CNN，ESPN，Financial Times，USA Today，MTV News7家国际媒体。</li>
</ul>
<p>因为我不是搞视觉设计的，也不是做页面交互设计的。我只是一枚码农。所以为了节省时间，整体APP的样式上，包括界面颜色等，我参考了<a href="http://m.maizuo.com/v4/?co=maizuo#/?_k=h7qksx" target="_blank" rel="external">卖座网</a>的实现。</p>
<h2 id="项目架构和落地"><a href="#项目架构和落地" class="headerlink" title="项目架构和落地"></a>项目架构和落地</h2><p>下面，我为大家介绍一下整个项目的设计构成和开发细节。</p>
<h3 id="数据流状态演示"><a href="#数据流状态演示" class="headerlink" title="数据流状态演示"></a>数据流状态演示</h3><p>熟悉Redux数据流框架的同学，应该对于store，dispatch，action，reducer，以及中间件等概念比较熟悉。这里不再进行讲解。<br>这套架构中，最重要的就是<strong>数据流的设计。</strong></p>
<p>首先，我们先整体看一下在“切换频道”这个交互发生时，整个项目的数据流向和数据结构的演示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-df843395274f854c.gif?imageMogr2/auto-orient/strip" alt="数据流动示意图"></p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-abcbfc9811943bd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录结构"></p>
<p>整个项目业务代码部分，我拆分成9个UI组件，1个全局Store，一个actions定义文件。</p>
<ul>
<li>app是开发目录<ul>
<li>actions目录集中了全局所有的actions</li>
<li>components目录集中了全局用到的所有UI组件</li>
<li>reducers目录集中了Redux架构中的所有reducers</li>
<li>store目录定义全局唯一的store</li>
<li>style目录集中了全局所有组件的样式文件</li>
<li>main.js为全局的入口函数</li>
</ul>
</li>
<li>build是打包后结果目录<ul>
<li>index.html是输出页面文件</li>
<li>bundle.js开发目录下脚本文件打包后的产出</li>
<li>img文件定义了APP开启时的loading图片</li>
</ul>
</li>
<li>node_modules相信大家不会陌生，这是依赖文件<br>…<br>其他配置文件不再一一介绍。</li>
</ul>
<p>10个组件包括：</p>
<ul>
<li>appIndex: 组件容器</li>
<li>billboardCarousel: 页面轮播图组件</li>
<li>currentChanel: 页面headlines新闻头条组件</li>
<li>homeView: 主体页面</li>
<li>imagePlaceholder: 占位图组件</li>
<li>loading: 加载提示组件</li>
<li>navBar :顶部导航组件</li>
<li>sideBar: 侧边栏组件</li>
<li>routerWrap: 路由相关组件</li>
</ul>
<h3 id="骨架构建"><a href="#骨架构建" class="headerlink" title="骨架构建"></a>骨架构建</h3><p>我认为，redux之所以学习曲线陡，很大程度上就在于<strong>数据流的贯通上。</strong></p>
<blockquote>
<p>“组件触发(dispatch)各种action，单向数据流流向reducer，reducer是一个纯函数(函数式编程思想)，接收处理action，返回新的数据，组件进而更新”</p>
</blockquote>
<p>这一套理论并不难理解。</p>
<p>但是落实在工程上，尤其要结合react，那就不好做了。即使有人做出来，业务就算可以跑得通，但是相比核心思想，却是背道而驰。社区上我看过很多项目，在写法上不分青红皂白，只要能运行，胡乱设计一通，误导初学者。</p>
<p>比如在整个项目中，存在多个stores这种常见的问题。</p>
<p><strong>那么，为什么不建议存在多个store呢？</strong><br>答案可以在<a href="http://redux.js.org/docs/faq/StoreSetup.html" target="_blank" rel="external">官方FAQ</a>中找到。内容较多，如果英文阅读吃力，我大体翻译一下：<br><em>熟悉Flux原始模型的读者可能了解，Flux存在多个stores，每个store都维护了不同层次的数据。这样设计的问题在于，一个store需要等待另外一个store的操作处理。我们Redux实现了切分数据层次，避免了这种情况的发生。<br>仅维持单个store不仅可以使用Redux DevTools，还能简化数据的持久化及深加工、精简订阅的逻辑处理。<br>单一store这种方式，我们不用考虑store模块的导入、 Redux应用的封装，后期支持服务器渲染也将变得更为简便。</em></p>
<p>如果上边这段话过于抽象，难以理解的话，那就直接看我的代码实现吧。</p>
<p>定义全局唯一的store：</p>
<pre><code>const store = createStore(
    combineReducers({
        sideBarChange,
        contents,
        routing: routerReducer
    }),
    composeEnhancers(applyMiddleware(thunkMiddleware)),
);
</code></pre><p>其中，我使用了redux-thunk作为中间件，用于处理异步action。这样，把异步过程放在action级别解决，对component没有影响。<br>另外composeEnhancers是用于使用redux devtool的设置。</p>
<p>容器组件构建：</p>
<pre><code>const mapStateToProps = (state) =&gt; {
    return {
        showLeftNav: state.sideBarChange.showLeftNav,
        loading: state.contents.loading,
        contents: state.contents.contents,
        currentChanel: state.contents.currentChanel
    }
}

var App = connect(mapStateToProps)(AppIndex);
render(
    &lt;Provider store={store}&gt;
        &lt;Router history={history}&gt;
            &lt;Route path=&quot;/&quot; component={App}&gt;
                &lt;Route path=&quot;home&quot; component={HomeView}/&gt;
            &lt;/Route&gt;
        &lt;/Router&gt;
    &lt;/Provider&gt;,
    document.getElementById(&apos;app&apos;)
);
</code></pre><p>其中，我使用了react-redux进行连接。AppIndex是整个项目唯一的容器组件。进行action的dispatch，以及向下传递props给UI组件（木偶组件）。</p>
<p>如果你还不理解<strong>容器组件</strong>和<strong>UI组件</strong>的区别，可以去<a href="http://redux.js.org/docs/basics/UsageWithReact.html" target="_blank" rel="external">官方文档学习。</a>这两个概念极其重要，它直接决定你是否能设计出有效且合理的组件架构。</p>
<p>另外，你会发现我使用了react－router进行路由管理。其实整个项目没有必要使用单页路由。这个路由管理的引入，说实话，比较鸡肋。但并不会对项目产生任何影响。我引入他的原因主要有两点。</p>
<ul>
<li>第一是，后续进行二次开发，考虑到更多的产品迭代的话，使用路由管理是必须的，我们要为长远准备。</li>
<li>另一个原因就是，我从来没用用过，好吧，想尝鲜下。</li>
</ul>
<h3 id="actions设计"><a href="#actions设计" class="headerlink" title="actions设计"></a>actions设计</h3><p>actions当然是必不可少的，我这里选取最重要的“fetchContents”这个action creator来讨论一下。</p>
<p>初次进入页面时，以及左侧边栏点击选择新闻频道时，都要去拉取数据。比如，APP第一次渲染，默认加载“BBC News”新闻频道，页面主体组件在挂载完成后：</p>
<pre><code>componentDidMount() {
    //获取内容
    this.props.fetchContents(&apos;bbc-news&apos;);
}
</code></pre><p>向上调用fetchContents方法，并逐级上传到容器组件。由容器组件进行dispatch:</p>
<pre><code>fetchContents={(source)=&gt;{this.props.dispatch(action.fetchContents(source))}}
</code></pre><p>source表示拉取的新闻频道。此处当然是’bbc-news’。</p>
<p>在actions.js文件中，进行异步action的处理并拉取数据。这里，我使用了最新的<strong>fetch API</strong>来代替古老的XHR，并利用fetch的promise的理念，封装了一层_get方法，用于AJAX异步请求：</p>
<pre><code>const sendByGet = ({url}, dispatch) =&gt; {
let finalUrl = url + &apos;&amp;apiKey=1a445a0861e&apos;
return fetch(finalUrl)
        .then(res =&gt; {
            if (res.status &gt;= 200 &amp;&amp; res.status &lt; 300) {
                return res.json();
            }
            return Promise.reject(new Error(res.status));
        })
}
</code></pre><p>对应的action操作：</p>
<pre><code>export const fetchContents = (source) =&gt; {
    const url = &apos;...&apos;;
    return (dispatch) =&gt; {
        dispatch({type: FETCH_CONTENTS_START});
        if (sessionStorage.getItem(source)) {
            console.log(&apos;get from sessionStorage&apos;);
            let articles = JSON.parse(sessionStorage.getItem(source));
            dispatch({type: FETCH_CONTENTS_SUCCESS, contents: Object.assign(articles, {currentChanel: source.toUpperCase()})})
        }
        else {
            sendByGet({url}, dispatch)
            .then((json) =&gt; {
                if (json.status === &apos;ok&apos;) {
                    sessionStorage.setItem(source, JSON.stringify(json.articles)); 
                    return dispatch({type: FETCH_CONTENTS_SUCCESS, contents: Object.assign(json.articles, {currentChanel: source.toUpperCase()})})
                }
                return Promise.reject(new Error(&apos;FETCH_CONTENTS_SUCCESS failure&apos;));
            })
            .catch((error) =&gt; {
                return Promise.reject(error)
            })
        }
    }
}
</code></pre><h3 id="请求优化"><a href="#请求优化" class="headerlink" title="请求优化"></a>请求优化</h3><p>我们知道，这些异步请求的访问速度是很慢的。因此，我采用了几种方法来进行优化。</p>
<ul>
<li>第一个方法就是加载时的loading美化。<br>我使用了<a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1489644681768&amp;di=2b78e7baf0749987d6bd1879b4d9f9f8&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F02dd4155c1c09a000001a5f0498dd6.gif" target="_blank" rel="external">来自网络的图片</a>占位。<br>当我把控制台中网络环境人为的模拟为3G时，页面效果如下：<br>（请耐心等待GIF图加载）</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-c9da38782a2473d6.gif?imageMogr2/auto-orient/strip" alt="加载占为图"></p>
<p>原谅我使用了这么粉嫩少女的加载图。。。</p>
<ul>
<li><p>第二个方法其实是一个trick，我的全局图片在初始状态时opacity设置为0，在onload事件触发时设置一个fadeIn的效果：</p>
<pre><code>&lt;img ref=&quot;image&quot; src={imgSrc} onLoad=
{this.handleImageLoaded.bind(this)}/&gt;

handleImageLoaded() {
    this.refs[&apos;image&apos;].style.opacity = 1;
}
</code></pre></li>
</ul>
<p>这样的一个小技巧最初来自Facebook对用户体验的研究。如果您对此有兴趣，可以在我的<a href="http://www.jianshu.com/p/2f3bc2598dc5" target="_blank" rel="external">另外一篇文章</a>中找到相关内容。</p>
<ul>
<li>Web Storage来进行优化<br>因为各大新闻媒体的headlines发布更新是不定时的，这个时间间隔可能较长。而我考虑到用户使用这个Web APP一般都是在碎片时间中。因此我采用了sessionStorage进行缓存内容。不要问我为什么不使用localStorage…，如果你存在疑问，建议对于Web Storage的特性再去回炉重修一下。</li>
</ul>
<p>具体实现方式就是在发送请求时判断sessionStorage是否已经存在此新闻媒体（比如bbc）的数据。如果存在就使用缓存。否则就去进行AJAX请求，请求成功的回调函数里进行缓存的种植。<br>代码部分如下：</p>
<pre><code>if (sessionStorage.getItem(source)) {
    console.log(&apos;get from sessionStorage&apos;);
    let articles = JSON.parse(sessionStorage.getItem(source));
    dispatch({type: FETCH_CONTENTS_SUCCESS, contents: Object.assign(articles, {currentChanel: source.toUpperCase()})})
}
else {
    sendByGet({url}, dispatch)
    .then((json) =&gt; {
        if (json.status === &apos;ok&apos;) {
            sessionStorage.setItem(source, JSON.stringify(json.articles)); 
            return dispatch({type: FETCH_CONTENTS_SUCCESS, contents: Object.assign(json.articles, {currentChanel: source.toUpperCase()})})
        }
        return Promise.reject(new Error(&apos;FETCH_CONTENTS_SUCCESS failure&apos;));
    })
    .catch((error) =&gt; {
        return Promise.reject(error)
    })
}
</code></pre><p>当然，有种植缓存，就要有清除缓存。这个按钮我设置在里navBar组件的最右侧：</p>
<pre><code>const CLEAR_SESSIONSTORAGE = &apos;CLEAR_SESSIONSTORAGE&apos;;
export const refresh = () =&gt; {
    sessionStorage.clear();
    return dispatch =&gt; dispatch({type: CLEAR_SESSIONSTORAGE});
}
</code></pre><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p>为了使用先进的构建工具的需求，我使用了node最新版本。但是因为工作业务的需要，又要同时保留低版本node环境。为此，我使用了：n这个利器进行node版本管理。</p>
<p>同时，我使用了webPack一系列强大开发功能和构建功能。包括但不限于：</p>
<ul>
<li>热更新</li>
<li>Less编译插件</li>
<li>服务器构建，使用了8088端口</li>
<li>jsx,es6编译</li>
<li>打包发布</li>
<li>彩色日志</li>
</ul>
<p>…等等，但是我可不是webpack专家。在狼厂，当然使用更多的是FIS构建工具。关于FIS和webpack的比较，我的网红同事@颜大神有过<a href="https://www.zhihu.com/question/50829160" target="_blank" rel="external">探索</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章涉及到了较为前沿的前端开发技术栈。包括了React框架，Redux数据流框架以及函数式编程、异步action中间件，fetch异步请求，webpack配置等等。也无形中涉及到了一些成熟产品的设计理念思路。当然这个项目还远没有成熟。在代码仓库中，我会不间断进行更新。<br>希望本文对大家在各个维度都有所启发。也恳请业界大牛不吝赐教，进行斧正。</p>
<p>最后想跟大家谈一下对于框架和前端学习的一些感受。我记得我刚开始工作，在初次接触前端时，是使用ionic，即Angular框架和phoneGap开发hybrid移动APP。当时我是完全懵b的，只是感觉比利时同事用的超high，6到飞起。每次他用浓重的比利时口音法语给我讲解时，我听的云里雾里，不知所以。</p>
<p>现在想想当时那么菜的原因还是在于自己的JS基础不够牢固。当你面对迅速更新换代的前端技术踟蹰茫然时，唯一的捷径就是从基础抓起，从JS原型原型链，this，执行环境上下文等等看起。</p>
<p>觉得前端知识有欠缺的读者们，欢迎follow我。最近我会带大家“重读”JS经典书籍，以code demo的形式提炼知识点，并会同步到博客和个人Github上。</p>
<p>Happying code!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇文章，分享了我利用闲暇时间，使用React+Redux技术栈重构的百度某产品个人中心页面。您可以&lt;a href=&quot;http://www.jianshu.com/p/8e28be0e7ab1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考这里
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从JS对象开始，谈一谈究竟什么是“不可变数据”和函数式编程</title>
    <link href="https://exp-team.github.io/blog/2017/03/25/js/immutable/"/>
    <id>https://exp-team.github.io/blog/2017/03/25/js/immutable/</id>
    <published>2017-03-24T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为前端开发者，你会感受到JS中对象(Object)这个概念的强大。我们说“JS中一切皆对象”。最核心的特性，例如从String，到数组，再到浏览器的APIs，对象这个概念无处不在。<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects" target="_blank" rel="external">这里</a>你可以了解到JS Objects中的一切。</p>
<p>同时，随着React的强势崛起，不管你有没有关注过这个框架，也一定听说过一个概念—不可变数据(immutable.js)。究竟什么是不可变数据？这篇文章会从JS源头—对象谈起，让你逐渐了解这个函数式编程里的重要概念。</p>
<p>JS中的对象是那么美妙：我们可以随意复制他们，改变并删除他们的某项属性等。但是要记住一句话：</p>
<blockquote>
<p>“伴随着特权，随之而来的是更大的责任。”<br>(With great power comes great responsibility)</p>
</blockquote>
<p>的确，JS Objects里概念太多了，我们切不可随意使用对象。下面，我就从基本对象说起，聊一聊不可变数据和JS的一切。</p>
<p>这篇文章缘起于Daniel Leite在本月16日的<a href="https://www.ckl.io/blog/objects-immutability-javascript/" target="_blank" rel="external">文章：Things you should know about Objects and Immutability in JavaScript</a>，我进行了翻译，并改写了用到的例子，以及进行了大量更多的扩展。</p>
<h2 id="可变和共享是万恶之源"><a href="#可变和共享是万恶之源" class="headerlink" title="可变和共享是万恶之源"></a>可变和共享是万恶之源</h2><p>不可变数据其实是函数式编程相关的重要概念。相对的，函数式编程中认为可变性是万恶之源。但是，为什么会有这样的结论呢？</p>
<p>这个问题可能很多程序员都会有。其实，如果你的代码逻辑可变，这并不是“政治错误”的。比如JS中的数组操作，很对都会对原数组进行直接改变，这当然并没有什么问题。比如：</p>
<pre><code>let arr = [1, 2, 3, 4, 5];
arr.splice(1, 1); // 返回[2];
console.log(arr); // [1, 3, 4, 5];
</code></pre><p>这是我们常用的“删除数组某一项”的操作。好吧，他一点问题也没有。</p>
<p>问题其实出现在“滥用”可变性上，这样会给你的程序带来“副作用”。先不必关心什么是“副作用”，他又是一个函数式编程的概念。</p>
<p>我们先来看一下代码实例：</p>
<pre><code>const student1 = {
    school: &apos;Baidu&apos;,
    name: &apos;HOU Ce&apos;,
    birthdate: &apos;1995-12-15&apos;,
}

const changeStudent = (student, newName, newBday) =&gt; {
    const newStudent = student;
    newStudent.name = newName;
    newStudent.birthdate = newBday;
    return newStudent;
}

const student2 = changeStudent(student1, &apos;YAN Haijing&apos;, &apos;1990-11-10&apos;);

// both students will have the name properties
console.log(student1, student2);
// Object {school: &quot;Baidu&quot;, name: &quot;YAN Haijing&quot;, birthdate: &quot;1990-11-10&quot;} 
// Object {school: &quot;Baidu&quot;, name: &quot;YAN Haijing&quot;, birthdate: &quot;1990-11-10&quot;}
</code></pre><p>我们发现，尽管创建了一个新的对象student2，但是老的对象student1也被改动了。这是因为JS对象中的赋值是“引用赋值”，即在赋值过程中，传递的是在内存中的引用(memory reference)。具体说就是“栈存储”和“堆存储”的问题。具体图我就不画了，理解不了可以单找我。</p>
<h2 id="不可变数据的强大和实现"><a href="#不可变数据的强大和实现" class="headerlink" title="不可变数据的强大和实现"></a>不可变数据的强大和实现</h2><p>我们说的“不可变”，其实是指保持一个对象状态不变。这样做的好处是使得开发更加简单，可回溯，测试友好，减少了任何可能的副作用。<br>函数式编程认为：</p>
<blockquote>
<p>只有纯的没有副作用的函数，才是合格的函数。</p>
</blockquote>
<p>好吧，现在开始解释下“副作用”(Side effect)：在计算机科学中，函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p>
<p>函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并降低程序的可读性。严格的函数式语言要求函数必须无副作用。</p>
<p>那么我们避免副作用，创建不可变数据的主要实现思路就是：一次更新过程中，不应该改变原有对象，只需要新创建一个对象用来承载新的数据状态。</p>
<p>我们使用纯函数(pure functions)来实现不可变性。纯函数指无副作用的函数。<br>那么，具体怎么构造一个纯函数呢？我们可以看一下代码实现，我对上例进行改造：</p>
<pre><code>const student1 = {
    school: &quot;Baidu&quot;, 
    name: &apos;HOU Ce&apos;,
    birthdate: &apos;1995-12-15&apos;,
}

const changeStudent = (student, newName, newBday) =&gt; {
    return {
        ...student, // 使用解构
        name: newName, // 覆盖name属性
        birthdate: newBday // 覆盖birthdate属性
    }
}

const student2 = changeStudent(student1, &apos;YAN Haijing&apos;, &apos;1990-11-10&apos;);

// both students will have the name properties
console.log(student1, student2);
// Object {school: &quot;Baidu&quot;, name: &quot;HOU Ce&quot;, birthdate: &quot;1995-12-15&quot;} 
// Object {school: &quot;Baidu&quot;, name: &quot;YAN Haijing&quot;, birthdate: &quot;1990-11-10&quot;}
</code></pre><p>需要注意的是，我使用了ES6中的解构(destructuring)赋值。<br>这样，我们达到了想要的效果：根据参数，产生了一个新对象，并正确赋值，最重要的就是并没有改变原对象。</p>
<h2 id="创建纯函数，过滤副作用"><a href="#创建纯函数，过滤副作用" class="headerlink" title="创建纯函数，过滤副作用"></a>创建纯函数，过滤副作用</h2><p>现在，我们知道了“不可变”到底指的是什么。接下来，我们就要分析一下纯函数应该如何实现，进而生产不可变数据。</p>
<p>其实创建不可变数据方式有很多，在使用原生JS的基础上，我推荐的方法是使用现有的Objects API和ES6当中的解构赋值（上例已经演示）。现在看一下Objects.assign的实现方式：</p>
<pre><code>const student1 = {
    school: &quot;Baidu&quot;, 
    name: &apos;HOU Ce&apos;,
    birthdate: &apos;1995-12-15&apos;,
}

const changeStudent = (student, newName, newBday) =&gt; Object.assign({}, student, {name: newName, birthdate: newBday})

const student2 = changeStudent(student1, &apos;YAN Haijing&apos;, &apos;1990-11-10&apos;);

// both students will have the name properties
console.log(student1, student2);
// Object {school: &quot;Baidu&quot;, name: &quot;HOU Ce&quot;, birthdate: &quot;1995-12-15&quot;};
// Object {school: &quot;Baidu&quot;, name: &quot;YAN Haijing&quot;, birthdate: &quot;1990-11-10&quot;};
</code></pre><p>同样，如果是处理数组相关的内容，我们可以使用：.map, .filter或者.reduce去达成目标。这些APIs的共同特点就是不会改变原数组，而是产生并返回一个新数组。这和纯函数的思想不谋而合。</p>
<p>但是，再说回来，使用Object.assign请务必注意以下几点：<br>1）他的复制，是将所有可枚举属性，复制到目标对象。换句话说，不可枚举属性是无法完成复制的。<br>2）对象中如果包含undefined和null类型内容，会报错。<br>3）最重要的一点：Object.assign方法实行的是浅拷贝，而不是深拷贝。</p>
<p>第三点很重要，也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。这也就意味着，当对象存在嵌套时，还是有问题的。比如下面代码：</p>
<pre><code>const student1 = {
    school: &quot;Baidu&quot;, 
    name: &apos;HOU Ce&apos;,
    birthdate: &apos;1995-12-15&apos;,
    friends: {
        friend1: &apos;ZHAO Wenlin&apos;,
        friend2: &apos;CHENG Wen&apos;
    }
}

const changeStudent = (student, newName, newBday, friends) =&gt; Object.assign({}, student, {name: newName, birthdate: newBday})

const student2 = changeStudent(student1, &apos;YAN Haijing&apos;, &apos;1990-11-10&apos;);

// both students will have the name properties
console.log(student1, student2); 
// Object {school: &quot;Baidu&quot;, name: &quot;HOU Ce&quot;, birthdate: &quot;1995-12-15&quot;, friends: Object}
// Object {school: &quot;Baidu&quot;, name: &quot;YAN Haijing&quot;, birthdate: &quot;1990-11-10&quot;, friends: Object}

student2.friends.friend1 = &apos;MA xiao&apos;;
console.log(student1.friends.friend1); // &quot;MA xiao&quot;
</code></pre><p>对student2 friends列表当中的friend1的修改，同时也影响了student1 friends列表当中的friend1。</p>
<h2 id="JS本身的苍白无力和强大的不可变数据类库"><a href="#JS本身的苍白无力和强大的不可变数据类库" class="headerlink" title="JS本身的苍白无力和强大的不可变数据类库"></a>JS本身的苍白无力和强大的不可变数据类库</h2><p>以上，我们分析了纯JS如何实现不可变数据。这样处理带来的一个负面影响在于：一些经典APIs都是shallow处理，比如上文提到的Object.assign。如果遇到嵌套很深的结构，我们就需要手动递归。这样做呢，又会存在性能上的问题。</p>
<p>比如我自己动手用递归实现一个深拷贝，需要考虑循环引用的“死环”问题，另外，当使用大规模数据结构时，性能劣势尽显无疑。我们熟悉的jquery extends方法，某一版本（最新版本情况我不太了解）的实现是进行了三层拷贝，也没有达到完备的deep copy。</p>
<p>总之，实现不可变数据，我们必然要关心性能问题。针对于此，我推荐一款已经“大名鼎鼎”的——<a href="http://facebook.github.io/immutable-js/" target="_blank" rel="external">immutable.js类库</a>来处理不可变数据。</p>
<p>他的实现原理很有意思，下面这段话，我摘自camsong前辈的<a href="https://zhuanlan.zhihu.com/p/20295971?columnSlug=purerender" target="_blank" rel="external">文章</a>：</p>
<blockquote>
<p>Immutable实现的原理是Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。<br>同时为了避免deepCopy把所有节点都复制一遍带来的性能损耗，Immutable使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p>
</blockquote>
<p>感兴趣的读者可以深入研究下，这是很有意思的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用JavaScript操纵对象，这样的方式很简单便捷。但是，这样操控的基础是在JavaScript灵活的对象机制的熟练掌握上。不然很容易使你“头大”。</p>
<p>在我开发的百度某部门<a href="http://jingyan.baidu.com/msg" target="_blank" rel="external">私信</a>项目中，因为使用了React+Redux技术栈，并且数据结构较为负责，也采用了immutable.js实现。</p>
<p>最后，在前端开发中，函数式编程越来越热，并且在某种程度上已经取代了“过程式”编程和面向对象思想。</p>
<p>我的感想是在某些特定的场景下，不要畏惧变化，拥抱未来。<br>就像我很喜欢的葡萄牙诗人安德拉德一首诗中那样说的：</p>
<blockquote>
<p>我同样不知道什么是海，<br>赤脚站在沙滩上，<br>急切地等待着黎明的到来。</p>
</blockquote>
<p>Happy Coding!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为前端开发者，你会感受到JS中对象(Object)这个概念的强大。我们说“JS中一切皆对象”。最核心的特性，例如从String，到数组，再到浏览器的APIs，对象这个概念无处不在。&lt;a href=&quot;https://developer.mozilla.org/en-US/d
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第11010期</title>
    <link href="https://exp-team.github.io/blog/2017/03/24/weekly/weekly-11010/"/>
    <id>https://exp-team.github.io/blog/2017/03/24/weekly/weekly-11010/</id>
    <published>2017-03-23T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>3.20-3.24，多说即将关闭，一路走好</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="2017-Web-开发者学习路线图"><a href="#2017-Web-开发者学习路线图" class="headerlink" title="2017 Web 开发者学习路线图"></a><a href="https://zhuanlan.zhihu.com/p/25936930" target="_blank" rel="external">2017 Web 开发者学习路线图</a></h3><h3 id="多说即将关闭，评论迁至何处？"><a href="#多说即将关闭，评论迁至何处？" class="headerlink" title="多说即将关闭，评论迁至何处？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;mid=2455058801&amp;idx=1&amp;sn=e5167772d8eb7df2aed24ea57db3a7ac&amp;chksm=8c16977fbb611e691b60516f2a153688ab83e8ff4078a055dcf0b6dc41280dfca6d2bba0d6d8&amp;mpshare=1&amp;scene=1&amp;srcid=0321dJ5o1t7wCtyyAfwDSnlO#rd" target="_blank" rel="external">多说即将关闭，评论迁至何处？</a></h3><h3 id="谈谈-Emoji-和字符编码"><a href="#谈谈-Emoji-和字符编码" class="headerlink" title="谈谈 Emoji 和字符编码"></a><a href="https://zhuanlan.zhihu.com/p/25707494" target="_blank" rel="external">谈谈 Emoji 和字符编码</a></h3><a id="more"></a>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="深挖data-URI性能瓶颈"><a href="#深挖data-URI性能瓶颈" class="headerlink" title="深挖data URI性能瓶颈"></a><a href="https://isux.tencent.com/understand-data-uri-performance.html" target="_blank" rel="external">深挖data URI性能瓶颈</a></h3><h3 id="80-应聘者都不及格的-JS-面试题"><a href="#80-应聘者都不及格的-JS-面试题" class="headerlink" title="80% 应聘者都不及格的 JS 面试题"></a><a href="https://zhuanlan.zhihu.com/p/25855075" target="_blank" rel="external">80% 应聘者都不及格的 JS 面试题</a></h3><h3 id="Google开源新算法，可将JPEG文件缩小35"><a href="#Google开源新算法，可将JPEG文件缩小35" class="headerlink" title="Google开源新算法，可将JPEG文件缩小35%"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;mid=2659599074&amp;idx=1&amp;sn=a26ae2a8becdc1f2cfbddf44d8ca1495&amp;chksm=8be997f0bc9e1ee6e33f3e33c73d11884ad66085c0aedc9dd5e482063482887d0733d8e7d187&amp;mpshare=1&amp;scene=1&amp;srcid=0318sVDCg6HlpxO7XYoEzkvq#rd" target="_blank" rel="external">Google开源新算法，可将JPEG文件缩小35%</a></h3><p>谷歌大法好</p>
<h3 id="百度SSP单页式应用性能优化实践"><a href="#百度SSP单页式应用性能优化实践" class="headerlink" title="百度SSP单页式应用性能优化实践"></a><a href="http://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485098&amp;idx=1&amp;sn=22955e9d5d7b46df67f927718174bff1&amp;chksm=97236468a054ed7ea687d515f34b3a72bf2c9572c3a4e3570c35e8be3dbf0c0e2ecbd6a83e9f&amp;mpshare=1&amp;scene=1&amp;srcid=0322t1xycMSrEdMbfJhhe1TA#rd" target="_blank" rel="external">百度SSP单页式应用性能优化实践</a></h3><h3 id="React-未来之函数式-setState"><a href="#React-未来之函数式-setState" class="headerlink" title="React 未来之函数式 setState"></a><a href="https://juejin.im/post/58cfcf6e44d9040068478fc6" target="_blank" rel="external">React 未来之函数式 setState</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="GitHub中国区前100名到底是什么样的人？"><a href="#GitHub中国区前100名到底是什么样的人？" class="headerlink" title="GitHub中国区前100名到底是什么样的人？"></a><a href="http://www.jianshu.com/p/d29cba7934c9" target="_blank" rel="external">GitHub中国区前100名到底是什么样的人？</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3.20-3.24，多说即将关闭，一路走好&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;2017-Web-开发者学习路线图&quot;&gt;&lt;a href=&quot;#2017-Web-开发者学习路线图&quot; class=&quot;headerlink&quot; title=&quot;2017 Web 开发者学习路线图&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25936930&quot;&gt;2017 Web 开发者学习路线图&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;多说即将关闭，评论迁至何处？&quot;&gt;&lt;a href=&quot;#多说即将关闭，评论迁至何处？&quot; class=&quot;headerlink&quot; title=&quot;多说即将关闭，评论迁至何处？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMjA5ODQwMQ==&amp;amp;mid=2455058801&amp;amp;idx=1&amp;amp;sn=e5167772d8eb7df2aed24ea57db3a7ac&amp;amp;chksm=8c16977fbb611e691b60516f2a153688ab83e8ff4078a055dcf0b6dc41280dfca6d2bba0d6d8&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0321dJ5o1t7wCtyyAfwDSnlO#rd&quot;&gt;多说即将关闭，评论迁至何处？&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;谈谈-Emoji-和字符编码&quot;&gt;&lt;a href=&quot;#谈谈-Emoji-和字符编码&quot; class=&quot;headerlink&quot; title=&quot;谈谈 Emoji 和字符编码&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25707494&quot;&gt;谈谈 Emoji 和字符编码&lt;/a&gt;&lt;/h3&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>探索nodeJS事件机制源码 打造属于自己的事件发布订阅系统</title>
    <link href="https://exp-team.github.io/blog/2017/03/22/js/node_event/"/>
    <id>https://exp-team.github.io/blog/2017/03/22/js/node_event/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-04-10T04:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，nodeJS改变了整个前端开发生态。本文通过分析nodeJS当中events模块源码，由浅入深实现了属于自己的ES6事件观察者系统。千万不要被nodeJS的外表吓到，不管你是写nodeJS已经轻车熟路的老司机，还是初入前端的小菜鸟，都不妨碍对这篇文章的阅读和理解。</p>
<h2 id="内有乾坤"><a href="#内有乾坤" class="headerlink" title="内有乾坤"></a>内有乾坤</h2><p>nodeJS<a href="https://github.com/nodejs/node" target="_blank" rel="external">官方介绍</a>中，第二句话便是：”Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient”。由此，“事件驱动（event-driven）”对nodeJS设计理念的重要性可见一斑。比如，我们对于文件的读取，任务队列的执行情况都需要这样一个观察者模式来保障。</p>
<h2 id="那个最熟悉的陌生人"><a href="#那个最熟悉的陌生人" class="headerlink" title="那个最熟悉的陌生人"></a>那个最熟悉的陌生人</h2><p>同时，作为前端开发人员，我们对于所谓的“事件驱动”理念——即“事件发布订阅模式（Pub/Sub模式）”一定再熟悉不过了。这种模式在js里面有与生俱来的基因。我们可以认为JS本身就是事件驱动型语言：比如，页面上有一个button, 点击一下就会触发上面的click事件。这是因为此时有特定程序正在监听这个事件，随之触发了相关的处理程序。</p>
<p>这个模式最大的一个好处在于能够解耦，实现“高内聚、低耦合”的理念。那么这样一个“熟悉的”模式应该怎么实现呢？</p>
<p>其实社区上已经有不少前辈的实现了，但是都不能算特别完美，或者不能完全符合特定的场景需求。</p>
<p>本文通过解析nodeJS源码中的events模块，提取其精华，一步步打造了一个基于ES6的eventEmitter系统。</p>
<p>读者有任何想法，欢迎与我交流。同时希望各路大神给予斧正。</p>
<h2 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h2><p>为了方便大家理解，我从一个很简单的页面实例说起。</p>
<p>该页面中，存在两处不同的收藏组件：<br>1）一处在页面顶部；<br>2）一处在页面详情侧栏。<br>第一次点击一个收藏组件按钮，发送异步请求，进行收藏，同时请求成功的回调函数里，将页面中所有“收藏”按钮转换状态为“已收藏”。以达到“当前文章”收藏状态的全局同步。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-a04e1b0f57f8a63d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="页面实例"></p>
<p>完成这样的设计很简单，我们大可在业务代码中进行混乱的操作处理，比如初学者常见的做法是：点击第一处收藏，回调逻辑修改页面当中所有收藏按钮。</p>
<p>这样做的问题在于耦合混乱，不仅仅是一个收藏组件，试想当代码中所有组件全都是这样的“随意”操作，后期维护成本便一发不可收。</p>
<p>我的Github仓库中，也有对于这么一个页面实例的分析，读者若想自己玩一下，可以访问<a href="https://github.com/HOUCe/eventEmitter" target="_blank" rel="external">这里。</a></p>
<p>当然，更优雅的做法就是使用事件订阅发布系统。<br>如何设计一个事件订阅发布系统？我们先来看看nodeJS是怎么做的吧！</p>
<h2 id="nodeJS方案"><a href="#nodeJS方案" class="headerlink" title="nodeJS方案"></a>nodeJS方案</h2><p>读者可以自己去nodeJS仓库查找源码，不过更推荐参考我的<a href="https://github.com/HOUCe/eventEmitter" target="_blank" rel="external">Github-事件发布订阅研究项目</a>，里面不仅有自己实现的多套基于ES6的事件发布订阅系统，也“附赠”了nodeJS实现源码。同时我对源码加上了汉语注释，方便大家理解。</p>
<p>在nodeJS中，引入eventEmitter的方式和使用方法如下：</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
</code></pre><p>我们要研究的，当然就是这个eventEmitter实例。先不急于深入源码，我们需要在使用层面先有一个清晰的理解和认知。不然盲目阅读源码，便极易成为一只“无头苍蝇”。</p>
<p>一个eventEmitter实例，自身包含有四个属性：<br>1）_events：<br>这是一个object，其实相当于一个哈希map。他用来保存一个eventEmitter实例中所有的注册事件和事件所对应的处理函数。以键值对方式存储，key为事件名；value分为两种情况，当当前注册事件只有一个注册的监听函数时，value为这个监听函数；如果此事件有多个注册的监听函数时，value值为一个数组，数组每一项顺序存储了对应此事件的注册函数。<br>需要说明的是，理解value值的这两种情况，对于后面的源码分析非常重要。我认为nodeJS之所以有这样的设计，是出于性能上的考虑。因为很多情况（单一监听函数情况）并不需要在内存上新建一个额外数组。</p>
<p>2）_eventsCount：整型，表示此eventEmitter实例中注册的事件个数。</p>
<p>3）_maxListeners：整型，表示此eventEmitter实例中，一个事件最多所能承载的监听函数个数。</p>
<p>4）domain：在node v0.8+版本的时候，发布了一个模块：domain。这个模块做的是捕捉异步回调中出现的异常。这里与主题无关，不做展开。</p>
<p>同样，eventEmitter实例的构造函数原型上，包含了一些更为重要的属性和方法，包括但不限于：<br>1）addListener(event, listener)：<br>为指定事件添加一个注册函数（以下称监听器）到监听器数组的尾部。他存在一个别名alias：on。<br>2）once(event, listener)：<br>为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。<br>3）removeListener(event, listener)：<br>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。<br>4）removeAllListeners([event])：<br>移除所有事件的所有监听器。如果指定事件，则移除指定事件的所有监听器。<br>5）setMaxListeners(n)：<br>默认情况下，如果你添加的监听器超过10个就会输出警告信息。setMaxListeners 函数用于提高监听器的默认限制的数量。<br>6）listeners(event)：返回指定事件的监听器数组。<br>7）emit(event, [arg1], [arg2], […])：<br>按参数的顺序执行每个监听器，如果事件有注册监听器返回true，否则返回false。</p>
<h2 id="nodeJS设计之美"><a href="#nodeJS设计之美" class="headerlink" title="nodeJS设计之美"></a>nodeJS设计之美</h2><p>上一段其实简要介绍了nodeJS中eventEmitter的使用方法。下面，我们要做的就是深入nodeJS events模块源码，了解并学习他的设计之美。</p>
<h3 id="如何创建空对象？"><a href="#如何创建空对象？" class="headerlink" title="如何创建空对象？"></a>如何创建空对象？</h3><p>我们已经了解到，_events是要来储存监听事件(key)、监听器数组(value)的map。那么，他的初始值一定是一个空对象。直观上，我们可以这样创建一个空对象：</p>
<pre><code>this._events = {};
</code></pre><p>但是nodeJS源码中的实现方式却是这样：</p>
<pre><code>function EventHandlers() {};
EventHandlers.prototype = Object.create(null);
this._events = new EventHandlers();
</code></pre><p>官方称，这么做的原因是出于性能上的考虑，经过jsperf比较，在v8 v4.9版本中，后者性能有超出2倍的表现。</p>
<p>对此，作为一个“吹毛求疵”有态度的程序员，我写了一个benchmark，对一个对象进行一千次取值操作，求平均时间进行验证：</p>
<pre><code>_events = {};
_events.test=&apos;test&apos;
for (let i = 0; i &lt; 1000; i++) {
    window.performance.mark(&apos;test empty object start&apos;);
    console.log(_events.test);
    window.performance.mark(&apos;test empty object end&apos;);
    window.performance.measure(&apos;test empty object&apos;,&apos;test empty object start&apos;,&apos;test empty object end&apos;);
} 
let sum1 = 0
for (let k = 0; k &lt; 1000; k++) {
    sum1 +=window.performance.getEntriesByName(&apos;test empty object&apos;)[k].duration
}
let averge1 = sum1/1000;
console.log(averge1*1000);

function EventHandlers() {};
EventHandlers.prototype = Object.create(null);
_events = new EventHandlers();_events.test=&apos;test&apos;;
for (let i = 0; i &lt; 1000; i++) {
    window.performance.mark(&apos;test empty object start&apos;);
    console.log(_events.test);
    window.performance.mark(&apos;test empty object end&apos;);
    window.performance.measure(&apos;test empty object&apos;,&apos;test empty object start&apos;,&apos;test empty object end&apos;);
} 
let sum1 = 0
for (let k = 0; k &lt; 1000; k++) {
    sum1 +=window.performance.getEntriesByName(&apos;test empty object&apos;)[k].duration
}
let averge1 = sum1/1000;
console.log(averge1*1000);
</code></pre><p>第一段执行时间：111.86000000001695；<br>第二段执行时间：108.37000000001353;<br>多执行几次会发现，第一段也存在时间上短于第二段执行时间的情况。总体来看，第二段时间上更短，但两次时间比较相近。</p>
<p>我自己的想法是，使用nodeJS源码中这样创建空对象的方式，在对对象属性的读取上能够节省原型链查找的时间。但是，如果一个属性直接在该对象上，即hasOwnProperty()为true，是否还有节省查找时间，性能优化的空间呢？</p>
<p>另外，不同浏览器引擎的处理可能也存在差别，即使是流行的V8引擎，处理机制也“深不可测”。同时，benchmark中都是对同一属性的读取，一般来讲浏览器引擎对同样的操作行为应该会有一个“cache”机制：据我了解JIT(just-in-time)实时汇编，会将重复执行的”hot code”编译为本地机器码，极大增加效率。所以benchmark实现的purity也有被一定程度的干扰。不过好在测试实例都是在相同环境下执行。</p>
<p>所以源码中，此处性能优化上的2倍数值，我持一定的保留态度。</p>
<h3 id="addListener实现"><a href="#addListener实现" class="headerlink" title="addListener实现"></a>addListener实现</h3><p><a href="https://github.com/HOUCe/eventEmitter/blob/master/src/common/event/node-eventEmitter.js" target="_blank" rel="external">经过整理，适当删减后的源码点击这里查看</a>，保留了我的注释。我们来一步一步解读下源码。</p>
<p>判断添加的监听器是否为函数类型，使用了typeof进行验证：</p>
<pre><code>if (typeof listener !== &apos;function&apos;) {
    throw new TypeError(&apos;&quot;listener&quot; argument must be a function&apos;);
}
</code></pre><p>接下来，要分为几种情况。<br>case1:<br>判断_events表是否已经存在，如果不存在，则说明是第一次为eventEmitter实例添加事件和监听器，需要新创建_events：</p>
<pre><code>if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
} 
</code></pre><p>还记得EventHandlers是什么吗？忘记了把屏幕往上滚动再看一下吧。</p>
<p>同时，添加指定的事件和此事件对应的监听器：</p>
<pre><code>existing = events[type] = listener;
++target._eventsCount;
</code></pre><p>注意第一次创建时，为了节省内存，提高性能，events[type]值是一个监听器函数。如果再次为相同的events[type]添加监听器时（下面case2），events[type]对应的值需要变成一个数组来存储。</p>
<p>case2:<br>又啰嗦一遍：如果_events已存在，在为相关事件添加监听器时，需要判断events[type]是函数类型（只存在一个监听函数）还是已经成为了一个数组类型（已经存在一个以上监听函数）。<br>并且根据相关参数prepend，分为监听器数组头部插入和尾部插入两种情况，以保证监听器的顺序执行：</p>
<pre><code>if (typeof existing === &apos;function&apos;) {
    existing = events[type] = prepend ? [listener, existing] :
                                      [existing, listener];
} 
else {
    if (prepend) {
        existing.unshift(listener);
    } 
    else {
        existing.push(listener);
    }
}
</code></pre><p>case3:<br>在阅读源码时，我还发现了一个很“诡异”的逻辑：</p>
<pre><code> if (events.newListener) {
    target.emit(&apos;newListener&apos;, type,
              listener.listener ? listener.listener : listener);
    events = target._events;
}
existing = events[type];
</code></pre><p>仔细分析，他的目的是因为nodeJS默认：当所有的eventEmitter对象在添加新的监听函数时，都会发出newListener事件。这其实也并不奇怪，我个人认为这么设计还是非常合理的。</p>
<p>cae4:<br>之前介绍了我们可以设置一个事件对应的最大监听器个数，nodeJS源码中通过这样的代码来实现：</p>
<pre><code>EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== &apos;number&apos; || n &lt; 0 || isNaN(n)) {
        throw new TypeError(&apos;&quot;n&quot; argument must be a positive number&apos;);
    }
    this._maxListeners = n;
    return this;
};
</code></pre><p>当对这个值进行了设置之后，如果超过此阈值，将会进行报警：</p>
<pre><code>if (!existing.warned) {
    m = $getMaxListeners(target);
    if (m &amp;&amp; m &gt; 0 &amp;&amp; existing.length &gt; m) {
        existing.warned = true;
        const w = new Error(&apos;Possible EventEmitter memory leak detected. &apos; +
                            `${existing.length} ${String(type)} listeners ` +
                            &apos;added. Use emitter.setMaxListeners() to &apos; +
                            &apos;increase limit&apos;);
        w.name = &apos;MaxListenersExceededWarning&apos;;
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        process.emitWarning(w);
    }
}
</code></pre><h3 id="emit发射器实现"><a href="#emit发射器实现" class="headerlink" title="emit发射器实现"></a>emit发射器实现</h3><p>有了之前的注册监听器过程，那么我们再来看看监听器是如何被触发的。其实触发过程直观上并不难理解，核心思想就是将监听器数组中的每一项，即监听函数逐个执行就好了。</p>
<p><a href="https://github.com/HOUCe/eventEmitter/blob/master/src/common/event/node-eventEmitter.js" target="_blank" rel="external">经过整理，适当删减后的源码</a>同样可以这里找到。源码中，包含了较多的错误信息处理内容，忽略不表。下面我挑出一些“出神入化”的细节来分析。</p>
<p>首先，有了上面的分析，我们现在可以清晰的意识到某个事件的监听处理可能是一个函数类型，表示该事件只有一个事件处理程序；也可能是个数组，表示该事件有多个事件处理程序，存储在监听器数组中。（我又啰嗦了一遍，因为理解这个太重要了，不然你会看晕的）</p>
<p>同时，emit方法可以接受多个参数。第一个参数为事件类型：type，下面两行代码用于获取某个事件的监听处理类型。用isFn布尔值来表示。</p>
<pre><code>handler = events[type];
var isFn = typeof handler === &apos;function&apos;;
</code></pre><p>isFn为true，表示该事件只有一个监听函数。否则，存在多个，储存在数组中。</p>
<p>源码中对于emit参数个数有判断，并进行了switch分支处理：</p>
<pre><code>switch (len) {
    case 1:
        emitNone(handler, isFn, this);
        break;
    case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
    case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
    case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
    // slower
    default:
        args = new Array(len - 1);
        for (i = 1; i &lt; len; i++) {
            args[i - 1] = arguments[i];
        }
        emitMany(handler, isFn, this, args);
}
</code></pre><p>我们挑一个相对最复杂的看一下——默认模式调用的emitMany：</p>
<pre><code>function emitMany(handler, isFn, self, args) {
    if (isFn) {
        handler.apply(self, args);
    }
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i &lt; len; ++i) {
            listeners[i].apply(self, args);
        }
    }
}
</code></pre><p>对于只有一个事件处理程序的情况（isFn为true），直接执行：</p>
<pre><code>handler.apply(self, args);
</code></pre><p>否则，便使用for循环，逐个调用：</p>
<pre><code>listeners[i].apply(self, args);
</code></pre><p>非常有意思的一个细节在于：</p>
<pre><code>var listeners = arrayClone(handler, len);
</code></pre><p>这里需要读者细心体会。</p>
<p>源码读到这里，我不禁要感叹设计的严谨精妙之处。上面代码处理的意义在于：防止在一个事件监听器中监听同一个事件，从而导致死循环的出现。<br>如果您不理解，且看我这个例子：</p>
<pre><code>let emitter = new eventEmitter;
emitter.on(&apos;message1&apos;, function test () {
    // some codes here
    // ...
    emitter.on(&apos;message1&apos;, test}
});
emit(&apos;message1&apos;);
</code></pre><p>讲道理，正常来讲，不经过任何处理，上述代码在事件处理程序内部又添加了对于同一个事件的监听，这必然会带来死循环问题。<br>因为在emit执行处理程序的时候，我们又向监听器队列添加了一项。这一项执行时，又会“子子孙孙无穷匮也”的向监听器数组尾部添加。</p>
<p>源码中对于这个问题的解决方案是：在执行emit方法时，使用arrayClone方法拷贝出另一个一模一样的数组，进而执行它。这样一来，当我们在监听器内监听同一个事件时，的确给原监听器数组添加了新的监听函数，但并没有影响到当前这个被拷贝出来的副本数组。在循环中，我们执行的也是这个副本函数。</p>
<h3 id="单次监听器once实现"><a href="#单次监听器once实现" class="headerlink" title="单次监听器once实现"></a>单次监听器once实现</h3><p>once(event, listener)是为指定事件注册一个单次事件处理程序，即监听器最多只会触发一次，触发后立刻解除该监听器。</p>
<p>实现方式主要是在进行监听器绑定时，对于监听函数进行一层包装。该包装方式在原有函数上添加一个flag标识位，并在触发监听函数前就调用removeListener()方法，除掉此监听函数。我理解，这是一种“双保险”的体现。</p>
<p>代码里，我们可以抽丝剥茧（已进行删减）学习一下：</p>
<pre><code> EventEmitter.prototype.once = function once(type, listener) {
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
</code></pre><p>once方法调用on方法（即addListener方法，on为别名），第二个参数即监听程序进行_onceWrap化包装，包装过程为：</p>
<pre><code>this.target.removeListener(this.type, this.wrapFn);
if (!this.fired) {
    this.fired = true;
    this.listener.apply(this.target, arguments);
}
</code></pre><p>_onceWrap化的主要思想是将once第二个参数listener的执行，包上了一次判断，并在执行前进行removeListener删除该监听程序。：</p>
<pre><code>this.listener.apply(this.target, arguments);
</code></pre><h3 id="removeListener的惊鸿一瞥"><a href="#removeListener的惊鸿一瞥" class="headerlink" title="removeListener的惊鸿一瞥"></a>removeListener的惊鸿一瞥</h3><p>removeListener(type, listener)移除指定事件的某个监听器。其实这个实现思路也比较容易理解，我们已经知道events[type]可能是函数类型，也可能是数组类型。如果是数组类型，只需要进行遍历，找到相关的监听器进行删除就可以了。</p>
<p>不过关键问题就在于对数组项的删除。</p>
<p>平时开发，我们常用splice进行数组中某一项的删除，99％的case都会想到这个方法。可是nodeJS相关源码中，对于删除进行了优化。自己封装了一个spliceOne方法，用于删除数组中指定角标。并且号称这个方法比使用splice要快1.5倍。我们就来看一下他是如何实现的：</p>
<pre><code>function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k &lt; n; i += 1, k += 1) {
        list[i] = list[k];
        list.pop();
    }
}
</code></pre><p>传统删除方法：</p>
<pre><code>list.splice(index, 1);
</code></pre><p>究竟是否计算更快，我也实现了一个benchmark，产生长度为1000的数组，删除其第52项。反复执行1000次求平均耗时:</p>
<pre><code>let arr = Array.from(Array(100).keys());
for (let i = 0; i &lt; 1000; i++) {
    window.performance.mark(&apos;test splice start&apos;);
    arr.splice(52, 1);
    window.performance.mark(&apos;test splice end&apos;);
    window.performance.measure(&apos;test splice&apos;,&apos;test splice start&apos;,&apos;test splice end&apos;);
}
let sum1 = 0
for (let k = 0; k &lt; 1000; k++) {
    sum1 +=window.performance.getEntriesByName(&apos;test splice&apos;)[k].duration
}
let averge1 = sum1/1000;
console.log(averge1*1000); // 1.7749999999869034


let arr = Array.from(Array(100).keys());
for (let i = 0; i &lt; 1000; i++) {
    window.performance.mark(&apos;test splice start&apos;);
    spliceOne(arr, 52);
    window.performance.mark(&apos;test splice end&apos;);
    window.performance.measure(&apos;test splice&apos;,&apos;test splice start&apos;,&apos;test splice end&apos;);
}
let sum1 = 0
for (let k = 0; k &lt; 1000; k++) {
    sum1 +=window.performance.getEntriesByName(&apos;test splice&apos;)[k].duration
}
let averge1 = sum1/1000;
console.log(averge1*1000); // 1.5350000000089494
</code></pre><p>明显使用spliceOne方法更快，时间上缩短了13.5%，不过依然没有达到官方的1.5，需要说明的是我采用最新版本的Chrome进行测试。</p>
<h2 id="自己造轮子"><a href="#自己造轮子" class="headerlink" title="自己造轮子"></a>自己造轮子</h2><p>前文我们感受了nodeJS中的eventEmitter实现方式。我也对于其中的核心方法，在源码层面进行了剖析。学习到了“精华”之后，更重要的要学以致用，自己实现一个基于ES6的事件发布订阅系统。</p>
<p>我的实现版本中充分利用了ES6语法特性，并且相对于nodeJS实现减少了一些“不必要的”优化和判断。</p>
<p>因为nodeJS的实现中，很多api在前端浏览器环境开发中并用不到。所以我对对外暴露的方法进行了精简。最终实现上，除去注释部分，只用了不到40行代码。如果您有兴趣，可以去<a href="">代码仓库</a>访问，整个逻辑还是很简单的。</p>
<p>里面同时附赠了我同事@颜海镜大神基于zepto实现版本，以及nodeJS events模块源码，方便读者进行对比。<br>整个过程编写时间仓促，其中必然不乏疏漏之处，还请您斧正并与我讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于nodeJS源码events模块的阅读，令我受益匪浅。设计层面上，优秀的包装和抽象思路对我一定的启发；实现层面上，很多“意想不到”的case处理，让我“叹为观止”。</p>
<p>虽然业务上暂时使用不到nodeJS，但是对于每一个前端开发人员来说，这样的学习我认为是有必要的。今后，我会整理出文章，总结对nodeJS源码更多模块的分析，希望同读者能够保持交流和探讨。</p>
<p>整篇文章里面列出的benchmark，我认为并不完美。同时，对于浏览器引擎处理上，我存在知识盲点和漏洞，希望有大神给与斧正。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，nodeJS改变了整个前端开发生态。本文通过分析nodeJS当中events模块源码，由浅入深实现了属于自己的ES6事件观察者系统。千万不要被nodeJS的外表吓到，不管你是写nodeJS已经轻车熟路的老司机，还是初入前端的小菜鸟，都不妨碍对这篇文章的阅读和理解。
    
    </summary>
    
      <category term="js" scheme="https://exp-team.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://exp-team.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第11001期</title>
    <link href="https://exp-team.github.io/blog/2017/03/17/weekly/weekly-11001/"/>
    <id>https://exp-team.github.io/blog/2017/03/17/weekly/weekly-11001/</id>
    <published>2017-03-16T16:00:00.000Z</published>
    <updated>2017-03-18T06:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>3.13-3.17，程序员不该互相鄙视</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="程序员不该互相鄙视"><a href="#程序员不该互相鄙视" class="headerlink" title="程序员不该互相鄙视"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713089&amp;idx=1&amp;sn=d9f72a559f82518c86995e70ac66e109&amp;chksm=bec0625289b7eb44461d6bcd42d27dad0c7bbfd1cbc6afab6543018a93683ab20d490210b2d6&amp;mpshare=1&amp;scene=1&amp;srcid=0316Raw0IUByU6Hhwd4P0xmw#rd" target="_blank" rel="external">程序员不该互相鄙视</a></h3><p>虽然前端处于鄙视链的末端，但是我们提议程序员不应该互相鄙视</p>
<h3 id="2017前端工具趋势"><a href="#2017前端工具趋势" class="headerlink" title="2017前端工具趋势"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226220&amp;idx=1&amp;sn=91a135e3b6ce38753fae9bd60a14203f&amp;chksm=bd4959e88a3ed0fe4ad3388af8887506619f35b7fd83fa36d8b9b9ee02bc69182b2f05a1e2c8&amp;mpshare=1&amp;scene=1&amp;srcid=0317pJQS7a64bbUl9eoEzzFW#rd" target="_blank" rel="external">2017前端工具趋势</a></h3><p>工欲善其事必先利其器，2017年了你在使用什么工具？</p>
<h3 id="2016-年崛起的-JS-项目"><a href="#2016-年崛起的-JS-项目" class="headerlink" title="2016 年崛起的 JS 项目"></a><a href="https://zhuanlan.zhihu.com/p/25709238" target="_blank" rel="external">2016 年崛起的 JS 项目</a></h3><p>2016是前端飞速发展的一年，这一年诞生了一大批前端项目，错过的同学看这一篇文章就足够了</p>
<a id="more"></a>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="Source-Map入门教程"><a href="#Source-Map入门教程" class="headerlink" title="Source Map入门教程"></a><a href="https://blog.fundebug.com/2017/03/13/sourcemap-tutorial/" target="_blank" rel="external">Source Map入门教程</a></h3><h3 id="理解关键渲染路径"><a href="#理解关键渲染路径" class="headerlink" title="理解关键渲染路径"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226203&amp;idx=1&amp;sn=c9a13663431d49b408af023766b6456f&amp;chksm=bd4959df8a3ed0c9c2173d58ea35252d72e10c30f1bf2944a969e7c6ebccae8b0340878eb611&amp;mpshare=1&amp;scene=1&amp;srcid=0316zVMVLQ2vDP4XgzOoXIfa#rd" target="_blank" rel="external">理解关键渲染路径</a></h3><h3 id="LsLoader-移动WEB工程化缓存方案"><a href="#LsLoader-移动WEB工程化缓存方案" class="headerlink" title="LsLoader 移动WEB工程化缓存方案"></a><a href="https://zhuanlan.zhihu.com/p/21357211?utm_source=wechat_session&amp;utm_medium=social" target="_blank" rel="external">LsLoader 移动WEB工程化缓存方案</a></h3><h3 id="Effective前端7：加快页面打开速度"><a href="#Effective前端7：加快页面打开速度" class="headerlink" title="Effective前端7：加快页面打开速度"></a><a href="https://zhuanlan.zhihu.com/p/25718817" target="_blank" rel="external">Effective前端7：加快页面打开速度</a></h3><p>这个系列特别好，强烈建议大家读一读</p>
<h3 id="面试中要注意的-3-个-JavaScript-问题"><a href="#面试中要注意的-3-个-JavaScript-问题" class="headerlink" title="面试中要注意的 3 个 JavaScript 问题"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964369&amp;idx=1&amp;sn=167ca080a10c5cab77432f8d8ee4ccb9&amp;chksm=843aedf7b34d64e1c325bab612cdf174b86ca587d4114fd4c2120640ecc1fa62d8b50bd847ec&amp;mpshare=1&amp;scene=1&amp;srcid=0315uSE7TjEwyIv6f8ZaJ4mj#rd" target="_blank" rel="external">面试中要注意的 3 个 JavaScript 问题</a></h3><p>最近面试中我都会问这三个问题</p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="如何落地和管理一个“大前端”团队-饿了么大前端团队解密"><a href="#如何落地和管理一个“大前端”团队-饿了么大前端团队解密" class="headerlink" title="如何落地和管理一个“大前端”团队?饿了么大前端团队解密"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650995610&amp;idx=1&amp;sn=d44ad482dc30a3eae727571f2630a348&amp;chksm=bdbf03c98ac88adf41c06ed5cde7378adc4796d4426b7e61bd3c17aaa675f2dc5eaaf0c14a2e&amp;mpshare=1&amp;scene=1&amp;srcid=03154V3qyLs6nGka4qfTTTMX#rd" target="_blank" rel="external">如何落地和管理一个“大前端”团队?饿了么大前端团队解密</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3.13-3.17，程序员不该互相鄙视&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;程序员不该互相鄙视&quot;&gt;&lt;a href=&quot;#程序员不该互相鄙视&quot; class=&quot;headerlink&quot; title=&quot;程序员不该互相鄙视&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=2650713089&amp;amp;idx=1&amp;amp;sn=d9f72a559f82518c86995e70ac66e109&amp;amp;chksm=bec0625289b7eb44461d6bcd42d27dad0c7bbfd1cbc6afab6543018a93683ab20d490210b2d6&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0316Raw0IUByU6Hhwd4P0xmw#rd&quot;&gt;程序员不该互相鄙视&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;虽然前端处于鄙视链的末端，但是我们提议程序员不应该互相鄙视&lt;/p&gt;
&lt;h3 id=&quot;2017前端工具趋势&quot;&gt;&lt;a href=&quot;#2017前端工具趋势&quot; class=&quot;headerlink&quot; title=&quot;2017前端工具趋势&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;amp;mid=2651226220&amp;amp;idx=1&amp;amp;sn=91a135e3b6ce38753fae9bd60a14203f&amp;amp;chksm=bd4959e88a3ed0fe4ad3388af8887506619f35b7fd83fa36d8b9b9ee02bc69182b2f05a1e2c8&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0317pJQS7a64bbUl9eoEzzFW#rd&quot;&gt;2017前端工具趋势&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;工欲善其事必先利其器，2017年了你在使用什么工具？&lt;/p&gt;
&lt;h3 id=&quot;2016-年崛起的-JS-项目&quot;&gt;&lt;a href=&quot;#2016-年崛起的-JS-项目&quot; class=&quot;headerlink&quot; title=&quot;2016 年崛起的 JS 项目&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25709238&quot;&gt;2016 年崛起的 JS 项目&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;2016是前端飞速发展的一年，这一年诞生了一大批前端项目，错过的同学看这一篇文章就足够了&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你撸一个跑男动画 顺便抽丝剥茧CSS3动画奥秘</title>
    <link href="https://exp-team.github.io/blog/2017/03/14/web/animation-runningman/"/>
    <id>https://exp-team.github.io/blog/2017/03/14/web/animation-runningman/</id>
    <published>2017-03-13T16:00:00.000Z</published>
    <updated>2017-03-14T06:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名真正的前端开发者，我们不能只关注前端逻辑部分。毕竟“水银泄地”般的页面设计和“炫酷逼真”的动画效果，是我们区别于其他程序员所特有的优势之一。尽量百分之百的还原视觉稿，为UE设计灵感和用户视觉享受架起一座桥梁：正所谓“晋帝时祭北郊，更祝版，工人削之，笔入木三分。”<br>借古书法形容我们的代码，当真是恰当准确又自恋无比。</p>
<p>之前的一些文章大多都是分享JS相关内容。今天轻松一下，我来谈谈前端页面的动画部分。通过剖析一个上线的“跑男”动画实例，来把CSS3中动画相关的知识点抽丝剥茧，一网打尽。如果读者有自己的感想或者不一样的见解，欢迎一起讨论。</p>
<p>整个项目的<a href="https://github.com/HOUCe/runningman-animation" target="_blank" rel="external">Github地址</a>可以参考<a href="https://github.com/HOUCe/runningman-animation" target="_blank" rel="external">这里</a>。对比线上效果，这个仓库进行了90%的删减，但是更加适合练手和理解。感兴趣的读者欢迎拉下来自己玩一玩。里面只有一关动画，您可以比葫芦画瓢进行调试练习。</p>
<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>这是一个运营活动页面——“春季马拉松大比拼”：用户以闯关形式参加，并进行角色扮演。在满足一定条件下，自己扮演的马拉松选手会绕着跑道（非正规跑道形状）前进，向终点发起冲击。</p>
<p>部分页面动画效果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-cabc0a036d80d926.gif?imageMogr2/auto-orient/strip" alt="部分动画效果截图"></p>
<p>当然，这个动画并不完美。考虑到时间性价比，我只用了两帧重复循环模拟摆腿动作。但也达到了运营和产品小妹的需求。如果在没有上线压力的情况下，我们完全可以拆分更多帧，把他打磨的更流畅顺滑。</p>
<p>首先，我们来看一下它的具体实现方式吧。如果您觉得很简单，也可以往下读，相信你也会有不一样的收获。</p>
<h2 id="动画方案"><a href="#动画方案" class="headerlink" title="动画方案"></a>动画方案</h2><p>这一系列的动画设计，出于性能和简单的考虑，我采用了纯CSS3来实现。CSS3实现动画，主要有两种方式：transition属性和animation属性。前者是用来“平滑的改变CSS的值”。一般对于需要特定帧处理的动画，这显然是苍白无力的。我就不过多介绍了。这里重点介绍一下animation属性。</p>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation属性其实是一个简写属性，就像我们更加熟悉的“background”属性一样。它用于设置六个动画属性：</p>
<p>1）animation-name<br>2）animation-duration<br>3）animation-timing-function<br>4）animation-delay<br>5）animation-iteration-count<br>6）animation-direction</p>
<p>最重要的就是animation-name，它规定需要绑定的keyframes名称。keyframes，我们用来定义几个关键节点帧。</p>
<p>具体我不会进行科普。如果初学者不了解，社区上关于这些的资料可是一大把。</p>
<h3 id="跑男开跑"><a href="#跑男开跑" class="headerlink" title="跑男开跑"></a>跑男开跑</h3><p>回到我们具体的业务场景，我们进行分析。跑男的动画其实可以拆分为两种：<br>1）一个是交替摆腿；<br>2）另一个是位置移动。<br>这两个动作要严丝合缝的结合。能把这个想清楚，那就基本思路理解了。</p>
<p>接着，如何让这两种动画一起施加在“静止的”跑男身上呢？</p>
<p>我采用了增加一个div标签包裹的方式：</p>
<pre><code>&lt;div class=&quot;man-wrapper&quot; id=&quot;man-wrapper&quot;&gt;
    &lt;div class=&quot;man&quot; id=&quot;man&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>‘man-wrapper’这个div与’man’这个div尺寸大小完全一致，视觉上绝对重合。父节点处理位移，子节点负责交替摆腿：</p>
<pre><code>.man-wrapper {
    display: inline-block;
    width: 46px;
    height: 75px;
    position: absolute;
}
.man {
    display: inline-block;
    width: 46px;
    height: 75px;
    background: url(img/sprite.png);
    position: absolute;
    top: 0;
    left: 0;
}
</code></pre><p>当需要触发位移，开启跑步状态时，父节点添”start-run”类：</p>
<pre><code>$(&apos;.man-wrapper&apos;).addClass(&apos;start-run&apos;);
</code></pre><p>子节点添加：</p>
<pre><code>$(&apos;#man&apos;).addClass(&apos;running&apos;);
</code></pre><h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><p>关于“start-run”位移的动画设计，在跑道上直道部分相对简单，我们思路是使用transform：translate3d。但是视觉稿上存在不少于5处不规则弯道，在不改变原图的基础上，在不增加多余图片的原则下，我们可以使用transform：rotate3d，使跑男进行侧身。具体设计看下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-22e1cfcd31e6b7e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画部分分解"></p>
<p>1）1-2和4-5，只需要改变transform：translate3d；<br>2）2-4部分，即2，3，4这三个阶段是为了弯道准备的。当然，如果时间充足，我们完全可以拆分的更加细致，更加细分。<br>3）其中3是弯道中心的45度转身：rotate3d(0,0,1,45deg);<br>4）其中4是已经完全转身：rotate3d(0,0,1,90deg);</p>
<p>具体代码：</p>
<pre><code>.start-run {
    animation: start-run 5000ms; 
    animation-fill-mode: forwards;
    animation-timing-function: linear;
}
@keyframes start-run {
    0% {
        transform: translate3d(0, 0, 0);
    }
    35% {
        transform: translate3d(0, 155px, 0) rotate3d(0, 0, 1, 0deg);
    }
    50% {
        transform: translate3d(20px, 224px, 0) rotate3d(0, 0, 1, -45deg);
    }
    70% {
        transform: translate3d(80px, 242px, 0) rotate3d(0, 0, 1, -90deg);
    }
    100% {
        transform: translate3d(200px, 243px, 0) rotate3d(0, 0, 1, -90deg);
    }
}
</code></pre><p>为什么是35%，50%，70%呢？这个是我调试出来，相对能达到顺畅效果。如果追求更严谨的话，完全可以列一个极坐标计算一下位移和时间。当然这样子成本会比较大。</p>
<p>还有一点值得一提的是animation-timing-function: linear; 一般马拉松中段，都近似于匀速跑吧～</p>
<p>解决完了位移的问题，我们来看摆腿动作。这个其实就是两张图片在交替播放。其实就是gif图原理。我使用了background-position来切换精灵图片的方式处理：</p>
<pre><code>.running {
    animation: running-man 1200ms steps(2) infinite;
}
@keyframes running-man {
    0% {
        background-position: 0 0;
    }
    50% {
        background-position: 92px 0;
    }
}
</code></pre><p>千万不要扫一眼代码完事儿，这里还有一些最重要的细节要注意。首先是“infinite”的使用，这个应该没什么意外吧。另外，你可曾注意了steps这个函数?</p>
<h3 id="steps-函数实现阶跃动画"><a href="#steps-函数实现阶跃动画" class="headerlink" title="steps()函数实现阶跃动画"></a>steps()函数实现阶跃动画</h3><p>我们知道animation定义的关键帧之间是“平滑过渡”的。这个平滑过渡怎么理解呢？我精心做了一个“反例”示图来说明：<br>在使用keyframes改变雪碧图background-position时，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-de26aeaa8879fa44.gif?imageMogr2/auto-orient/strip" alt="动画部分分解反面示例"></p>
<p>这样的”平滑过度”显然不是我们想要的。</p>
<p>所以，在切换雪碧图背景的方案下，steps()就要派上用场了。顺便说一句，最近面试一些人，提到熟悉CSS3动画，但是大部分都还不知道这个steps阶跃函数。如果你还不清楚，可以参考<a href="http://www.cnblogs.com/BATAKK/p/5301819.html" target="_blank" rel="external">这里。</a></p>
<p>借助steps()函数，我们实现了交替跑动的分解动画：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4363003-4cd1498e2f1c9504.gif?imageMogr2/auto-orient/strip" alt="动画部分分解"></p>
<h2 id="还不完美"><a href="#还不完美" class="headerlink" title="还不完美"></a>还不完美</h2><p>做到这里，其实还没有完全结束。有一些值得我们思考的问题。</p>
<p>1）真的有必要多一个标签，来相互结合生成动画吗？<br>其实不是的，animation很神奇很强大的一点在于：它可以接受多个动画属性序列。比如上边那种情况我们完全可以这样实现：</p>
<pre><code>.running {
    animation: start-run 5000ms forwards linear, running-man 1200ms steps(2) infinite
}
</code></pre><p>2) 如果刻意追求更佳完美的动画，我们还需要哪些储备？<br>不得不要说知识储备上，就是数学和物理知识了。比如，二次方曲线、三次方曲线、一直到五次方曲线，正弦余弦、圆弧、抛物线、反弹曲线、弹簧曲线等等。如果你对研究这些有兴趣，这里安利一些：<a href="https://greensock.com/" target="_blank" rel="external">高性能动画实现</a>以及<a href="https://greensock.com/ease-visualizer" target="_blank" rel="external">可视化1</a>，<a href="http://jeremyckahn.github.io/stylie/" target="_blank" rel="external">可视化2。</a></p>
<p>除了数学公式以外，也需要我们掌握样式预处理器函数使用。毕竟，那么多帧我们不可能自己手动实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>流畅高效的动画，绝非一朝一夕就能完成，需要各方面甚至跨领域的积累。如果你对此很感兴趣，欢迎讨论。我也在工作过程中，积累了很多动画实现效果，愿意同大家一起分享，互通资源。</p>
<p>最后，这篇文章中截图部分采用了我厂（狼厂）UE：许冬设计师的视觉稿，和PM：田小甜大小姐的交互设计。</p>
<p>PS：百度知识搜索部大前端继续招兵买马，有意向者火速联系。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名真正的前端开发者，我们不能只关注前端逻辑部分。毕竟“水银泄地”般的页面设计和“炫酷逼真”的动画效果，是我们区别于其他程序员所特有的优势之一。尽量百分之百的还原视觉稿，为UE设计灵感和用户视觉享受架起一座桥梁：正所谓“晋帝时祭北郊，更祝版，工人削之，笔入木三分。”&lt;b
    
    </summary>
    
      <category term="web" scheme="https://exp-team.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://exp-team.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>expfe技术周刊第11000期</title>
    <link href="https://exp-team.github.io/blog/2017/03/10/weekly/weekly-11000/"/>
    <id>https://exp-team.github.io/blog/2017/03/10/weekly/weekly-11000/</id>
    <published>2017-03-09T16:00:00.000Z</published>
    <updated>2017-03-11T16:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>3.6-3.10，你的前端工作经验值钱吗？</p>
<h2 id="本期推荐"><a href="#本期推荐" class="headerlink" title="本期推荐"></a>本期推荐</h2><h3 id="为什么你的前端工作经验不值钱？"><a href="#为什么你的前端工作经验不值钱？" class="headerlink" title="为什么你的前端工作经验不值钱？"></a><a href="http://mp.weixin.qq.com/s?__biz=MzI3NzIzMDY0NA==&amp;mid=2247484101&amp;idx=1&amp;sn=6b095010810a9dfa0c134fa9d116c1ce&amp;chksm=eb68279edc1fae8847b479592461a9f62136ac2c5b5047baaf82d0f2c63a3f67bbb643a3a887&amp;mpshare=1&amp;scene=1&amp;srcid=030683oKsqW95apeyMRaqppM" target="_blank" rel="external">为什么你的前端工作经验不值钱？</a></h3><p>之前看过一本书叫做《技巧》，里面提到有些人不是有10年工作经验，而是把1年的工作经验用了10年，永远不要停止学习，永远不要待在舒适区</p>
<h3 id="前端开发者应知必会：浏览器是如何渲染网页的"><a href="#前端开发者应知必会：浏览器是如何渲染网页的" class="headerlink" title="前端开发者应知必会：浏览器是如何渲染网页的"></a><a href="https://zhuanlan.zhihu.com/p/25554352" target="_blank" rel="external">前端开发者应知必会：浏览器是如何渲染网页的</a></h3><p>每次看都会有收获，温故而知新</p>
<h3 id="如何用-fis3-来开发-React"><a href="#如何用-fis3-来开发-React" class="headerlink" title="如何用 fis3 来开发 React?"></a><a href="http://fex.baidu.com/blog/2016/04/develop-react-with-fis3/" target="_blank" rel="external">如何用 fis3 来开发 React?</a></h3><p>最近的一个项目中用上了react，觉得这个有点意思，那么fis3下开发react也是蛮爽的</p>
<a id="more"></a>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="HTML不能这么写、你造吗？"><a href="#HTML不能这么写、你造吗？" class="headerlink" title="HTML不能这么写、你造吗？"></a><a href="https://zhuanlan.zhihu.com/p/25410484?utm_source=wechat_session&amp;utm_medium=social" target="_blank" rel="external">HTML不能这么写、你造吗？</a></h3><p>html5中元素不再只有块级和行内，嵌套规则也变得需要表格来维护了</p>
<h3 id="五分钟-get-你也许不知道的前端新特性"><a href="#五分钟-get-你也许不知道的前端新特性" class="headerlink" title="五分钟 get 你也许不知道的前端新特性"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650964364&amp;idx=1&amp;sn=6ac57a2111cbc3bc042d85650278c83c&amp;chksm=843aedeab34d64fc93d629315b02995a3aabb891f83116afa26b9a6e5d85630ed3aed6072309&amp;mpshare=1&amp;scene=1&amp;srcid=0309RHflqTapJLuCvi9PTOiE" target="_blank" rel="external">五分钟 get 你也许不知道的前端新特性</a></h3><h3 id="不止-React-Native、Ionic、Weex，连-Objective-C-的开发者都收到警告邮件了"><a href="#不止-React-Native、Ionic、Weex，连-Objective-C-的开发者都收到警告邮件了" class="headerlink" title="不止 React Native、Ionic、Weex，连 Objective-C 的开发者都收到警告邮件了"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&amp;mid=2652974732&amp;idx=1&amp;sn=3462a3ca8a2f10e645be76f922c7e8c2&amp;chksm=bd4afdaf8a3d74b96bb748af53ad721e826251228efc45b23fabc14f5dfe20f3d1e252f633bf&amp;mpshare=1&amp;scene=1&amp;srcid=0308Shw8MOXxeRrjzdcV4G3o" target="_blank" rel="external">不止 React Native、Ionic、Weex，连 Objective-C 的开发者都收到警告邮件了</a></h3><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="作为一个面试官，我是怎么来面试测试人员的"><a href="#作为一个面试官，我是怎么来面试测试人员的" class="headerlink" title="作为一个面试官，我是怎么来面试测试人员的"></a><a href="https://zhuanlan.zhihu.com/p/25516083?utm_medium=social&amp;utm_source=wechat_session&amp;from=singlemessage" target="_blank" rel="external">作为一个面试官，我是怎么来面试测试人员的</a></h3><p>最近也面试了不少人，一直都在</p>
<h3 id="人到中年，我就问你怕不怕？"><a href="#人到中年，我就问你怕不怕？" class="headerlink" title="人到中年，我就问你怕不怕？"></a><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650713067&amp;idx=1&amp;sn=81459616b22059bc743a3be5911156f4&amp;chksm=bec065b889b7ecae7cf84110f5f03935e59dd4cd815cb4918489bfd3092367e444b70a9b4fd5&amp;mpshare=1&amp;scene=1&amp;srcid=0307rNX7bl8qGHZbRBF9kKby" target="_blank" rel="external">人到中年，我就问你怕不怕？</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3.6-3.10，你的前端工作经验值钱吗？&lt;/p&gt;
&lt;h2 id=&quot;本期推荐&quot;&gt;&lt;a href=&quot;#本期推荐&quot; class=&quot;headerlink&quot; title=&quot;本期推荐&quot;&gt;&lt;/a&gt;本期推荐&lt;/h2&gt;&lt;h3 id=&quot;为什么你的前端工作经验不值钱？&quot;&gt;&lt;a href=&quot;#为什么你的前端工作经验不值钱？&quot; class=&quot;headerlink&quot; title=&quot;为什么你的前端工作经验不值钱？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3NzIzMDY0NA==&amp;amp;mid=2247484101&amp;amp;idx=1&amp;amp;sn=6b095010810a9dfa0c134fa9d116c1ce&amp;amp;chksm=eb68279edc1fae8847b479592461a9f62136ac2c5b5047baaf82d0f2c63a3f67bbb643a3a887&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=030683oKsqW95apeyMRaqppM&quot;&gt;为什么你的前端工作经验不值钱？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;之前看过一本书叫做《技巧》，里面提到有些人不是有10年工作经验，而是把1年的工作经验用了10年，永远不要停止学习，永远不要待在舒适区&lt;/p&gt;
&lt;h3 id=&quot;前端开发者应知必会：浏览器是如何渲染网页的&quot;&gt;&lt;a href=&quot;#前端开发者应知必会：浏览器是如何渲染网页的&quot; class=&quot;headerlink&quot; title=&quot;前端开发者应知必会：浏览器是如何渲染网页的&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25554352&quot;&gt;前端开发者应知必会：浏览器是如何渲染网页的&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;每次看都会有收获，温故而知新&lt;/p&gt;
&lt;h3 id=&quot;如何用-fis3-来开发-React&quot;&gt;&lt;a href=&quot;#如何用-fis3-来开发-React&quot; class=&quot;headerlink&quot; title=&quot;如何用 fis3 来开发 React?&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://fex.baidu.com/blog/2016/04/develop-react-with-fis3/&quot;&gt;如何用 fis3 来开发 React?&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;最近的一个项目中用上了react，觉得这个有点意思，那么fis3下开发react也是蛮爽的&lt;/p&gt;
    
    </summary>
    
      <category term="weekly" scheme="https://exp-team.github.io/categories/weekly/"/>
    
    
      <category term="weekly" scheme="https://exp-team.github.io/tags/weekly/"/>
    
  </entry>
  
</feed>
